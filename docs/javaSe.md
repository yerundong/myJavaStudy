# 总概

 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。

 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。



[JDK各版本发布时间](https://zhuanlan.zhihu.com/p/269860416)



**Java基础知识图解：**

![Java基础知识图解](.\images\javaSe\总概\Java基础知识图解.png)



## 1 动态语言 vs 静态语言

1. **动态语言**

   动态语言是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。`通俗点说就是在运行时代码可以根据某些条件改变自身结构`。

   **主要动态语言：**Object-C、C#、JavaScript、PHP、Python、Erlang等。

   

2. **静态语言**

   静态语言与动态语言相对应的，运行时结构不可变的语言就是静态语言。

   **主要静态语言：**Java、C、C++等。

   

> 注意：Java虽然是静态语言，但Java可以称之为“准动态语言”，即Java有一定的动态性，就是因为我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！



## 2 面向对象

 面向对象(Object Oriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。

 面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。

 面向对象编程（Object Oriented Programming，OOP）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是**类和对象**。



**面向对象特征的三个特征：**封装性、继承性、多态性



**面向对象编程（OOP）与面向过程编程（POP）的区别：**

1. 二者都是一种编程思想，面向对象是相对于面向过程而言的。

   **面向过程，强调的是功能行为，以函数为最小单位，着重于怎么做**。

   **面向对象，将功能封装进对象， 强调具备了功能的对象，以类/对象为最小单位，着重于谁来做。**

   

2. 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。



**理解Java中的“万事万物皆对象”：**

1. 在Java中，我们将功能、结构等封装到类中，填过类的实例化，来调用具体的功能结构
2. 涉及到Java语言与前端、后端的数据库交互时，前后端结构在Java层面交互时，都体现为类、对象



## 3 设计一个项目的思路

1. 罗列出项目中存在的实体
2. 分析实体需要体现的属性和功能，以此设计类和接口
3. 将类实例化成对象。对象是解决问题的最终工具



## 4 常量池

- [Java中几种常量池的区分](http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/)
- [常量池详解](https://zhuanlan.zhihu.com/p/64839455)
- [字符串常量池和运行时常量池是在堆还是在方法区？](https://blog.csdn.net/weixin_44556968/article/details/109468386)
- [字面量进入字符串常量池的时机](https://www.zhihu.com/question/55994121/answer/147296098)
- [JVM 常量池中存储的是对象还是引用呢？](https://www.zhihu.com/question/57109429)



常量池逻辑上是属于方法区。



Java中基本类型的包装类的大部分都实现了常量池技术，这些类是**Byte，Short，Integer，Long，Character，Boolean**，**另外两种浮点数类型（Float、Double）的包装类则没有实现**。另外Byte，Short，Integer，Long，Character这5种整型的包装类也只是在**-128到127之间**时才可使用常量池，也即对象不负责创建和管理大于127的这些类的对象。



了解[字符串常量池](#1 字符串常量池 )。



**常量池的好处**：

常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。
（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。

## 5 JDK、JRE、JVM关系

![JDK&JRE&JVM关系示意图](.\images\javaSe\总概\JDK&JRE&JVM关系示意图.png)

- **JDK：**

  Java Development Kit，Java开发工具包

- **JRE：**

  Java runtime environment，Java运行环境

- **JVM：**

  Java Virtual Machine，Java虚拟机



**使用的人群：**JDK是给开发人员用的，JRE和JVM是普通用户用的。



## 6 JVM内存

![java内存](.\images\javaSe\总概\java内存.png)

- **堆（Heap）**

  此内存区域的唯一目的就是存放对象实例几乎所有的对象。 实例都在这里分配内存，包括对象的属性（非静态）。

  这一点在Java虚拟机规范中的描述是：所有的对象实例、数组都要在堆上分配。

  - 凡是new出来的东西都，都存放在堆中。

  - 堆中的所有东西都有一个16进制的地址值。

  - 堆中的数据都有默认值。

- **栈（Stack）**

  通常所说的栈是指**虚拟机栈**。虚拟机栈用于存储**局部变量**等。 

  局部变量表存放了编译期可知长度的各种基本数据类型boolean、byte、char、short、int、float、long、double、对象引用（引用类型在堆内存的首地址），方法执行完，自动释放。

- **本地方法栈（Native Method Stack）**

  操作系统相关，调用一些C、C++等类库。

- **方法区（Method Area）**

  用于存储已被虚拟机加载的**类信息、常量（池）、静态（域）变量、即时编译器编译后的代码**。

- **寄存器（程序计数器\Program Counter Register\PC Register）**

  CPU相关。





## 7 执行顺序

1. 编译完源程序，生成字节码文件
2. JVM中的类加载器和解释器对字节码文件解释运行
3. 运行中，字节码文件中对应的类被加载到各内存中，这里涉及到内存解析



## 8 元空间

https://baijiahao.baidu.com/s?id=1664760592941035748&wfr=spider&for=pc

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：

-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。

-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：

-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集.

-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集



## 9 垃圾回收机制？

垃圾回收机制关键点


垃圾回收机制只回收JVM堆内存里的对象空间。


对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力


现在的JVM有多种垃圾回收实现算法，表现各异。


垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。


可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。


程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有
一些效果，但是系统是否进行垃圾回收依然不确定。


垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一
个新的引用变量重新引用该对象，则会重新激活对象）。


永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。

# 数据类型

Java数据类型可分为**基本类型**和**引用类型**两大类。

**基本类型分为八种：**六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 其中整数型：byte、short、int、long。

**引用类型：**类、接口、数组

![数据类型](.\images\javaSe\数据类型\数据类型.png)



## 1 默认值

存放在堆中的数据都有默认值，如数组的元素、成员变量等。

| **数据类型**           | **默认值** |
| :--------------------- | :--------- |
| byte                   | 0          |
| short                  | 0          |
| int                    | 0          |
| long                   | 0L         |
| float                  | 0.0f       |
| double                 | 0.0d       |
| char                   | 'u0000'    |
| boolean                | false      |
| String (or any object) | null       |



## 2 基本数据类型

- **byte：**

  byte 数据类型是8位、有符号的，以二进制补码表示的整数。

  - 最小值是 -128（-2^7）；
  - 最大值是 127（2^7-1）；
  - 默认值是 0；

  byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一。

  例子：byte a = 100，byte b = -50。



- **short：**

  short 数据类型是 16 位、有符号的以二进制补码表示的整数

  - 最小值是 -32768（-2^15）
  - 最大值是 32767（2^15 - 1）
  - 默认值是 0

  Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一。

  例子：short s = 1000，short r = -20000。



-  **int：**

  int 数据类型是32位、有符号的以二进制补码表示的整数。

  - 最小值是 -2,147,483,648（-2^31）
  - 最大值是 2,147,483,647（2^31 - 1）
  - 默认值是 0 

  一般地整型变量默认为 int 类型。

  例子：int a = 100000, int b = -200000。



- **long：**

  long 数据类型是 64 位、有符号的以二进制补码表示的整数。

  - 最小值是 -9,223,372,036,854,775,808（-2^63）
  - 最大值是 9,223,372,036,854,775,807（2^63 -1）
  - 默认值是 0L

  这种类型主要使用在需要比较大整数的系统上。

  例子： long a = 100000L，Long b = -200000L。

  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。



- **float：**

  float 数据类型是单精度、32位、符合IEEE 754标准的浮点数。 float 在储存大型浮点数组的时候可节省内存空间；

  - 默认值是 0.0f

  浮点数不能用来表示精确的值，如货币；

  例子：float f1 = 234.5f。

  

- **double：**

  double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型；

  - 默认值是 0.0d；

  double类型同样不能表示精确的值，如货币；

  例子：double d1 = 123.4。



- **boolean：**

  boolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；

  - 默认值是 false；

  例子：boolean one = true。



- **char：**

  char类型是一个单一的 16 位 Unicode 字符；

  - 最小值是 \u0000（即为0）；
  - 最大值是 \uffff（即为65,535）；

  char 数据类型可以储存任何字符；

  例子：char letter = 'A';。



## 3 基本类型的自动转换

基本数据类型（除布尔类型外）在某些情况下将发生数据类型自动转换。这些情况包括：赋值运算，数学运算，三目运算，传参等。



**快速记忆：** 数字相关才能玩，运算，传参，不带布尔玩



**自动类型转换（提升）特点：**

1. 代码不需要进行特殊处理，自动完成。
2. 数据范围从小到大自动转变（与字节数无关），所以也叫提升。
3. byte/short/char这三种类型在运算的时候，都默认被先提升成为int类型，然后计算
4. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）



## 4 基本类型的强制转换

向下转换，将数据是从范围大到小的转换。



**格式：** 

```java
（类型）数据
```



**快速记忆：**小小括号能强制，数字相关才能玩，就是不带布尔玩；从小到大很没问题，从大到小要亏损；byte/short/char搞特殊，常量不超范围可省略。



**注意事项：**

1. 不推荐使用，有可能发生精度损失、数据溢出
2. byte/short/char三种类型：如果【常量数据】强制转换为此三种类型，且常量数据【不超过此三种类型范围】，可以省略强制格式——"(类型)"
javac编译器将会自动隐含地补上一个(byte)(short)(char)
3. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）





## 5 包装类

Java语言是一个面向对象的语言，但并不是<u>纯面向对象的语言</u>。基本数据类型不是面向对象的，它们不具有继承性、多态性、封装性。这时，我们就需要利用包装类(Wrapper Class)将基本类型数据转化成引用类型！在实际使用中经常将基本数据类型转换成对象，便于操作，比如，集合的操作中。

> 包装类是属于引用类型，包装类都位于java.lang包下。



![包装类的继承关系](.\images\javaSe\数据类型\包装类的继承关系.png)



**基本类型与包装类的对应关系：**

| 基本类型 |      包装类       |
| :------: | :---------------: |
|   byte   |       Byte        |
|  short   |       Short       |
|   int    |  Integer【特殊】  |
|   long   |       Long        |
|  float   |       Float       |
|  double  |      Double       |
|   char   | Character【特殊】 |
| boolean  |      Boolean      |



**装箱与拆箱：** 

即基本类型和包装类之间的转换。

- 装箱：基本类型 --> 包装类对象
- 拆箱：包装类对象 --> 基本类型



**为什么需要装箱与拆箱：**

- 基本类型不可调用方法、属性等对象才有的特性
- 包装类不可直接使用算术运算符，需要先转成基本类型



**手动装箱：**new包装类的构造器

**手动拆箱：**调用包装类方法：`xxx.xxxValue()`



**自动装箱、自动拆箱：**

从JDK 1.5+开始，支持自动装箱、自动拆箱。

如：

```java
Type var = value;
```



**包装类的缓存机制（[常量池](#4 常量池)）：**

包装类内部有一个 XxxCache 的静态结构（如：IntegerCache），如果我们自动装箱的范围在：-128~127之间，就会缓存在 XxxCache.cache 这个数组里，
如果再次调用，直接使用缓存中的地址，不会再去 new 了。



目的：提高效率。

> 注意：手动装箱没有缓存（使用new），自动装箱有缓存



## 6 基本类型和String转换

**快速记忆：** 基本转String用valueOf，toString，拼接符号黑科技；String转基本用parse，只有char搞特殊。

![基本类型、包装类、String的转换](.\images\javaSe\数据类型\基本类型、包装类、String的转换.png)

### 6.1 **基本类型转String**

- String.valueOf(basic)

  如：

  ```java
  String str1 = String.valueOf((byte) 1);
  ```

- 包装类的toString方法

  如：

  ```java
  String str1 = Byte.toString((byte) 1);
  ```

- 字符串拼接方式

  如：

  ```java
  String str1 = (byte) 1 + "";
  ```



### 6.2 String转基本类型

- 包装类的`Xxx.parseXxx(str)`方法（不适用于char）

  如：

  ```java
  byte byte2 = Byte.parseByte("1");
  ```

- String --> char

  - 方式一：

    ```java
    char char1 = "A".charAt(0);
    ```

  - 方式二：

    ```java
    char char2 = (char) Integer.parseInt("65");
    ```



# 变量、常量、字面量

变量可分为[局部变量](#2 局部变量)与[成员变量](#2.1 成员变量)，与常量可分为[局部常量](#3 局部常量)与[成员常量](#8.2.1 成员常量)（以及[接口的成员常量](#4.2 常量)）。

## 1 变量

**命名格式：**小驼峰（myName）



**书写格式：**

```java
// 声明+赋值
Type var = value;

// 先声明再赋值
Type var;
var = value;

// 同时定义多个变量
Type var = value1, var2 = value2;

// 多个变量先声明再赋值
Type var1, var2;
var1 = value1;
var2 = value2;
```



**注意事项：** 

1. 变量名不能重复。
2. 对于float和long类型，后缀F和L不能忘记。
3. byte和short类型，数值不能超出范围。
4. 变量一定先定义（声明+赋值）后使用，**若不使用可以不赋值**。
5. 变量的使用不能超出作用域范围。
6. 局部变量声明后，必须显式赋值才能使用（局部变量声没有默认值）。成员变量可以不显式赋值，因为它有隐式赋值（默认值）。
7. 不能使用权限修饰符，但可以使用final修饰（常量）



**变量传递机制：**

- 基本数据类型：传递数据值
- 引用数据类型：传递地址值



## 2 常量

常量可看作特殊的变量，属于不可变的变量。在程序运行期间，固定不变的量，即“一次赋值，终生使用”，此外其他机制基本与变量一致。



**命名格式：**全大写，底杠分割，如：MY_NAME



## 3 字面量

字面量也叫字面值，直接量。在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。

字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。

```cpp
int a; // 变量
const int b = 10; // b为常量，10为字面量
string str = “hello world！”; // str 为变量，hello world！为字面量
```



**字面量的分类：**

1. 整数字面量：分为byte、short、int、long，默认为int类型。如果
2. 字符串字面量：凡是用双引号引起来的部分，叫做字符串字面量。例如："abc"、"Hello"、"123"
3. 浮点数字面量：直接写上的数字，有小数点，默认为double类型。例如：2.5、-3.14、0.0
4. 字符字面量：凡是用单引号引起来的单个字符，就做字符字面量。例如：'A'、'b'、'9'、'中'
5. 布尔字面量：只有量中取值。true、false。
6. 空字面量：null。代表没有任何数据。



**编译器的常量优化：** 

在给变量进行赋值的时候，如果右侧的表达式当中全都是**字面量或常量，没有任何变量**，那么编译器javac将会直接将若干个字面量表达式计算得到结果。

如：short result = 5 + 8 ，等号右边全都是字面量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中优化成：short result = 13 。

这称为“编译器的常量优化”。（注意：一旦表达式当中有变量参与，那么就不能进行这种优化了）





# 运算符

**Java运算符可分为：**

- 算术运算符：+ - * / % ++ --
- 关系运算符：== != > < >= <=
- 位运算符：...
- 逻辑运算符：&& || ！
- 赋值运算符：= += -= *= /= %= ...
- 三目运算符：?:
- 其他运算符：instanceof 运算符



## 1 instanceof

instanceof用来测试一个对象是否为一个类或其子类的实例，或一个对象是否为一个接口或其子接口的实现类的实例，返回boolean值。



**书写格式：** 

```java
boolean bool = object instanceof Class/Interface
```



## 2 ==

==只比较栈中的值。

对于基本类型来说，== 是进行**数值**的比较。
对于引用类型来说，== 是进行**地址值**的比较。

> 注意： 对于常量池中的字符串也是比较的地址值，只不过在编译阶段就把常量池中相同字符串合并，只占用一个堆空间，共享一个地址值。所以 == 可以用于比较常量池中的字符串是否相等。



# 修饰符

Java语言提供了很多修饰符，主要分为以下两类：

1. 权限修饰符，通常放在语句的最前端（public，default...）

2. 非访问修饰符（final，static...）



## 1 权限修饰符

权限修饰符也叫访问控制符。Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

**访问范围：** public > protected > default > private

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |
| :---------- | :----- | :------- | :------------- | :------------- | :----- |
| `public`    | ✓      | ✓        | ✓              | ✓              | ✓      |
| `protected` | ✓      | ✓        | ✓              | ✓              |        |
| `default`   | ✓      | ✓        | ✓              |                |        |
| `private`   | ✓      |          |                |                |        |



### 1.1 public

对所有类可见。访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、变量以及方法不仅可以跨类访问，而且允许跨包（package）访问。



**使用对象：**类、接口、类成员



**注意：**一个源文件只能有一个public类输出



### 1.2 protected

对同一包内的所有类、所有子类内可见。



**使用对象：**类成员、类和对象.内部类。 



**注意：**

1. 不能修饰**接口的成员**
2. 不能修饰**外部的类\接口**



### 1.3 default

即默认，什么也不写。在同一包内可见，不使用任何修饰符。使



**用对象：**类、接口、类成员。



### 1.4 private

访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能在该类内部访问，外部一概不能访问，包括其子类，更不能允许跨包访问。

有一些变量和方法只作用在本类中，不必被外部访问或子类继承，则可以使用private修饰符；需要访问private成员变量，可通过Getter/Setter方法



**使用对象：**类成员、类和对象、内部类。 



**注意：**不能修饰类\接口（外部）



## 2 非访问修饰符

### 2.1 static

代表静态的、类的



**修饰对象：**

1. 类成员：变量、方法、内部类、代码块
2. 接口成员：常量、方法



**内存位置：**位于静态域（方法区）



### 2.2 final

代表最终、不可变、常量、不可继承、不可重写的

**修饰对象：**

 1. 外部类
 2. 内部类
 4. 类成员
 5. 局部变量
 6. 接口常量



**注意：**abstract 和 final 互相矛盾，所以不能同时使用（abstract 必须要被继承或重写）



**不可变原则：**

1. 对于基本类型来说，不可变说的是局部常量当中的数据不可改变
2. 对于引用类型来说，不可变说的是局部常量当中的地址值不可改变



### 2.3 abstract

代表抽象的、不可实例化的



**修饰对象：**

1. 类
2. 类成员：方法
3. 内部类：成员内部类、局部内部类



**注意：**构造方法、静态方法（static）、私有方法（private）、final方法都不可被重写，final类不可被继承，这些都与抽象冲突，不可同时使用。



### 2.4 synchronized  

代表同步的、线程安全的



**修饰对象：**

 1. 类
 2. 实例方法、静态方法
 3. 代码块



**注意：**

1. 接口方法不能使用synchronized关键字
2. 构造方法不能使用synchronized关键字，但可以使用synchronized代码块来实现同步。



### 2.5 transient

参考：[transient修饰符](#9.3 transient修饰符)




# 数组

数组是引用数据类型，一种容器，可以同时存放多个数据值。

数组本身不提供任何操作方法，方法全部继承自 Object，如果需要操作数组建议使用 Arrays 工具类。

数组也是一种类，一种特殊的类。



**特殊性：** 数组没有一个class文件（例如Array）来储存数组类的相关属性和方法，所以实创实例过程与常规类不同。

具体原因参考：

- 链接1：https://blog.csdn.net/iteye_3313/article/details/81800350?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase

* 链接2：https://bbs.csdn.net/topics/390943750



**特点：** 

1. 数组只能储存同一种类型数据
2. 数组的长度在程序运行期间不可改变
3. 数组未重写 equals、toString 方法
3. 数组是==协变（*covariant*）==的，支持==元素类型==上的协变和==数组类型==上的协变（见代码示例）



## 1 初始化

**两种常见的初始化方式：**

- 动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。

  **格式：**`数据类型[] 数组名称 = new 数据类型[数组长度];`

  

- 静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。

  - **标准格式：**`数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };`
  - **省略格式：**`数据类型[] 数组名称 = { 元素1, 元素2, ... };`



**注意：**

1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。
2. 初始化格式可以拆分成为两个步骤：声明、初始化。
3. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。



**使用建议：** 如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。



## 2 数组长度

数组长度是数组的成员个数，是int类型的整数。 数组长度是 final 类型，数组一旦创建，程序运行期间，数组长度不可改变。



**访问格式：** array.length



## 3 数组默认值

使用动态初始化数组的时候，其中的元素将会自动拥有一个[默认值](#1 默认值)。



**注意事项：** 静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。



## 4 数组相关异常

- **空指针异常：**
  所有的引用类型变量，都可以赋值为一个null值。但是代表其中什么都没有。
  数组必须进行new初始化才能使用其中的元素。
  如果只是赋值了一个null，没有进行new创建，
  那么将会发生：空指针异常 NullPointerException

  原因：忘了new
  解决：补上new



- 越界异常
  数组的索引编号从0开始，一直到“数组的长度-1”为止。
  如果访问数组元素的时候，索引编号并不存在，那么将会发生
  数组索引越界异常
  ArrayIndexOutOfBoundsException

  原因：索引编号写错了。
  解决：修改成为存在的正确索引编号。



# 字符串

String类是一个final类，引用类型，代表**不可变字符序列**。

API中说：Java 程序中的所有字**符串字面值**（如 "abc" ）都作为此类的实例实现。即：程序当中所有的双引号字符串，都是String类的实例对象（没有new也是）。



**特性：**

1. String声明为一个final类，表示不可继承

2. String实现Serializable接口，表示支持序列化；

3. String实现Comparable接口，表示可比较大小；

4. String内部定义 final byte[] value 属性，用于储存字符串内容；
   
    > 注： 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。
    
5. 不可变性：即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。这是与其他引用类型对象区别之一。正是因为字符串不可改变，所以字符串是可以共享使用的。
   
    - 不可变指的是**字符串内容**不可变，而非指**变量名和内容之间的绑定**不可变
    - 不管什么方式创建的字符串都不可变



**创建字符串的方式：**

1. 构造函数创建：
   
    new构造函数
    
    - public String()：创建一个空白字符串，不含有任何内容。
    
    - public String(String original)：根据字符串字面量构造。
    
    - public String(char[] array)：根据字符数组的内容，来创建对应的字符串。
    
    - public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。
    
      ...
    
      ```java
      String str = new String("Hello"); 
      ```
    
      
    
2. 字面量创建：

    直接写上双引号，就是字符串对象

    ```java
    String str = "Hello"; 
    ```

**区别：** 

- 构造函数创建创建字符串，**会在堆中创成1个或2个字符串对象**：先查找**字符串常量池**中是否存在相同的字符串，若无，创建一个实例1（堆中），将实例1引用地址加入常量池中，若有，则不创建；最后，无论常量池有没有，都会再创建一个实例2（堆中），并返回堆中的实例2的引用地址。
- 字面量创建的字符串，**会在堆中创成0个或1个字符串对象**：先查找**字符串常量池**中是否存在相同的字符串，若无，创建一个实例（堆中），将引用地址加入常量池中，并返回常量池中的引用地址。若有，则不创建实例，直接返回已存在的常量池中的引用地址。
- 构造函数创建返回的**一定是堆中的引用地址**，字面量创建返回的**一定是字符串常量池中的引用地址**。
- 构造函数创建一定会在堆中创建新实例，字面量创建不一定会创建新实例。

![字符串常量池内存](.\images\javaSe\字符串\字符串常量池内存.png)



**Java9改进字符串底层存储方式：**

Java9改进了字符串（包括String、StringBuffer、StringBuilder）的实现。

在Java9以前字符串采用char[]数组来保存字符，因此字符串的每个字符占2字节；

而Java9的字符串采用byte[]数组再加一个encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。

所以Java9的字符串**更加节省空间**，字符串的功能方法也没有受到影响。



**字符串与基本类型数据转换：**[基本类型和String转换](#6 基本类型和String转换)



## 1 字符串常量池

字符串常量池位于方法区（元空间），用于储存**字面量创建**的字符串。字符串常量池**不会储存相同内容的字符串**。

请结合[常量池](#4 常量池)章理解。



**快速记忆：** 常量池搞兼并，相同值只一个，值同则地址同，可以用==判等。



**常量池位置：** jdk1.6-方法区（永久代），jdk1.7堆空间，jdk1.8+方法区（元空间）



**常量池的好处：**

常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了**对象的共享**。

例如字符串常量池，在编译阶段就把所有的字符串放到一个常量池中。

- **节省内存空间：**常量池中所有相同的字符串值被**合并**，只占用一个空间。
- **节省运行时间：**比较字符串时，== 比 equals() 效率高。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。



## 2 实例方法

由于String的不可变性，String的所有方法都==不会改变原字符串==。

String实现了CharSequence接口，CharSequence是char值的可读序列。CharSequence已知实现类：CharBuffer ，Segment ，String ，StringBuffer ，StringBuilder。



**具体用法：**详见代码示例。



## 3 StringBuilder和StringBuffer

String是不可变的字符序列，StringBuffer/StringBuilder 代表**可变的字符序列**。

StringBuffer是JDK1.0开始存在，StringBuilder是JDK1.5才新增的。



**StringBuffer、StringBuilder（简称2SB）与String的不同：**

1. 2SB都代表可变字符串序列，String代表不可变的字符序列
2. 2SB因为是可变，可对底层数组进行扩容，String只会开辟新的内存
3. 2SB总体而言，效率比String高



**StringBuffer、StringBuilder相同点：**

 1. 两个类都代表可变字符串对象
 2. 两个类的构造器和方法也基本相同（但不保证同步）。
 3. 两个类底层都是byte[]储存数据
 4. 两个类都会自动对底层数组进行扩容



 **StringBuilder、StringBuffer不同点：**

1. StringBuffer 是线程安全的（方法都添加了synchronized），效率更低
2. StringBuilder 是线程不安全的，效率更高（优先采用）



**实例方法：**实例方法部分与String相同，增加了可修改字符序列的一些方法。



## 4 判等

**String类提供了两个实例方法用来判等：**

- equals：比较字符串值，继承自Object类

- equalsIgnoreCase：忽略大小写，比较字符串值

  > 不容忍空指针异常，可以使用字符串常量、字符串字面值作为调用实例来避免："Lily".equals(name);



**另外可以用以下来判等：**

- ==：比较地址。常量池字符串值一样，地址就一致，可以用\==间接比较字符串值。不推荐使用。
- Objects.equals：比较字符串值，可以容忍空指针异常



# 常用类

## 1 Object

### 1.1 equals方法

equals是Object中的成员方法，而Object是所有类的父类，所有类都继承了该方法，基本类型需要包装类才能使用。



**源码：**

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```



**判断机制：** 除==所有基本类型==和==部分重写了equals的引用类型==外，其他引用类型没有重写equals，他们equals的方法继承自Object，判断机制与 == 一样，判断两个类是否地址一样。



**重写了equals的类：** 包装类（Byte，Integer...）、String、Date、File、BigInteger、BigDecimal...
**未重写了equals的类：** 数组...



**特性：**

1. 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。
1. 自反性：x.equals(x)必须返回是“true”。
1. 传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。
1. 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。



**注意事项：**

1. 只能引用类型数据调用，基本类型数据需要使用==包装类==才能调用
2. x.equals(null)，永远返回是“false”，x.equals(和x不同类型的对象)永远返回是“false
3. null.equals()会报空指针异常，所以调用之前需要判断一下非null
4. 推荐把==常量==或==确定非null的对象==用来放在前面：推荐："abc".equals(str)    不推荐：str.equals("abc")



**重写equals方法：**详见代码示例。



### 1.2 toString

返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。

建议所有Object子类都重写此方法。



**源码：**

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```



**重写了toString的类：** 包装类（Byte，Integer...）、String、Date、File、BigInteger、BigDecimal...

**未重写了toString的类：** 数组...



**重写toString方法：**详见代码示例。



## 2 Objects

jdk1.7后，Java在java.util包中有一个工具类Objects，用于处理对象。

它由所有静态方法组成。 

Objects类中的大多数方法都会优雅地==处理空值==。

判断基本类型时不用包装类。



**具体使用：**详见代码示例。



## 3 Arrays

Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。



**具体使用：**详见代码示例。



## 4 System

System类代表程序所在系统，提供了对应的一些系统属性信息和系统操作。 

它不能被实例化。



**注意：**

1. System无法实例化，都是静态方法和变量，是一个系统相关的工具类
2. 静态变量有：
   - in：标准输入流（键盘输入）
   - out：标准输出流（显示器）
   - err：标准错误输出流（显示器）



**具体使用：**详见代码示例。



## 5 Math

java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。

Math类操作的是数字类型数据，包括int\long\float\double



**具体使用：**详见代码示例。



## 6 BigInteger和BigDecimal

### 6.1 BigInteger

Integer能存储的最大整型值为 2^31^-1，Long类也是有限的，最大为2^63^-1。如果要表示再大的整数，他们都无能为力，更不用说进行运算了。

java.math包的BigInteger可以表示==不可变的任意精度的整数==。BigInteger提供所有Java的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。

另外， BigInteger 还提供以下运算：模算术、 GCD 计算、质数测试、素数生成、位操作以及一些其他操作。



**注意：**

1. 不可变性：BigInteger的操作方法不会改变主对象
2. BigInteger重写了toString方法
2. BigInteger不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法



**具体使用：**详见代码示例。



### 6.2 BigDecimal

一般的 Float 类和 Double 类可以用来做科学计算或工程计算，双精度浮点型变量double可以处理16位有效数，但在商业计算中，要求数字精度更高，故用到 java.math.BigDecimal类 。

BigDecimal类支持==不可变的、任意精度的有符号十进制定点数==。



**注意：**

1. 不可变性：BigDecimal的操作方法不会改变主对象
2. BigDecimal重写了toString方法
3. BigDecimal不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法



**具体使用：**详见代码示例。



# 日期与时间

## 1 Java 8之前的日期与时间

在Java SE 8前，日期时间工具库在java.util包中，包括：

- **java.util.Date：**表示日期和时间，精确到毫秒。java.util.Date类自jdk 1.0即存在，但是它的大多数方法已经在JDK 1.1引入java.util.Calendar类之后被弃用了，而Calendar并不比Date好多少。java.sql.Date 是 java.util.Date 的子类，表示数据库中的日期类型变量。
- **java.util.Calendar以及其实现子类：**表示各种日历系统，常用的是格林威治日历java.util.GregorianCalendar
- **java.util.TimeZone以及其实现子类：**表示时区偏移量和夏令时

以及辅助其进行格式化和解析的工具库在java.text包中，包括：

- **java.text.DateFormat：**格式化日期时间和解析日期时间的工具抽象类
- **java.text.SimpleDateFormat：**DateDateFormat的实现



**它们面临的问题有：**

1. 可变性：像日期和时间这样的类应该是不可变的，他们都是可变的

2. 偏移性：Date中的年份是从1900开始的，而月份都从0开始

3. 格式化：格式化只对Date有用，Calendar则不行
4. 缺乏年、月、日、时间、星期的单独抽象
5. Dater日期时间类既描述日期又描述时间，耦合，且Date不仅在java.util包中存在，在java.sql中也存在，重复名称，容易导致bug发生

4. 此外，它们是线程不安全的；不能处理闰秒等。



## 2 java.time库

第三次引入的API是成功的，Java 8 吸收了 Joda-Time 的精华，本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。

从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有：

- 本地日期和时间：LocalDateTime，LocalDate，LocalTime（替换Calendar）；
- 带时区的日期和时间：ZonedDateTime；
- 时刻：Instant（替换Date）；
- 时区：ZoneId，ZoneOffset；
- 时间间隔：Duration。
- 格式化类：DateTimeFormatter（替换SimpleDateFormat）。

和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。

此外，新API修正了旧API不合理的常量设计：

1. Month的范围用1~12表示1月到12月；
2. Week的范围用1~7表示周一到周日。

最后，新API的类型几乎全部是==不变类型==（和String类似），可以放心使用不必担心被修改。并且Java.time 这个包是==线程安全==的。



### 2.1 Instant

时刻，是==格林威治标准时间==（GMT）的==即时时间点==（类似 java.util.Date），表示全球时间轴上的特定瞬间，==与时区无关==，精确到==纳秒==的（而不是旧版本的Date精确到毫秒）。

Instant构造器是私有的，不能直接new。



**时间戳：** 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至特定时刻的==总秒数==或==总毫秒数==。



**与LocalDateTime的不同：**
LocalDateTime表示的是不带时区的日期及时间，替换之前的Calendar。看上去，LocalDateTime和Instant很象，但记得的是“Instant中是==不带时区==的即时时间点。

可能有人说，即时的时间点不就是日期＋时间么？

看上去是这样的，但还是有所区别，比如LocalDateTime对于用户来说，可能就只是一个简单的日期和时间的概念，考虑如下的例子：两个人都在2013年7月2日11点出生，第一个人在英国出生，而第二个是在加尼福利亚，如果我们问他们是在什么时候出生的话，则他们看上去都是在同样的时间出生（就是LocalDateTime所表达的），但如果我们根据时间线（如格林威治时间线）去仔细考察，则会发现在出生的人会比在英国出生的人稍微晚几个小时（这就是Instant所表达的概念，并且要将其转换为UTC格式的时间）。



**具体使用：**详见代码示例。



### 2.2 LocalXxx

LocalXxx总是表示本地日期和时间。精度为纳秒。

JDK8新特性里提供了3个时间类：**LocalDate、LocalTime、LocalDateTime**，替换 Calendar。

LocalDate、LocalTime、LocalDateTime构造器是私有的，不能直接new。



**具体使用：**详见代码示例。



### 2.3 ZonedDateTime

ZonedDateTime代表带时区的日期和时间。

LocalDateTime总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要ZonedDateTime。

ZonedDateTime可用于不同时区的日期和时间转换。



**注：** 涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。



**具体使用：**详见代码示例。



### 2.4 ZoneId和ZoneOffset类

Date-Time API 提供了两个用于指定==时区==或==时区偏移量==的类：

- ZoneId 指定时区标识符，并提供 Instant 和 LocalDateTime 之间转换的规则。
- ZoneOffset 指定格林威治/ UTC 时间的时区偏移量。



**具体使用：**详见代码示例。



### 2.5 DateTimeFormatter

对ZonedDateTime或LocalDateTime进行格式化，需要使用DateTimeFormatter类。

DateTimeFormatter可以通过==格式化字符串==和Locale对日期和时间进行定制输出。



![日期时间的模式字母](.\images\javaSe\日期和时间\日期时间的模式字母.PNG)



**具体使用：**详见代码示例。



# 方法

方法用于描述类的功能，是语句的集合。

在Java中，没有函数的概念，只有方法的概念。方法不能独立存在，它只能属于类或者对象。



**命名规则：** 小驼峰（myMethod）



**作用：** 

1. 使程序变得更简短而清晰。
2. 有利于程序维护。
3. 可以提高程序开发的效率。
4. 提高了代码的重用性。



**定义格式：** 

```java
修饰符 返回值类型 方法名称(参数类型 参数名称, ...) {
  // 方法体
  return 返回值;
}
```

**说明：**

- 返回值类型：限制方法最终产生的数据结果的数据类型

  > 注：void代表没有返回值，不能返回任何数据，可以不写return，要写只能写return;

- 方法名称：方法的名字，规则和变量一样，小驼峰规则
- 参数类型：限制进入方法的数据类型
- 参数名称：进入方法的数据对应的变量名称（形参）
- 方法体：方法需要做的事情，若干行代码
- 返回值：方法执行后最终产生的数据结果，类型必须与前面的“返回值类型”保持一致



**注意事项：** 

1. 方法必须定义在一个类或接口中，不能定义在另一个方法当中，或其他地方
2. 方法return后面不能书写任何必被执行的语句
4. 返回值类型为void的方法，它没有返回结果，所以不能对它的执行结果赋值或访问



## 1 参数

方法的参数是方法内部的局部变量，但它们是最先声明的，只不过是由调用时**由外部传值\传址来赋值**。



**方法的参数分为两种：**

1. 形参：形参代表方法定义上的，用于接收实参的参数，供方法体使用，如void method(int a, int b)中的a、b
2. 实参：实参代表方法执行时，传递给形参的，且实际参与运算的参数，如method(1, 2)中的1、2



与传递变量一致，传递参数有两种类型：

- 基本类型：值传递（传值），形参的改变不影响实参
- 引用类型：引用地址传递（传址），形参的改变直接影响实参



**修饰符：**

1. 形参不可使用**访问修饰符**
2. 可以使用final修饰符，即为**常量参数**



### 1.1 可变形参

JDK 1.5 开始，Java支持传递**同类型**的可变形参，用来接受不可预期个数的实参。可变形参是**数组类型**。

可变形参可看做**数组形参的升级版**，调用传入实参时，可传入任意个数的同类型实参，也可传入数组。



**书写格式：**

```java
// 声明
method(Type... param)
    
// 调用传参
method(param1, param2, ...)
// 或
method(Type[] param)
```



**注意事项：** 

1. 一个方法中只能指定一个可变参数
2. 可变参数必须是**最后一个参数**
3. 因为与(Type[] name)是相同的形参列表，不构成**重载**条件
4. 可变参数会被转成**数组类型**接收，直接传数组也可接收



## 2 局部变量

**局部变量可分为：** 

1. 形参
2. 方法局部变量
3. 代码块局部变量



**存放位置：** 栈



**生命周期：** 方法调用至执行结束。只有在被调用的时候才分配内存空间，一旦调用结束，就释放内存空间



**注意事项：** 

1. 局部变量没有默认值，都必须显示赋值，否则不能访问
2. 访问修饰符不能用于局部变量



## 3 局部常量

final修饰的局部变量，其他机制基本与变量一致。



## 4 递归方法

递归方法 （recursive method）指：一个方法在内部调用自己。递归方法会实现一种隐式循环，重复某段代码。但这种循环必须有终止条件，否则将变成无穷递归。



## 5 main方法

在Java中，main方法是Java应用程序的**入口方法**，因为JAVA是在C++的基础上开发的语言，main也是c++的程序入口。也就是说，程序在运行的时候，第一个执行的方法就是main()方法，这个方法和其他的方法有很大的不同，比如方法的名字必须是main，方法必须是public static void 类型的，方法必须接收一个字符串数组的参数等等。



**固定格式：**

```java
public static void main(String[] args) {
  ...   
}
```



**要求：**

1. 方法的名字必须是：main
2. 修饰符和返回类型也是固定的：public static void
3. 参数只能一个，且是字符串数组类型的：String[] args



**解释：**

- 为什么是main：规定，JVM只能识别叫做main的函数作为程序运行的起点

- 为什么是public的：为了保证JVM在任何情况下都可以访问到main方法，就用public修饰
- 为什么是static的：静态可以让JVM调用main方法的时候更加方便，不需要通过对象调用
- 为什么没有返回值（void）：没有返回值是因为不需要，Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序
- 为什么参数是String[] args：也是规定



# 类和对象

 ## 1 类的概述

类（class）是对现实中实体事物的属性和行为的描述，是抽象的，概念上的定义，是一个模板



**类的命名规范：** 大驼峰（MyClass）



**注意事项：**

1. 一个源文件【必有且仅能有】一个与文件名相同的类
2. 一个源文件中仅能有一个 public 类，且 public 类名必须与源文件名一致（原因：为了在import公共类时提高效率）
3. 一个源文件可以有多个非 public 类，可以跟文件名不同，但为了为了便于管理，一般一个源文件放一个类
4. 同一个包（同级目录）下不能有重复名称的类



**面向对象具体实现流程：**

1. 创建类，设计类的变量和方法
2. 创建对象
3. 通过对象的属性和方法，来调用对象结构



### 1.1 对象

对象（instance）是实际存在的个体，有状态和行为，也称为实例。对象是解决问题的最终工具。



**对象的命名规范：** 小驼峰（myInstance）



**判断对象的值与址的相等性：**

1.  == ：参考 \src\运算符\双等号
2.  equals：参考 \src\常用类.Object类\equals
3.  Objects.equals：参考 \src\常用类.Object类\Objects工具类\Equals



#### 1.1.1 创建对象

创建对象也叫类的实例化，或实例化类。

**格式：**

```java
类型 对象名 = new 类(参数列表);
```



#### 1.1.2 匿名对象

创建对象没有显式地赋给一个变量名，即为匿名对象。

如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。

> 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。



**示例：**

```java
new Person("张三", 30).tell();
```





### 1.2 this关键字

**使用格式：** 

```java
类名.this // “类名”省略代表当前类下的this
```



**作用：**

- 指向==当前实例对象==，用于访问实例的成员变量\方法，如：this.field/this.method()
  
    > 注：
    >
    > 1. 当与成员变量或形参不重名的情况下，this可以省略
    > 2. 继承中，如果子类实例化，父类中的this（==包括代码块、构造器、方法中的this==）是指向子类实例；若父类实例化，父类的this还是指向父类实例。
    
- 充当本类的构造函数，用法：this()\this(...)
  
  > 注：
  >
  > 1. 只允许在构造器的==第一行代码==执行
  > 2. 一个构造器中只允许执行一个其他构造方法
  > 3. 只允许调用其他构造器
  > 4. 构造器不允许循环调用
  
  

**注意：** 静态方法、静态代码块中不能使用this，因为实例对象还没生成



## 2 类的成员

类的成员包括**变量**（属性、域、字段、field）、**方法**（行为、函数、method）、**代码块**（初始化块、block）。

面向对象的设计重点是类的设计，而设计类重点则是<u>设计类的成员</u>。



**类的成员分类：**

- 变量
- 方法
- 构造器
- 类
- 接口
- 代码块

> 以上每种都可分为静态（类成员）与非静态（实例成员）。



### 2.1 成员变量

与局部变量不同，成员变量有[默认值](#1 默认值)，不同类型的成员变量有不同的默认值（与数组一致）。



**就近原则：**当方法的<u>局部变量</u>和类的<u>成员变量</u>重名的时候，根据“就近原则”，优先使用局部变量。



**成员变量赋值的先后顺序：**

1. 默认初始化
2. 显式赋值
3. 构造器赋值
4. 通过“对象.方法”或“对象.属性”赋值

> 注：123只执行一次，4可以反复执行）



**实例变量、静态变量、局部变量的对比:**

1. 定义的位置不一样【重点】
    成员变量：定义在类中
    局部变量：定义在方法（包括构造器）中、方法（包括构造器）形参、代码块

2. 作用范围不一样【重点】
   成员变量：整个类全都可以通用。
   局部变量：只有方法当中才可以使用，出了方法就不能再用

3. 默认值不一样【重点】
   成员变量：如果没有赋值，会有默认值，规则和数组一样
   局部变量：没有默认值，如果要想使用，必须手动进行赋值

4. 内存的位置不一样
   实例变量：位于堆内存，跟着实例对象走，new的时候创建
   静态变量：位于方法区（静态域），跟着类走
   局部变量：位于栈内存，跟着方法走，方法进栈，局部变量创建

5. 生命周期不一样
   实例变量：随着实例对象创建而诞生，随着实例对象被垃圾回收而消失。所以实例变量生命周期就是实例对象的开始和销毁。
   静态变量：随着类声明而诞生，随着类被垃圾回收而消失。所以静态变量生命周期就是类的开始和销毁。
   局部变量：随着方法进栈而诞生，随着方法出栈而消失。所以局部变量生命周期就是方法的开始和销毁。

6. 权限修饰符的不同
   成员变量不可用权限修饰符



**成员常量：**可算做不可变的成员变量，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 2.2 成员方法



### 2.3 构造器

构造器（Constructor/构造方法/构造函数）是专门用来创建对象的特殊方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。



**作用：**

1. 创建对象

2. 初始化对象信息



**格式：**

```java
权限修饰符 构造器名(参数列表) {
   ...
}
```

**构造器与成员方法的区别：**

       1. 构造方法的名称必须和所在的类名称完全一模一样
              2. 构造方法不写返回值类型，连void都不写，也不能 return
              3. 构造方法用于创建对象，并进行初始化值；普通成员方法是用于完成特定功能的。
                     4. 构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数；普通成员方法是由创建好的对象调用，可以调用多次

> 注：构造器可以看作特殊的成员方法



**注意事项：**

1. 如果没有编写任何构造方法，那么编译器将会默认创建一个空的构造方法（没有参数、方法体什么事情都不做，即：public Student() {}）
2. 默认提供的构造器的权限修饰符与类相同
3. 一旦显式定义一个构造方法，那么编译器将不再默认创建
4. 构造方法允许重载。（重载：方法名称相同，参数列表不同）
5. 一个类至少有一个构造器，创建一个对象的时候，至少要调用一个构造器
6. 构造方法允许被各种权限修饰符修饰



### 2.4 代码块

代码块也叫初始化块。

**分类：**
       1. 非静态代码块（实例）
              2. 静态代码块



**执行顺序：**

1. 静态代码块先于非静态代码块执行

2. 同一类的多个代码块按**声明顺序**执行（一般不会声明多个代码块）



#### 2.4.1 非静态代码块

**声明格式：**

```java
{
    ...
}
```

**用途：** 给实例属性初始化

**执行时间：** 每次<u>创建实例</u>时候都会执行一次

**创建实例时，实例结构的执行顺序：**

1. 默认初始化
2. 显式初始化/非静态代码块执行
   注： 显式初始化和（实例）代码块执行是同一级别的，谁在前谁先
3. 构造器初始化
4. 通过"对象.属性"或“对象.方法”去赋值



#### 2.4.2 静态代码块

**声明格式：**

```java
static {
    ...
}
```

**用途：** 给静态变量初始化

**执行时间：** 每次<u>加载类</u>的时候都会执行一次

**加载类时，静态结构的执行顺序：**

1. 默认初始化
2. 显式初始化 / 静态代码块执行
   注： 显式初始化和静态代码块执行是同一级别的，谁在前谁先
3. main方法执行



**注意：**

1. 静态代码块类只能调用静态结构
2. 继承的时候先需要加载父类，所以父类的静态代码块也会先执行



### 2.5 成员类、成员接口

成员类是内部类的一种，具体可参考[7.1 成员内部类](#7.1 成员内部类)。

成员接口与成员类类似。



### 2.6 静态成员

static 修饰符可用于修饰类的成员（变量和方法，以及内部类），被修饰的统称为为静态成员。



**什么时候使用静态的：**

1. 不会随着对象改变而变的成员
2. 操作静态属性的方法
3. 工具类的方法，习惯用静态的（比较省事，不用创建对象，如Math、Arrays）
4. 常量（final）习惯用静态的



**访问格式：** 类.静态变量\方法\类

**静态成员内存位置：** 位于静态域（方法区）

**特点：**

1. 节省内存空间
2. 共享性



**注意事项:**

   1. 静态成员属于所在的类，非属于实例对象
   2. 静态成员被同一类的实例对象可以共享
   3. 静态成员可直接通过类访问，不需要创建实例就可使用
   4. 静态先于实例对象存在，所以静态方法中不可用实例变量、实例方法、this、super关键字，但可以访问其他静态成员
   5. 实例方法可以访问静态成员，且可以省略类名
   6. 实例成员和静态成员的名称不允许重复
   7. 静态方法可以被继承，可以被重载，可以被隐藏（隐藏其实相当于重新声明），但不能被重写



## 3 JavaBean

JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定。



**约定：**
1. 所有的成员变量私有化（private）
2. 私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范
3. 必须具有一个公共的(public)无参构造函数
4. 这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）



## 4 类的继承

继承（extends）就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

![继承类型](.\images\javaSe\类和对象\继承类型.png)

**书写格式：**

```java
修饰符 class 子类名 extends 父类名 {
    
}
```



**作用：**共性抽取



**特性:**

1. 子类拥有父类<u>所有的属性和方法</u>

2. 子类可以在父类的基础上进行修改和扩展，方式是重写、重载、隐藏

3. 父类的private属性和方法也是可以被继承的，只是子类拥有但无法访问（封装性）；不能直接访问，但可以通过非private的父类方法进行间接访问。

4. Java 的继承是【单继承】，但是可以【多重继承】。单继承是一个子类只能继承一个父类（只能有一个父亲），多重继承就是子类也可以当父类（传代），例如 A 类 -> B 类 -> C 类

   > 注：A 类 -> B 类 -> C 类，B为C的直接父类，A为C的间接父类

5. 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）

6. 继承是多态的前提

7. 所有类继承的最顶级对象是java.lang.Object，Object是祖先类，Object在 java.lang 包中，所以不需要 import

8. 当访问实例对象的成员变量或方法时，则优先寻找本类当中是否存在，若有则用，无则向上（父类）寻找，不会向下（子类）寻找

9. 若需访问父类与子类的重名成员变量时，可通过super访问



### 4.1 super关键字

我们可以通过super关键字来实现对父类成员的访问，相当于父类的this。



**使用格式：** 

```java
类名.super // "类名"省略代表当前类的super
```



**作用：**

1. super可以指向父类的this，现对父类成员的访问，用来访问父类的成员变量和方法

2. 可以充当父类的构造函数



**使用注意事项：**

1. 只能在子类构造函数中执行
2. 跟this一样，只能作为第一个语句执行，因此一个代码块中，super和this只能调用一个一个构造函数只能执行一次super

3. 子类所有的构造器第一行都会默认隐式地执行父类的无参构造器（super()），手动显式地执行super()或this()，则替代默认的super()
4. 子类的构造器中，第一行不是执行this()，就是执行super()，而至少有一个子类构造器执行super()，而至多有n-1个this()
5. 每个子类的构造器都会直接或间接调用父类构造器，所以当执行某类的构造器的时候，一定会把它所有父类的构造器都执行一遍，直到Object的构造器，这便是继承的过程。注意：但只创建一个对象，即new的那个类的对象



## 5 重写、重载、隐藏

**重载与重写对比：**

- 重写（Override）：方法的名称、形参列表<u>要求一样</u>；访问权限、返回值类型<u>要求兼容</u>；其他无关；用于子类覆盖父类方法。

  > 记忆：替代

- 重载（Overload）：方法的名称<u>要求一样</u>；形参列表<u>要求不一样</u>；其他无关；用于对不同的传参进行不同的处理情景，可对本类或父类的方法重载。

  > 记忆：新增一种实现方式

![重写和重载](.\images\javaSe\类和对象\重写和重载.png)



### 7.1 方法重写

方法重写（覆盖/覆写/Override/Overwrite）是子类对父类的允许访问的【实例方法】的实现过程进行重新编写，返回值和形参都不能改变。

<u>即外壳不变，核心重写！</u>



**书写格式：**

```java
@Override
修饰符 类型 方法名 (参数列表){
    ...
}
```

> 注解@Override 写在方法前面，可用来检测是不是有效的正确覆盖重写（可写可不写）



**作用：** 重写的作用在于子类可以根据业务需要，重定义方法的行为，也就是说子类能够根据需要实现父类的方法。



**要求：**

1. 方法的名称、参数列表（类型\个数\顺序）必须相同

2. 返回值类型：如果父类返回值为引用类型，则子类重写方法的返回值必须【小于等于】父类的；如果父类返回值为基本类型或void，则子类必须返回跟父类一模一样的

3. 访问权限：子类重写方法必须【大于等于】父类方法

   > 访问权限：public > protected > (default) > private

4. throws类型：子类重写方法必须【小于等于】父类方法，如果父类没有声明throws，则子类也不能声明



**注意事项：**

1. 重写只能是子类对父类（祖先类）的重写，不能是对本类或子类方法的重写
2. 声明为 final 的方法不能被重写。
3. private方法无法被重载、重写，因为子类无法访问父类的private成员
4. 父类静态方法可以被继承，可以被重载，可以被隐藏，但不能被重写（隐藏只是形式上的重写，并不满足多态的特征，所以严格说不是重写）
5. 重写只能适用于【实例方法】，不能用于静态方法，对于静态方法,只能隐藏







### 7.2 方法重载

方法重载（Overload）是指在同一个类中定义多个同名的方法，要求每个方法具有不同的形参的类型\个数\顺序，保证每个重载的方法都必须有一个独一无二的参数列表。



**作用：** 对不同的传参进行不同的处理

**方法重载与下列因素相关：**

1. 参数个数不同
2. 参数类型不同
3. 参数的多类型顺序不同



**方法重载与下列因素无关：**

1. 与形参的名称无关
2. 与方法的返回值类型无关
3. 与方法的修饰符无关



**注意：**

1. 重载可以对本类方法的重载，也可以是子类对父类的方法进行重载，但不能是本类对子类的重载
2. private方法无法被重载、重写，因为子类无法访问父类的private成员



### 7.3 隐藏

隐藏是指子类的成员变量（包括实例变量和静态变量）和静态方法与父类的命名一样，访问子类的这些变量和方法的时候就只会访问子类的，而父类的被隐藏。若子类没有，再去访问父类的。



## 6 抽象类和抽象方法

**关键字：** abstract



###　6.１ 抽象类

如果一个类没必要实例化，仅提供一些结构供子类去实例化，其中没有包含具体的信息来描绘一个具体的对象，这样的类就是抽象类。

类的继承当中，结构会越来越具体，而上层的父类往往需要更通用，且没必要实例化，因此便有了抽象类。

抽象类就是用来继承的，继承过程中去重写抽象方法，



**声明格式：**

```java
权限修饰符 abstract class {
    ...
}
```



**注意：**

1. 抽象类不能直接实例化，必须被继承，才能够使用
2. 抽象类虽然不能实例化，但仍需要<u>构造器</u>，供子类调用
3. 没有任何抽象方法的抽象类有特殊作用（？？？）
4. 抽象类在继承方面没有限制——抽象类可以被抽象类、普通类继承，抽象类也可以继承抽象类、普通类
5. 抽象类也可以多态
4. final类不可被继承，而抽象类必须要被继承，所以抽象类不能被final修饰



### 6.2 抽象方法

抽象方法就是为了子类重写而存在，该方法的具体实现由它的子类确定，所以不需要方法体。



**声明格式：**

```java
[权限修饰符] abstract 返回类型 方法名 (参数列表); -- 权限修饰符缺省，默认为public
```



**注意：**

1. 抽象方法只能声明在抽象类中，且只有声明，没有方法体
2. 有抽象方法的类必定是抽象类，抽象类中不一定包含抽象方法
3. 子类必须覆盖重写抽象父类当中所有的抽象方法，除非该子类也是抽象类，否则报错
6. 静态方法（static）、私有方法（private）、final方法不可被重写，这些都与抽象冲突，不可用于修饰抽象方法



## 7 内部类

将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。

### 7.1 成员内部类

内部类作为一个外部类的成员存在。



**用途：** 当一个事物（人）需要一个完整的结构（大脑）去描述，而这个结构只需要对这个事物提供服务，那么这个结构最好使用内部类。

**分类：**

- 非静态成员内部类
- 静态成员内部类



**注意：**内部类的 this 指向内部类实例，若要在内部类中使用外部类的 this，则用：【外部类.this】。



#### 7.1.1 非静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
```



#### 7.1.2 静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称.内部类名称();
```





### 7.2 局部内部类

定义在方法、构造器、代码块内部的类。



**注意事项：**

1. 局部内部类只能在该方法内访问，方法外无法访问
2. 局部内部类不允许使用权限修饰符（public，default...），因为没有意义，它只能在方法内访问
3. 局部内部类只能通过所在的方法去使用



**局部内部类访问该方法内的局部变量的情况：** 

1. 该变量必须是【final】的，原因：因为局部变量是跟方法走的，而局部内部类是new出来的，是在堆中的，两者声明周期不同，所以局部变量必须不变
2. 从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略



#### 7.2.1 局部匿名内部类

匿名内部类也是局部内部类的一种，也只能定义是方法、构造器、代码块内部。

他常用于**继承和实现**中，当一个<u>子类</u>或<u>实现类</u>只使用一次时，可以使用匿名类快捷方便地创建实例。



**格式：**

```java
// 继承
父类名称 对象名 = new 父类名称(){
  // 匿名内部类（子类）
  // 这里书写子类的内容
};

// 实现
接口 对象名 = new 接口(){
  // 匿名内部类（实现类）
  // 这里书写实现类的内容
};
```



**局部匿名内部类引用外部变量问题：**

1. 局部匿名内部类==不能引用外部的局部变量==，更不能在内部类里去==修改外部的局部变量==。

2. 可以引用==局部常量==，以及==外部类的成员变量\常量==。局部常量可以是final修饰的局部常量，也可以是不被后面的代码修改的普通局部变量（即==隐性的具有 final 的语义==）。

   > 演示：见代码示例



## 8 final类与final成员

### 8.1 final类

final类不可被继承（太监类），成为最终类，被继承会报错。



**注意事项：**

1. final类没有子类，但有父类（任何类都有父类，除了Object）
2. 既然没有继承，也就没有所谓的子类对父类的成员覆盖、重载
3. final类一样可以对它的父类成员进行重写、重载
4. abstract 和 final 互相矛盾（abstract 类一定要被继承，final 类不可被继承），不能同时使用



### 8.2 final成员

#### 8.2.1 成员常量

成员常量即加final的变量。

成员常量，不可用默认值，所以必须赋值一次（初始化），且不可再变。

赋值的位置有：显式赋值，构造器赋值，代码块赋值。（方法中赋值不可行，太晚了）。



**命名格式：**全大写，底杠分割，如：MY_NAME



**静态常量：**用 static final 修饰的成员变量。可当作**全局常量**。



**注意：**子类可以隐藏（覆盖）父类的成员常量



#### 8.2.2 final方法

**分类：**

- 静态final方法
- 非静态final方法



**注意：** 

1. abstract 和 final 互相矛盾（abstract 方法一定要被重写，final 方法不可被重写），不能同时使用
2. final方法不可被重写、隐藏，但可以被重载。



## 9 对象的序列化和反序列化

在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。但是，我们创建出来的这些对象都存在于JVM中的堆（heap）内存中， 只有JVM处于运行状态的时候，这些对象才可能存在。**一旦JVM停止，这些对象也就随之消失**；但是在真实的应用场景中，我们需要将这些对象**持久化**下来，并且在需要的时候 将对象重新读取出来，Java的序列化可以帮助我们实现该功能。

 对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将对象的状态信息保存为**字节数组**，并且可以在有需要的时候将这个字节数组通过**反序列化**的方式转换成对象，对象的序列化可以很容易的在JVM中的**活动对象和字节数组（流）**之间进行转换。

在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中。



**serialVersionUID：**

简单来说，JAVA序列化的机制是通过判断类的serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID于本地相应实体类 的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。

serialVersionUID有两种显示的生成方式：

1. 是默认的1L，比如：private static final long serialVersionUID = 1L;
2. 是根据包名，类名，继承关系，非私有的方法和属性，以及参数，返回值等诸多因子计算得出的，极度复杂生成的一个64位的哈希字段。基本上计算出来的这个值是唯一的。 比如：private static final long serialVersionUID = xxxxL;

> 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明。



**注意：**

1. transient、static修饰的成员都无法序列化
2. 在序列化对象的时候，静态字段并没有被序列化，但使用反序列化对象去访问静态字段的时候会自动去访问类的静态字段，而不是反序列化对象的。

2. 要想将父类也序列化，则父类必须可序列化
3. 如果可序列化类内部成员有访问其他对象，这些对象也必须是可序列化的，否则会导致该类无法可序列化



**对象的序列化方式有两种：**

- Serializable接口
- Externalizable 接口



### 9.1 Serializable接口



**步骤：**

1. 让需要序列化的类继承Serializable接口
2. 声明全局常量：serialVersionUID



### 9.2 Externalizable接口？

有特殊需要时，如不希望对象的某一部分被序列化，或者不希望某个对象的子对象被序列化等，可通过实现Externalizable接口来替代实现Serializable接口，对序列化过程进行控制。

将类实现为Externalizable后，没有任何东西可以自动序列化，并且可以在writeExternal方法中对所需部分进行显示的序列化。

Externalizable接口继承了Serializable接口，并添加了两个方法：writeExternal(ObjectOutput out)和readExternal(ObjectInput in)方法，这两个方法会在序列化和反序列化还原的过程中被自动调用。

在重构 Externalizable 对象时，先使用无参数的公共构造方法创建一个实例，然后调用 readExternal 方法。通过从 ObjectInputStream 中读取 Serializable 对象可以恢复这些对象。因此，对于一个Externalizable对象，所有普通的默认构造器都会被调用（包括在字段定义时的初始化），然后调用readExternal()方法，因此默认构造器要设为public。在反序列化过程中，带参数的构造器不会被调用，因此在带参数构造器中所有初始化操作也就不会被保存，所以要在readExternal方法中重新初始化。



### 9.3 transient修饰符

transient关键字用于可序列化类中，将==不需要序列化的成员变量==前添加关键字transient，序列化对象的时候，这些成员变量就不会序列化到指定的目的地中。



**修饰对象：**成员变量；不可修饰于成员方法；也一般不修饰静态成员，因为静态成员本来就无法序列化，修饰了也无用。





# 枚举类

当一个类的对象数量是已知的、确定的、有限的，这个类称为枚举类。

![枚举类归纳](.\images\javaSe\枚举类\枚举类归纳.png)



**命名规则：**大驼峰（MyEnum）



**建议：**

1. 当我们需要一组有限个数的常量时，建议使用**枚举类**
2. 当枚举类只有一个对象时，可以用**单例模式**实现



**两种方式：**

1. 自定义枚举类（JDK 5.0之前）
2. Enum枚举类（JDK 5.0之后）



## 1 自定义枚举类

使用普通类来模拟枚举类，这是JDK 5.0之前的做法，现在已弃用，使用Enum枚举类代替。



**步骤：**

1. 声明一个类，在类中声明该枚举类的属性（private final）；
2. 私有化构造器（private），并给属性赋值；
3. 在类中创建枚举实例，并提供公共静态常数的访问方式（public static final）



**具体示例：**Season类



## 2 Enum枚举类

枚举（enum）类型是Java 5新增的特性，它是一种新的类型，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。

尽管 enum 看起来像是一种新的数据类型，事实上，enum是一种受限制的类，并且具有自己的方法。创建enum时，编译器会为你生成一个相关的类，这个类继承自 java.lang.Enum。



**特性：**

  1. Enum枚举类和Class、Interface的地位一样
  2. Enum枚举类继承自java.lang.Enum，而不是继承Object类，除此之外**不能继承其他类和其他enum类**
  3. Enum 枚举类固定使用 final 修饰，不能显式修饰，**不可以被继承**
  4. Enum枚举类跟类一样，**可以实现一个或多个接口**
  5. Enum枚举类**不能抽象**，因为无法被继承
  6. Enum枚举类的toString方法继承至Enum，返回枚举实例的常量名，直接打印枚举实例，输出的是枚举实例的常量名
  7. Enum 枚举类的**构造函数是私有的**
 8. Enum枚举类**可以有静态方法**



**声明格式：**

```java
public enum Payment {
  // 枚举实例
  // 属性
  // 构造器
  // 方法
    ...
}
```



**枚举实例：**

- 定义格式：

  ```java
  枚举实例名1(...), 枚举实例名2(...), 枚举实例名3(...), ... 无参枚举实例名4;
  ```

- 注意：
  1. 必须在Enum枚举类中**第一行**声明，否则报错
  2. 固定是public static final修饰，不能显式修饰

**属性：**与普通类一致。

**构造器：**

- 声明格式：

  ```java
  构造器名(...){
      ...
  }
  ```

- 注意：固定是私有的（private），否则报错，可以省略



**Enum枚举类实现接口**：Enum枚举类跟类一样，也可以实现接口。



**Enum枚举类实例方法与静态方法：**略



## 3 内部枚举类？



# 接口

接口就是规范，定义的是一组规则。接口的本质是契约，标准，规范，就像我们的法律一样，制定好后大家都要遵守。

在Java语言中，接口（Interface）是一种引用类型，是方法的集合，是类的公共规范。

如果说类的内部封装了成员变量、构造方法和成员方法， 那么接口的内部**主要就是封装了方法**，其中最重要的就是的：**抽象方法**。

编写接口的方式和类很相似，但是它们属于不同的概念，接口与类是并列的两个结构。

接口是**隐式抽象**的。



**特性：**

- 多重实现：类只能单继承，但允许同时可以实现多个接口
- 多重继承：接口允许同时继承多个父接口



> **实现接口和继承类的通俗理解：**实现接口可以理解为一个人学一个技能，比如烹饪，那么他必须遵守了烹饪的相关规则，才能说学会了烹饪。当然一个人可以学很多技能：写作、开车、修理家具等等。继承类可以理解为一个人选择成为某个职业中的一员，比如成为厨师，那么他也必须遵守厨师的相关规则，但是职业只能一个（Java规定，其他语言不一定），不能既是厨师，又是运动员。



**接口与类的不同之处：**

1. 类描述对象的<u>属性和方法</u>，接口则包含类要实现的<u>方法</u>
2. 接口不能实例化（没有构造函数），同过<u>实现</u>发挥效用；类通过实例化发挥效用
3. 接口里的所有的方法必须是<u>抽象方法</u>
4. 接口支持<u>多继承，多实现</u>，而类只支持<u>单继承</u>。
5. 接口不能包含成员变量、构造方法、代码块



**接口与类的相同之处：**

1. 与类一样，接口文件保存在.java 结尾的文件中，文件名使用接口名
2. 与类一样，接口的字节码文件保存在 .class 结尾的文件中
3. 与类一样，接口也具有多态性
4. 与类一样，接口也可以包含常量、抽象方法、默认方法、静态方法、私有方法



**不同版本Java，接口包含的内容：**

- Java 7：
  - 常量
  - 抽象方法
- Java 8：
  - 默认方法
  - 静态方法
- Java 9：
  - 私有方法



**标识接口：**标识接口是<u>没有任何方法和属性</u>的接口。标识接口不对实现它的类有任何语义上的要求，它仅仅表明实现它的类属于一个特定的类型。如Serializable接口。



## 1 定义接口

**书写格式：**

```java
权限修饰符 [abstract] interface 接口名称 {
    // 接口内容
}
// 接口是隐式抽象的，所以[abstract]可省略
```



**接口的命名规范**： 大驼峰（MyInterface）





**接口和抽象类相似之处:**

1. 接口和抽象类都不能被实例化。
2. 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。



1. 接口里只能包含抽象方法、静态方法和默认方法，不能为普通方法提供实现，而抽象类可以。
2. 接口里只能定义常量，不能定义普通成员变量，抽象类则可以。
3. 接口里不包含构造器;抽象类可以包含构造器，但抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
4. 接口里不能包含初始化块;但抽象类则完全可以包含初始化块。
5. 一个类最多只能有一个直接父类（包括抽象类）;但一个类可以实现多个接口，通过实现多个接口可以弥补Java单继承的不足。





## 2 实现接口

接口不能直接使用，必须有一个“实现类”来实现该接口。接口支持多重实现，即：一个“实现类”可以同时实现多个接口。

> 如果实现类没有重写接口中<u>所有的抽象方法</u>，该实现类必须定义成<u>抽象类</u>



**关键字：** implements



**书写格式：**

```java
// 实现，支持多重实现
权限修饰符 class 实现类名称 implements 接口名称1[, 接口名称2, 接口名称3, ...] {
     ...
}
```



**多重实现时，接口成员重复情况：**

1. 静态方法不会被继承，只通过接口自身调用，所以**不用管重复**
2. 私有成员不会被出现在实现类当中，所以**不用管重复**
3. 常量（静态变量）重复，只能通过接口调用；或者实现类中重声明隐藏接口常量，才可以类和实例调用
3. 抽象方法重复，实现类**只需重写一次**
4. 默认方法重复，实现类**必须重写**





**类同时继承，并实现接口情况：** 继承优先于实现，父类优先于接口

```java
// 顺序：先继承，后实现
权限修饰符 class ClassA extends ClassB implements Interface1[, 接口名称2, 接口名称3, ...] {
    ...
}
```



**当继承与实现成员重复时：**

1. 抽象方法同名同参数：子类只需重写一次
2. 普通（默认）成员方法同名同参数：父类优先于接口
3. 静态方法同名同参数：父类优先于接口
4. 静态变量同名：引用不明确，子类不会继承

> 当出现命名冲突时，子类就必须重写或重声明



## 3 接口继承

一个接口允许同时继承多个父接口，即多重继承。



**关键字：** extends



**书写格式：**

```java
// 继承，支持多重继承
权限修饰符 Interface extends Interface1[, Interface2, Interface3...] {
    ...
}
```



**多重继承时，父接口成员重复情况：**

1. 父接口抽象方法重复：子接口不必重写，但实现类中必须重写
2. 父接口默认方法重复：子接口必须重写，实现类不必重写
3. 父接口静态方法重复：静态方法只通过接口自身调用，所以不用管重复（接口的静态方法不会被继承）
4. 父接口常量（静态变量）重复，只能通过父接口调用；或者子接口中重声明隐藏接口常量，才可以在子接口、类、实例调用



## 4 接口成员

接口成员包含：抽象方法、常量、默认方法、私有方法、静态方法。而其中抽象方法是最重要的。



### 4.1 抽象方法

接口最重要的内容就是其中的：抽象方法。



**格式：**

```java
[public abstract] 返回值类型 方法名称(参数列表);// [public abstract]可省略
```



**注意：**

1. 接口中的方法是隐式抽象的，声明时可以省略 abstract 关键字

2. 接口中的抽象方法必须是公有的，权限修饰符必须是public的，所以可以省略 public 关键字

   

### 4.2 常量

接口常量必须是**静态**的，必须使用 public static final 三个关键字进行修饰，所以也可省略。



**格式：**

```java
[public static final] 数据类型 常量名称 = 数据值;
```



**命名格式：**全大写，底杠分割，如：MY_NAME



**注意：**

1. 常量，必须进行赋值

2. 常量会被实现类继承，变成类的静态变量（注意：静态方法不会被继承，这是区别）
3. 常量可以被隐藏
4. 常量可以接口直接调用，也可以实现类调用，也可以实例调用（除了多重实现时重复，只能接口调用）（重点）

>  基本与类的成员常量类似，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 4.3 私有方法

私有方法用于接口内部的代码封装。

> 从Java 9开始支持



**格式：**

```java
private [static] 返回值类型 方法名称(参数列表) {
  ...
}
```



**注意：**私有方法只在接口内部可见，与外部无关，不会被实现类继承。



### 4.4 静态方法

> 从Java 8开始支持



**格式：**

```java
[权限修饰符] static 返回值类型 方法名称(参数列表) {
    ...
}
// 权限修饰符默认为public，可以省略
```



**注意：**

1. 接口的静态方法不会被继承（这点与类不同），只存在接口自身中，当然也没有重载、重写、隐藏（重点）
2. 权限修饰符默认为public，可以省略（这点与类不同）
3. 静态方法只能通过接口自身调用，格式：接口.静态方法()



### 4.5 默认方法

**用途：** 接口当中的默认方法，常用来解决接口升级的问题;若是升级时添加的是抽象方法，老代码因未重写报错，而默认方法不会



> 从Java 8开始支持



**格式：**

```java
[权限修饰符] default 返回值类型 方法名称(参数列表) {
    ...
}
// 权限修饰符默认为public，可以省略
```



**注意：**

1. 默认方法会被实现类的继承作为实例方法
2. 可继承，可重写，可重载



## 5 函数式接口

函数式接口(Functional Interface)是对一类特殊类型的接口的称呼。 这类接口保证有且仅有一个抽象方法。

函数式接口可以使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个 接口是一个函数式接口。

函数式接口可以被隐式转换为 **lambda 表达式**。

其他方面与普通接口无异。



注意，如果接口声明了一个**可被java.lang.Object中的某方法重写**的抽象方法，那么它不会计入接口的抽象方法数量中，因为所有的实现类都继承了Object类，该接口中的抽象方法一开始就已被重写。

比如，虽然Comparator虽然有两个抽象方法：

```java
int compare(T o1, T o2);
boolean equals(Object obj);
```

但其中 equals 被 Object 的 equals 重写，只剩下 compare 是唯一必须被重写的抽象方法，被所以Comparator可以作为函数式接口。



### 1 内置函数式接口

Java 8新增了 java.util.function 包，该包定义了丰富的函数式接口。



**四大核心的内置函数式接口：**

|   函数式接口   | 参数类型 | 返回类型 | 抽象方法          |                             用途                             |
| :------------: | :------: | :------: | ----------------- | :----------------------------------------------------------: |
|  Consumer<T>   |    T     |   void   | void accept(T t)  |             **消费型：**对类型为T的对象应用操作              |
|  Supplier<T>   |    无    |    T     | T get()           |                **供给型：**返回类型为T的对象                 |
| Function<T, R> |    T     |    R     | R apply(T t)      | **函数型：**对类型为T的对象应用操作，并返回结果。结果是R类型的对象。 |
|  Predicate<T>  |    T     | boolean  | boolean test(T t) | **断定型：**确定类型为T的对象是否满足某约束，并返回boolean 值。 |



**其他内置函数式接口：**

|              函数式接口              | 参数类型 | 返回类型 |         抽象方法          |                       用途                       |
| :----------------------------------: | :------: | :------: | :-----------------------: | :----------------------------------------------: |
|         BiFunction<T, U, R>          |   T, U   |    R     |     R apply(T t, U u)     | 对类型为 T, U 参数应用操作，返回 R 类型的结果。  |
|   UnaryOperator<T>(Function子接口)   |    T     |    T     |       T apply(T t)        | 对类型为T的对象进行一元运算，并返回T类型的结果。 |
| BinaryOperator<T>(BiFunction 子接口) |   T, T   |    T     |    T apply(T t1, T t2)    | 对类型为T的对象进行二元运算，并返回T类型的结果。 |
|           BiConsumer<T, U>           |   T, U   |   void   |   void accept(T t, U u)   |           对类型为T, U 参数应用操作。            |
|           BiPredicate<T,U>           |   T,U    | boolean  |   boolean test(T t,U u)   |                    双参断定型                    |
|           ToIntFunction<T>           |    T     |   int    |    int applyAsInt(T t)    |                  计算in值的函数                  |
|          ToLongFunction<T>           |    T     |   long   |   long applyAsLong(T t)   |                 计算long值的函数                 |
|         ToDoubleFunction<T>          |    T     |  double  | double applyAsDouble(T t) |                计算double值的函数                |
|            IntFunction<R>            |   int    |    R     |    R apply(int value)     |               参数为int 类型的函数               |
|           LongFunction<R>            |   long   |    R     |    R apply(long value)    |               参数为long类型的函数               |
|          DoubleFunction<R>           |  double  |    R     |   R apply(double value)   |             参数为double 类型的函数              |



### 2 Lambda表达式

Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。

**本质：**作为函数式接口的实例。它表达的是对象而不是函数。



**格式：**

```java
// 函数式接口实现并实例化普通写法：
接口 itfc = new 接口(){ 
    @Override
    public void 抽象方法(参数) {
        方法体
    }
};

// 改成Lambda表达式：
接口 itfc = (参数) -> { 
    方法体
};

// 若参数只有一个，可以省略圆括号；若方法体只有一句，可以省略大括号；若方法体只有一句，且是返回语句，可以省略return关键字：
接口 itfc = 参数 -> 方法体/返回数据;

// 匿名lambda表达式写法
((接口) (参数) -> {
    方法体
}).方法();
```



**lambda表达式的重要特征:**

- 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。
- 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
- 可选的大括号：如果主体只包含一个语句，就不需要使用大括号。
- 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。



**lambda表达式引用外部局部变量报错问题：**详见[局部匿名内部类](#7.2.1 局部匿名内部类)



### 3 方法引用

方法引用是Lambda表达式升级版，更加省略。

其本质还是Lambda表达式。



**要求：**当使用Lambda表达式时，方法体是**只有一句调用方法的语句**，调用方法和接口中的抽象方法具有**相同的返回值，或需相同的形参同参同返）**。



**格式：** 

```java
接口 itfc = 类/对象 :: 引用方法/new;

// 匿名方法引用表达式写法
((接口) 类/对象 :: 引用方法/new).方法();
```



**方法引用有四种用法：**

1. **实例方法引用：**`对象::实例方法`，同参同返

2. **静态方法引用：**`类::静态方法`，同参同返

3. **类的任意实例方法引用：**`类::实例方法`，==同返不同参==

   最特殊，有两种情况都适合：

   1. 双参-单参：`(s1, s2) -> s1.equals(s2)` ==> `S::equals`
   2. 单参-空参：`(s) -> s.getName()` ==> `S::getName`

4. **构造器引用：**`类::new`，同参同返



#### 3.1 构造器引用

当使用Lambda表达式时，lambda体是一个调用构造器、实例化的表达式，而是返回一个实例，可简写成构造器引用的格式。



**要求：**引用的构造器方法必须和接口中的抽象方法具有相同的形参，而抽象方法返回这个类的实例。



**格式：** 

```java
接口 itfc = 类 :: new;
```



# 多态

多态是继封装、继承之后，面向对象的第三大特性。多态（Polymorphism）是指同一操作，作用于不同的对象，可以有不同的解释，产生不同的执行结果。现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。比如跑的行为，小猫、小狗和大象，跑起来是不一样的。

Java中，多态就是同一个接口，使用不同的实例而执行不同操作。

多态的使用体主要现在<u>虚拟方法</u>的调用。



**含义：**

父类的引用指向子类对象，或子类对象赋给父类引用。多态本身就是<u>向上转型</u>过的过程，是小范围到大范围的转变。把子类单做父类使用，只能使用继承自父类的成员，不能使用子类特有的成员。例如：把某只猫当作动物而不是猫来看待，它具备动物的属性，但不能使用猫特有的属性。



**多态存在的三个必要条件：**

1. 继承或者实现【二选一】

2. 方法的重写【不重写，无意义】

3. 向上转型



**多态的转型：**多态的转型分为<u>向上转型</u>和<u>向下转型</u>两种



**多态的优点：**

1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性



**多态体现的格式：**

```java
父类名称 对象名 = new 子类名称();
// 或者：
接口名称 对象名 = new 实现类名称();
```



**口诀：** 编译看左边，运行看右边



**使用多态成员看两个方面：**

1. 有没有：看类\接口是否有这个成员（继承来的也算）

2. 从哪找：从哪个类开始往上查找

> 先看有没有，没有则报错，有则再看从哪找



**多态成员变量和多态成员方法调用规则不一样：**

1. 使用多态成员方法：有没有看左边，从哪找看右边

2. 使用多态成员变量：有没有、从哪找都看左边（因为属性不存在多态性）

> 通过get方法间接访问成员变量，跟成员方法的规则一致



**虚拟方法 （虚方法\virtual method）：**在多态的情况下，将父类的方法称为虚拟方法，父类根据赋给他不同的子类对象，动态地调用子类的该方法，这些方法在编译期是无法确定的，只有运行时才能确定。



**注意事项：**

1. 多态对象堆内存中仍然有子类特有的成员，但是因为类型是父类的，所以无法调用，需要向下转型才能调
2. 多态是动态绑定（运行时），重载是静态绑定（编译时）
3. 多态性体现在成员方法上，不体现在属性上



## 1 向上转型

父类引用指向子类对象，把子类当做父类使用，只能使用父类有的成员，不能使用子类特有的成员。例如：把猫当作动物来看待，可以使用动物有的属性，但不能使用猫特有的属性。

类似于自动类型转换：`double num = 100;// int -> double`，范围小 -> 范围大，自动类型转换



**适用场景：** 当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。



**格式：**

```java
Fu fu = new Zi();
```



**向上转型注意事项：**

1. 向上转型是小范围到大范围的转变
2. 向上转型一定是安全的，许可的
3. 优点是：左边代码可以统一
4. 缺点是：不能调用子类特有的内容。解决方案是：向下转型





## 2 向下转型

向下转型是向上转型的还原动作。

向上转型之后，把对象还原为原有类型，向下转型成功后又可以使用子类特有的内容。

例如：把猫上转型为动物来看待后，还原为猫，又可以使用猫的特有属性了。

适用场景： 当要使用子类特有功能时。



**格式：**

```java
Zi zi = (Zi)fu;
```



**类似于：**

```JAVA
int num = (int) 100.0;// 可以
int num = (int) 100.5;// 精度损失
```



**向下转型注意事项：**

1. 向下转型是大范围到小范围的转变

2. 向上转型是安全的，但向下转型是有风险的
3. 【前提条件】：必须先多态（向上转型），才能向下转型，而且只能转为原有类型，若转为其他类型，则编译通过，运行报错，
   报ClassCastException（猫只能还原为猫，不能还原为狗）。所以向下转型前先用 instanceof 判断。



# 泛型

Java泛型是JDK 5引入的一个特性。

泛型（Generic），即“==参数化类型==”。顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用/调用时传入具体的类型（类型实参）。

泛型提供了编译时<u>类型安全检测机制</u>，该机制允许程序员在编译时检测到非法的类型。 泛型的引入加强了参数类型的安全性，减少了类型的转换。

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。



**泛型结构：**

- 泛型类
- 泛型接口
- 泛型方法



**特性：**

1. 泛型只在编译阶段有效



## 1 泛型参数

所有泛型都有一个类型参数声明部分，写在尖括号中，如。泛型参数也可叫叫做：类型参数、泛型变量、类型变量。 此处T可以随便写为任意标识，常见的T、E、K、V等大写字母。多个泛型参数用逗号隔开，写做：<T,E,K,V>。



**特性：**

1. null 符合所有泛型参数
2. 若泛型参数未传入，默认是Object类型
3. 泛型参数必须是**引用类型**，不能是基本类型



## 2 泛型结构

### 2.1 泛型方法

泛型方法中，类型传入的时间点： 在方法<u>被调用的时候确定类型</u>，通过实参的类型来来确定。



**声明格式：**

```java
修饰符 <T> returnType methodName (param){
  ...
}
```



**类型传入的时间点：**在方法<u>被调用的时候确定类型</u>，通过==实参类型==或==接收变量类型==来确定。

**类型传入格式：**

```java
// 通过实参类型确定
methodName(param);

// 通过接收变量类型确定
Type obj = methodName(param);
```



**注意事项：**

1. 方法上泛型的差异不构成重载



### 2.2 泛型类

泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。



**声明格式：**

```java
class GenericClass<T>{
  ...
}
```



**类型传入的时间点：** 在类被<u>实例化、继承</u>的时候确定类型

> 注意：泛型类（父）被继承时，可选择完全确定父类类型（参考SubClass1），或者完全保留父类类型，让子类实例化的时候确定类型（参考SubClass2），或者部分保留、部分确定父类类型（参考SubClass3）， 或者擦除父类类型（参考SubClass4）

**类型传入格式：**

```java
// 1.无变量接收
new ClassName<Type>();

// 2.有变量接收
ClassName<Type> Var = new ClassName<Type>();

// JDK7.0 以后，增加类型推断，后面的泛型参数可省略：
ClassName<Type> Var = new ClassName<>();
// 注：后面的尖括号<>不可省略，省略了<>等于不使用泛型。
```



**注意事项：**

1. 类中的非静态成员可以访问并使用类定义的泛型参数，静态成员不可访问
2. 类成员定义的泛型参数优先级大于类定义的泛型参数，若重复，定义的泛型会覆盖类的泛型参数
3. 不同泛型参数的引用不能互相赋值，参考例test3
4. 静态方法不能使用类的泛型，但可以有自己的泛型，因为静态方法加载时，泛型有可能还未传入（实例化）
5. 泛型类是无法继承自 Throwable 类（包括异常类（Exception\Error）），即异常类等不能使用泛型，
    参考：https://blog.csdn.net/ziwang_/article/details/56288597



### 2.3 泛型接口

**声明格式：**

```java
修饰符 interface interfaceName<T> {
  ...
}
```



**类型传入的时间点：** 在接口被<u>实现</u>的时候确定类型

**类型传入格式：**

```java
修饰符 class ClassName implements interfaceName<Type> {
  ...
}
```



## 3 类型擦除机制

Java的泛型只在<u>编译阶段</u>实现，<u>在运行期被删除</u>。编译器生成的字节码在运行期间并不存在泛型的类型。

由于类型擦除机制，显性地引用==运行时类型==的操作都是不允许的。

与c++对比，java的泛型只停留在编译阶段，是==不彻底的泛型机制==。



既然泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？

答案是在运行期只能获取当前class对象中==包含泛型类型的信息==，而不能在运行时动态获取某个==泛型引用的类型==。

实际上==泛型信息==是被编译进字节码文件的，这样我们就可以通过==反射==来获取泛型信息，创建具体类型。



在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果==没有指定上限==，如 `<T>`则会被转译成`<Object>`类型，如果指定了上限如 `<T extends String>`则类型参数就被替换成类型上限`<String>`。

**在编译后所有的泛型类型都会做相应的转化，转化如下：**

```java
List<String>、List<T> 擦除后的类型为 List。
List<String>[]、List<T>[] 擦除后的类型为 List[]。
List<? extends E>、List<? super E> 擦除后的类型为 List<E>。
List<T extends Serialzable & Cloneable> 擦除后类型为 List<Serializable>。
```



**泛型只停留在编译阶段的原因：**

1. 如果把类型信息保留到运行时，需要做大量的重构工作
2. 兼容原生的老版本类型



**类型擦除不会改变class属性:**

```java
List<String> t1 = new ArrayList<String>();
List<String> t2 = new ArrayList<Integer>();
System.out.println(t1.getclass() == t2.getclass());
```



**不允许以下操作:**

1. new 泛型参数

   ```java
   T t = new T();
   ```

2. 引用泛型参数的方法、属性

   ```java
   T.class;
   T.get();
   ```

4. 打印

   ```java
   System.out.println(T);
   ```
   
3. 不支持创建具体类型的泛型数组，因为这样做会破坏类型安全。

   ```java
   ArrayList<String>[] list = new ArrayList<String>[2];// 编译报错
   ```

2. instanceof 不能带泛型参数:

   ```java
   list instanceof List<String>// 编译报错
   obj instanceof T// 编译报错
   ```


6. ==不同泛型参数的泛型类（接口）==会被编译器认定为==不同类型==，==不支持泛型上的多态和转型==，体现了泛型类型的==不变性（*invariant*）==。所以不同泛型参数之间的==赋值，传参==是不允许的：

   ```java
   List<Object> ls1 = new ArrayList<>();
   List<String> ls2 = new ArrayList<>();
   ls1 = ls2;// 编译报错
   ```

​		……



## 4 通配符

在java泛型中，引入了通配符和边界符来支持==协变==和==逆变==。解决了不同泛型参数之间的==赋值，传参==的限制，但也带来了一些==副作用==。

通配符表示一种==未知类型==，并且对这种未知类型存在==约束关系==。

通配符（?）、边界符（extends、super）一般配合使用。



**分类：**

- **上边界通配符(upper bounded wildcard)** ：`? extends T`对应==协变关系==，表示 `?` 是继承自 `T`的任意子类型（包括T自身），即? <= T。
  
  - **无边界通配符**：`?` 的等于 `? extends Object`，表示 `?` 是继承自`Object`的任意类型。
  
  ![上边界](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\泛型\上边界.jpg)
  
- **下边界通配符（lower bounded wildcard）**：`? super T`对应==逆变关系==，表示 `?` 是 `T`的任意父类型（包括T自身）），即? >= T。

![下边界](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\泛型\下边界.jpg)

**使用地方限制：**

1. 只能用于==泛型类、接口的泛型参数==中，如：`List<?>`、`ArrayList<? extend String>`、`List<? super String>`

2. 只能用于==方法和变量接收处==：

   1. 方法定义

      1. 形参接收处：`public void look(List<?> ls) {}`
      2. 返参限定处：`public List<?> look() {}`

   2. 变量接收处：`List<? extends String> ls = new ArrayList<>();`

   > 注：不可用于任何泛型结构（泛型类、接口、方法）的泛型参数==定义==处。



**存、取约束：**

- 上边界通配符：善取不善存

- 下边界通配符：善存不善取

> 详见代码示例



**PECS原则(producer-extends,consumer-super)：**

这个是 `Effective Java`中提出的一种概念。如果类型变量是生产者，则用 `extends`，如果类型变量是消费者，则使用 `super`。

通俗地讲即：

1. 需要频繁往外==读取==内容的，适合用上界Extends。
2. 需要经常往里==插入==的，适合用下界Super。



**? 与 T 的差别：**

1. `?` 表示一个未知类型, `T` 是表示一个确定的类型. 因此,无法使用 `?` 像 `T` 声明变量和使用变量.如

   ```java
   // OK
   static <T> void test1(List<T> list) {
       T t = list.get(0);
       t.toString();
   }
   // Error
   static void test2(List<?> list){
       ? t = list.get(0);
       t.toString();
   }
   ```

2. `?` 主要针对泛型类（接口）的限制, 无法像 `T`类型参数一样单独存在.如

   ```java
   // OK
   static <T> void test1(T t) {
   }
   // Error
   static void test2(? t){
   }
   ```

3. `?` 主要表示==使用泛型==,`T`表示==声明泛型==。泛型类无法使用`?`来声明,泛型表达式无法使用`T`.如

   ```java
   // Error
   public class Holder<?> {
       ...
   // OK
   public class Holder<T> {
       ...
   public static void main(String[] args) {
       // OK
       Holder<?> holder;
       // Error
       Holder<T> holder;
   }
   ```



## 5 边界符

**说明：**

- T型：使用字母T，E，K，V的用法

- 通配型：使用通配符?的用法



**边界符分类：**

- **上边界符（extends）**

  上边界符限定为==目标类及其子类==，==T型==和==通配型==均可用。

- **下边界符（super）**

  下边界符限定为==目标类及其父类==，仅==通配型==可用。

- **多重界符（T extends ClassA & InterfaceB）**

  多重界符限定为ClassA 和 InterfaceB的共有子类型，仅==T型==可用。



# 集合框架

集合框架是一个用来代表和操纵集合的统一架构。Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。

集合和数组都属于Java容器，对多个数据进行储存操作的结构（注：这里的储存是内存层面的储存，非持久化储存）。

![集合框架关系图](.\images\javaSe\集合框架\集合框架关系图.gif)

**所有的集合框架都包含如下内容：**

- 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象
- 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。
- 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。



**集合框架结构（不全）：**

```
├── 集合框架
    ├── Collection(I)
        ├── List(I)
            ├──ArrayList（C）   
            ├──LinkedList（C）    
            └──Vector（C）       
        ├── Set(I)
            ├──HashSet（C）     
                └──LinkedHashSet（C）   
            └──TreeSet（C）   
        └── Queue(I)
    └── Map(I)
        ├── HashMap（C）
            ├──LinkedHashMap（C）   
        ├── treeMap（C）    
        └── Hashtable（C）
            └── Properties（C）
```

> 通俗理解：
>
> Java集合框架世界里有两大家族，一个叫**Collection（集）**，另一个是叫**Map（图）**。Collection 家族主张**单列集合**主义，Map家族主张**双列集合**主义。Collection 接口和 Map 接口分别是这2大家族中的大族长（顶层接口）。两大家族的大族长之下，便是一些干部：子接口、抽象类，他们不直接干活，而是叫他们之下的实现类（普通类）、子类（普通类）去干活。



**说明：**

- Collection：接口；单列集合，存储一个一个对象
  - List：接口；储存有序的、可重复的数据；容量不固定，随着容量的增加而动态扩容（阈值基本不会达到），习惯称之为“动态数组”
  - Set：接口；储存无序的、不可重复的数据；习惯称之为“集合”
  - Queue：接口；储存有序的、可重复的数据；
- Map：接口；双列集合，存储键/值对（key-value）映射；允许一对一、多对一，不允许一对多
  - ArrayList：类；数组队列，Java集合框架中被使用最多的，线程不安全，效率高
  - LinkedList：类；双向链表
  - HashSet：类；HashSet 基于 HashMap 来实现的；



**集合和数组的对比：**

1. 数组只能放**同一类型**的数据，集合可以储存不同类型（可以使用泛型约束）
2. 数组可以存放**基本类型**和**引用类型**数据，集合只能存放**引用类型**数据
3. 数组**长度不可变**，集合**长度可变**
4. 数组提供操作数据的手段非常有限，对于删除、增加、插入等操作非常不便，同时效率不高； 集合提供丰富的操作方法，十分便利
5. 数组储存数据的特点：有序，可重复，对于无序，不可重复的数据无法满足，集合可以
6. 获取数组中的元素个数，数组没有提供有效的属性或方法使用



## 1 Collection

Collection 是最基本的单列集合接口，存储一个一个对象，单列集合框架中最顶级的接口。其子接口和实现类都必须满足它设定的规则。



**特性：**

1. 继承了 Iterator 接口
2. 由于Set是无序的，所以Collection不提供**索引相关的特性**，所以也没有类似 get 和 set 方法用于取值设值。
2. Collection 的实现类的对象（不管是有序的List还是无序的Set），在往集合对象里添加元素 obj 时，要求 obj 所在类**必须重写equals方法**，因为 Collection 的许多方法（如：contains、remove、equals...）都会调用到元素对象的equals方法。



**接口方法**：详见代码示例。



### 1.1 List

储存**有序的、可重复**的数据；容量不固定，随着容量的增加而动态扩容（阈值基本不会达到），习惯称之为“动态数组”。List下面有三个实现类：ArrayList、linkedList、Vector。



**实现类：**

- ArrayList：主要实现类，使用最多；线程不安全，查询效率高；底层使用数组 Object[] elementData 储存数据
- LinkedList：底层使用双向链表储存；对于频繁的插入、删除操作，使用此类效率比 ArrayList 高，但查询效率不如ArrayList
- ~~Vector：出现比较早（1.0，比List还早），基本被ArrayList替代，**不推荐使用**；线程安全，效率低；底层使用 Object[] elementData 储存数据。~~



**ArrayList和LinkedList对比区别：**[博客园](https://i.cnblogs.com/links?cateId=1980880)



**接口方法**：详见代码示例。



**ArrayList的源码分析：**

```
1.jdk 7情况下
    ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData
    list.add(123);//elementData[0] = new Integer(123);
    ...
    list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。
    默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。
    结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)

2.jdk 8中ArrayList的变化：
    ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组
    list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]
    ...
    后续的添加和扩容操作与jdk 7 无异。
3. 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。
```



**LinkedList的源码分析：**

```java
LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null
    list.add(123);//将123封装到Node中，创建了Node对象。

其中，Node定义为：体现了LinkedList的双向链表的说法
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```



**Vector的源码分析：**

```java
jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。
```



### 1.2 Set

储存无序的、不可重复的数据；习惯称之为“集合”。

Set里没有额外定义的方法，全部是继承自Collection的方法。

list是一个有序的容器，保持了每个元素的插入顺序。即输出顺序就是输入顺序，而Set方法是无序容器，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。



**实现类：**

- HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值，但只能储存一个
  - LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet
- TreeSet：可以按照添加对象的指定属性，进行排序



**特性：**

1. 无序性：不等于随机性；存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的**哈希值**决定的。
2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一个。



**添加元素要求：**

1. HashSet、LinkedHashSet中添加的数据，其所在的类一定要重写hashCode()和equals()，否则添加时都默认是未存在相同的，造成重复的数据
2. 重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码（哈希值）

> 重写两个方法的小技巧： 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。



**添加元素的过程(以HashSet为例)：**

我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值， 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断 数组此位置上是否已经有元素：

- 如果此位置上没有其他元素，则元素a添加成功。 --->情况1
- 如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：
  - 如果hash值不相同，则元素a添加成功。--->情况2
  - 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功。--->情况3

对于添加成功的情况2和情况3而言：元素a与已经存在指定索引位置上数据以链表的方式存储。

jdk 7 :元素a放到数组中，指向原来的元素。 jdk 8 :原来的元素在数组中，指向元素a

总结：七上八下



## 2 Map

Map 是最基本的双列集合接口，存储一个一个键/值对（key-value）映射。

允许一对一、多对一，但不允许一对多。



**理解Map结构：**

- Map中的key：无序的、不可重复的，使用Set存储所有的key，key所在的类要重写equals()和hashCode() （以HashMap为例）
- Map中的value：无序的、可重复的，使用Collection存储所有的value，所以value所在的类要重写equals()
- 一个键值对：key-value构成了一个Entry对象
- Map中的entry：无序的、不可重复的，使用Set存储所有的entry



![Map结构](.\images\javaSe\集合框架\Map结构.jpg)



**实例方法：**详见代码示例。



**实现类：**

- HashMap（C）：作为Map的主要实现类；线程不安全，效率高；允许存储null的key和value；底层实现：数组+链表 （jdk8之前），数组+链表+红黑树 （jdk 8+） 
  - LinkedHashMap（C）：保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。
- treeMap（C）：保证按照特定规则对添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序；底层使用红黑树
- Hashtable（C）：作为古老的实现类；线程安全的，效率低；不能存储null的key和value
  - Properties（C）：常用来处理配置文件。key和value都必须是String类型



**HashMap的底层实现原理：**

```
HashMap map = new HashMap():
在实例化以后，底层创建了长度是16的一维数组Entry[] table。
...可能已经执行过多次put...
map.put(key1,value1):
首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据
的哈希值：
        如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
        如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
                如果equals()返回false:此时key1-value1添加成功。----情况3
                如果equals()返回true:使用value1替换value2。

补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。

在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。

jdk8 相较于jdk7在底层实现方面的不同：
    1. new HashMap():底层没有创建一个长度为16的数组
    2. jdk8底层的数组是：Node[],而非Entry[]
    3. 首次调用put()方法时，底层创建长度为16的数组
    4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。
      4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
      4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。

字段说明：
    DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
    DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
    threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
    TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
    MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
```



**LinkedHashMap的底层实现原理（了解）：**

```
 static class Entry<K,V> extends HashMap.Node<K,V> {
     Entry<K,V> before, after;//能够记录添加的元素的先后顺序
     Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
     }
 }
```



## 3 Iterator

Iterator接口（迭代器）不是一个集合，它是一种用于访问集合的迭代器模式，Iterator 是 Java 迭代器最简单的实现。Iterator就是为容器而生。

Iterator可用于迭代 ArrayList 和 HashSet 等集合。

ListIterator 是 Iterator 的子接口，它扩展了 Iterator 接口。



![迭代器执行原理](.\images\javaSe\集合框架\迭代器执行原理.jpg)



**实例方法：**详见代码示例。



## 4 Collections

Collections是操作Collection、Map的工具类，包含各种有关集合操作的静态方法，专门操作集合实现类里面的元素。

这些方法有：常规操作（查找，最大，最小等）、排序、线程安全（同步）操作、不可变集合等。

不能实例化(把构造函数私有化)。



**静态方法：**略



# 异常

在java语言中，将程序执行中发生不正常的情况称为“异常”。**语法错误和逻辑错误**不是异常。



**Throwable类：**是 Java 语言中所有错误或异常的超类（广义上的异常）。

**Throwable有两个子类：**

1. Error：错误，java虚拟机无法解决的严重错误，无法捕获和预处理，只能改代码，它们在Java程序处理的范畴之外。例如，JVM 内存溢出
2. Exception：异常，编程错误或偶然性的外在因素导致的一般性问题，可以用针对性的代码处理（一般指狭义上的异常）



**Exception异常分为两类：**

1. 编译时异常：也叫**受检异常**（checked），如IOException、ClassNotFoundException、CloneNotSupportedException等。编译时异常必须处理后才能执行程序。
2. 运行时异常：也叫**非受检异常**（unchecked），RuntimeException及其子类异常。运行时异常不处理也可执行程序。

>注： Error也属于不可检测（unchecked），在运行时才抛出

![异常分类](.\images\javaSe\异常\异常分类.png)



**异常对象的生成有两种方式：**

1. 虚拟机检测到异常，如果当前程序没有对异常进行处理，则会在后台自动创建一个异常对象抛出（自动抛出）
2. 手动创建一个异常对象抛出。如果只创建不抛出，不会对程序运行有影响



**抓抛模型：**java的异常处理是「抓抛模型」，「抓」是「捕获继而处理」的意思，「抛」是「抛出异常」的意思。

**处理异常方式：**要么抓，要么抛，只能选一种。

- 抓：try-catch-finally
- 抛：throws

> 若前面出现异常，但后续操作还必须执行（比如IO流的关闭），这时候就需要try-catch-finally处理，不可再抛到外部，否则内部执行就中断，导致必须执行的代码未执行。



## 1 处理异常

### 1.1 try-catch-finally

try-catch-finally语句用来捕获并处理异常（编译时+运行时）。



**注意：**

1. catch只捕获对应的异常类，一旦捕获，将不执行其他catch
2. catch参数是捕捉对应的异常类，多个catch时，按从小到大的顺序捕捉（异常子类在前，父类在后），不然报错
3. finally兜底，放在最后，无论如何最后都会执行，统一处理try-catch中的错误
4. try中只要检测到异常，代码将中止，进入catch或finally代码块
5. catch代码块中若也发生异常，会进入同级的finally中
6. 运行时异常一般不必用try-catch-finally处理，因为太多了，编译时必须处理，将它延迟到运行时出现
7. 数据库连接、输入输出流、网络编程Socket等资源，jvm不会自动回收，我们需要看手动释放，释放代码需要写在finally中



**try-catch-finally中的return：**

1. try、catch、finally的代码块执行不会被 return 截止，会先执行各自return前的代码，最后再按顺序执行return
2. try、catch、finally只会执行一次return，最后执行的那个return会==覆盖前面的return==
3. finally的return总是会覆盖try、catch
3. 若try-catch-finally都有return，return执行顺序是：try => catch => finally
3. try、catch、finally中任意一个retrun执行了，则try-catch-finally结构之后的所有代码都将==不执行==



### 1.2 throws

针对方法内部的异常处理，将方法内部的异常抛出，由调用处接受，一层层向上抛出，直到虚拟机



**作用：**方法内部不处理异常，将异常抛出外部，统一在**方法调用处**处理异常。



**格式：**

```java
method() throws ExceptionType1, ExceptionType2...{
    方法体
}
```



**注意：**

1. throws的类型与顺序无关
2. 方法内部出现异常将终止后续代码执行
3. throws没有真正处理异常，而是向上“甩锅”，最终处理还是需要try-catch-finally



## 2 手动抛出异常

手动抛出异常对象。异常对象是指 Throwable 或其子类的对象。

抛出非自定义异常，一般选择 Exception 或 RuntimeException。



**格式：**

```java
 throw 异常对象;
```



**如何自定义异常类？**

1. 创建一个类，继承Exception 或 RuntimeException
2. 提供静态常量：serialVersionUID
3. 提供重载构造器



## 3 自定义异常类

**自定义异常类流程：**

1. 创建一个类，继承Exception 或 RuntimeException
2. 提供静态常量：serialVersionUID
3. 提供重载构造器



# 比较与排序

在 Java 中经常会涉及到对象的排序问题，那么就涉及到对象之间的比较问题 。



**Java 实现对象排序的方式有两种：**

1. 自然排序： java.lang.Comparable 接口
2. 定制排序： java.util.Comparator 接口



## 1 自然排序

自然排序即：使需要排序的类实现Comparable接口，重写 compareTo 方法。

Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。

> 注： 实现 Comparable 接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort 进行自动排序。



**步骤：**

1. 需要排序的类要实现 Comparable 接口，并重写 compareTo 方法
2. 在 compareTo 方法里，比较该类的两个实例的属性，按特定的规则比较一个或若干个属性，返回1（正数）、0、-1（负数）三个值，**正数代表往后排，0保持不变，负数往前排**
3. 需要排序的类的实例调用compareTo 方法得出排序结果



**已实现Comparable的类（默认都是从小到大排列的）：**

1. 包装类

   > 此外，包装类还提供静态的比较方法，如：Integer.compare(x, y)

2. String

3. Date、Time

3. ...



## 2 定制排序

定制排序即：创建一个**比较器类**，使这个比较器类实现 Comparator 接口，重写 compare 方法。将需要比较的类的实例当作参数传入 compare 方法进行比较。

当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用Comparator接口来创建一个**比较器类**。

> 注： 可以把比较器类传递给 sort 方法（如 Collections.sort 、 Arrays.sort、stream.sorted）从而允许在排序顺序上实现精确控制 。



**步骤：**

1. 创建一个比较器类，实现 Comparator 接口，重写 compare 方法
2. 在 compare 方法里，比较该类的两个实例的属性，按特定的规则比较一个或若干个属性，返回1（正数）、0、-1（负数）三个值，**正数代表往后排，0保持不变，负数往前排**
3. 需要排序的类的实例调当作参数传入比较器类的 compare 方法得出排序结果



# 注解

注解（Annotation）又称标注，是 JDK5.0 引入的一种注释机制。 

Java 语言中的包，类，构造器，方法，成员变量，参数，局部变量的声明都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 

当然它也支持自定义 Java 标注。

Annotation 其实就是代码里的特殊标记, 这些标记可以在编译 , 类加载 , 运行时被读取 , 并执行相应 的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下 , 在源文件中嵌入一些 补充信息 。 代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。

Annotation 可以像修饰符一样被使用 , 可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在 Annotation 的 “name=value” 对中。

未来的开发模式都是基于注解的， JPA 是基于注解的，Spring2.5 以上都是基于注解的，Hibernate3.x 以后也是基于注解的， 现在的Struts2 有一部分也是基于注解的了，注解是一种趋势 ，一定程度上可以说： 框架 = 注解 + 反射 + 设计模式。

![Annotation 架构](.\images\javaSe\注解\Annotation 架构.PNG)



**按作用位置分，注解可分为类：**

- 作用在代码的注解
- 作用在其他注解的注解(元注解)



**调用格式：** 

```java
// 通常写法
@AnnotationName(key1 = value1, key2 = value2, ...);

// 无参数，或者所有参数都有默认值时，可以省略()，省略时使用的是默认值传入
@AnnotationName;

// 一个参数， 且key 名称为“value”，可以省略key = 
@AnnotationName(value);

```



## 1 自定义注解

自定义注解自动继承 java.lang.annotation.Annotation 接口。

注解的与类相似，也有内部成员，叫作**注解成员**，也叫**配置参数、参数**。

与类不同的是，注解成员比较单一，只有一种形式，其定义与调用的写法类似于类的成员方法。

没有成员的注解称为**标记**，包含成员的注解称为**元数据 Annotation**。



**关键字：** @interface



**声明格式：**

```java
public @interface AnnotationName{
    // 无默认值成员
	type valueName();
    
    // 带默认值成员
    type valueName() default value;
}
```

**注意：**

1. 成员类型（type）只能是：基本数据类型、String 类型、Class类型、enum类型、Annotation类型及以上所有类型的**数组**
2. 如果只有一个成员，建议使用名称为“value”
3. 自定义注解必须配上注解的信息处理流程才有意义？？？



## 2 内置的注解

Java 定义了一套内置的注解，有的在 java.lang 中，有的在 java.lang.annotation 中。



**作用在代码的内置注解:**

- @Override - 标记重写方法；**无参**
- @Deprecated - 标记过时方法
- @SuppressWarnings - 抑制编译器警告
- @SafeVarargs - （ Java 7+）忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告；**无参**。
- @FunctionalInterface - （Java 8+）标识一个匿名函数或函数式接口；**无参**



**作用在其他注解的内置注解(元注解):**

- @Retention - 标识一个注解的生命周期
- @Documented - 标记这些注解是否包含在用户文档（javadoc）中；**无参**
- @Target - 标记注解的修饰范围
- @Inherited - 标记注解的继承性；**无参**
- @Repeatable - （Java 8+）标识某注解可以在同一个声明上使用多次



### 2.1 @Override

标记重写方法。可写可不写，建议写，可校验是否重写。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 

无参。



### 2.2 @Deprecated 

标记过时方法，意味将来很可能被删除，使用时会被划线，但仍可正常使用。如果使用该方法，会报编译警告。



### 2.3 @SuppressWarnings

指示编译器去忽略注解中声明的警告。



### 2.4 @SafeVarargs 

在JDK 7中引入，主要目的是处理可变长参数中的泛型，此注解告诉编译器：在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。

在声明具有模糊类型（比如：泛型）的可变参数的构造函数或方法时，Java编译器会报unchecked警告。鉴于这些情况，如果程序员断定声明的构造函数和方法的主体不会对其varargs参数执行潜在的不安全的操作，可使用@SafeVarargs进行标记，这样的话，Java编译器就不会报unchecked警告。



### 2.5 @FunctionalInterface 

Java 8 开始支持，标识一个匿名函数或函数式接口。

无参。



### 2.6 @Retention

标识一个注解的生命周期，标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。



**参数：**

- RetentionPolicy枚举：
  - RetentionPolicy.SOURCE - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃
  - RetentionPolicy.CLASS - 注解被保留到class文件，但jvm加载class文件时候被遗弃（默认）
  - RetentionPolicy.RUNTIME - 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；只有通过RUNTIME才能使用**反射**获取

> 这3个生命周期分别对应于：Java源文件(.java文件) ---> .class文件 ---> 内存中的字节码。生命周期长度 SOURCE < CLASS < RUNTIME



**怎么选择参数：**

一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解，比如@Deprecated使用RUNTIME注解；
如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；
如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，使用SOURCE 注解。



### 2.7 @Documented

标记这些注解是否包含在用户文档（javadoc）中。

无参。



### 2.8 @Target 

标记注解的修饰范围。



**参数：**

- 枚举数组，ElementType[]，ElementType是一个枚举类



### 2.9 @Inherited

标记注解的继承性。当一个注解 a 使用@Inherited修饰后，某一个类使用了 a 注解，则这个类的子类也会继承这个 a 注解。

无参。



### 2.10 @Repeatable 

Java 8 开始支持，标识某注解可以在同一个声明上使用多次。



**参数：**



# 反射

Reflection（反射）是被视为<u>动态语言</u>的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

加载完类之后，在堆内存的方法区中就产生了一个<u>Class类型的对象</u>（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。

通俗地讲，有一个运行时的未知的对象，我们可以通过反射，来知道这个对象对应的类，类的属性、方法等成员，以及调用这些方法、或设置这些属性等操作。

> 注意：Java不是动态语言，但Java可以称之为“准动态语言”，即Java有一定的动态性，就是因为我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！



![正常方式和反射方式](.\images\javaSe\反射\正常方式和反射方式.png)



**Java反射机制提供的功能：**

- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时获取泛型信息
- 在运行时调用任意一个对象的成员变量和方法
- 在运行时处理注解
- 生成动态代理



## 1 运行时类

java.lang.Class类是Java反射的源头。

在Object类中定义了以下的方法：`public final Class getClass()`，此方法将被所有子类继承。此方法返回值的类型是一个Class类型的对象。

程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为<u>**类的加载**</u>。加载到内存中的类，我们就称为**运行时类**，此运行时类，就作为Class的一个实例。

换句话说，<u>Class的实例就对应着一个运行时类。</u>

加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类（Class对象）。

对于每个类而言，JRE 都为其保留一个不变的 Class 对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。

![Class类](.\images\javaSe\反射\Class类.png)

**注意：**

- Class本身也是一个类
- Class 对象只能由系统建立对象
- 一个加载的类（运行时类）在 JVM 中只会有一个Class实例
- 一个Class对象实例（运行时类）对应的是一个加载到JVM中的一个.class文件
- 每个类的实例都会记得自己是由哪个 Class 实例所生成
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象



**哪些类型可以有Class对象？**

- class： 外部类（包含Class自身），成员(成员内部类，静态内部类)，局部内部类，匿名内部类
- interface：接口
- []：数组
- enum：枚举
- annotation：注解@interface
- primitive type：基本数据类型
- void



### 1.1 获取运行时类

**方式：**

1. **类的class属性：**若已知具体的类，通过类的静态属性：`class`来获取，该方法最为安全可靠，程序性能最高。
2. **实例getClass方法：**已知某个类的实例，可通过此调用方法获取运行时类
3. **forName方法：**Class的静态方法：`Class.forName(...)`，已知一个类的全类名，可通过此调用方法获取运行时类
4. **loadClass方法：**ClassLoader的实例方法：`cl.loadClass(...)`，已知一个类加载器的实例和一个类的全类名，可通过此调用方法获取运行时类



### 1.2 获取运行时类对象

详见代码示例。



### 1.3 获取运行时类的相关信息

详见代码示例。



## 2 类加载器

### 2.1 类的加载过程

类的加载过程分为：加载、链接、初始化三个步骤，这三个流程可以统称为：类的加载。

![类的加载过程1](.\images\javaSe\反射\类的加载过程1.png)



1. **加载：**将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要**类加载器**参与。 
2. **链接：**将Java类的二进制代码合并到JVM的运行状态之中的过程。
   - 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题
   - 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 
   - 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 
3. **初始化：**
   - 执行类构造器clinit()方法的过程。类构造器clinit()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 
   - 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 
   - 虚拟机会保证一个类的clinit()方法在多线程环境中被正确加锁和同步



**什么时候会发生类初始化？**

1. 类的主动引用（一定会发生类的初始化）

   - 当虚拟机启动，先初始化main方法所在的类 
   - new一个类的对象
   - 调用类的静态成员（除了final常量）和静态方法
   - 使用java.lang.reflect包的方法对类进行反射调用
   - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
2. 类的被动引用（不会发生类的初始化）

   - 当访问一个静态域时，只有真正声明这个域的类才会被初始化
   - 当通过子类引用父类的静态变量，不会导致子类初始化
   - 通过数组定义类引用，不会触发此类的初始化
   - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）



### 3.2 类加载器

Java中使用java.lang.ClassLoader类表示一个类加载器。

![类的加载过程2](.\images\javaSe\反射\类的加载过程2.png)

**类加载器的作用：**

类加载的作用：将.class文件字节码内容加载到内存中，并将这些==静态数据转换成方法区的运行时数据结构==，然后在==堆中==生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。



**类缓存：**

标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。



**类加载器有三种：**

- 引导类加载器：加载Java核心库，如String，获取不到
- 扩展类加载器：加载jre/lib/ext下的jar包
- 系统类加载器：加载自定义类，最常用

![ClassLoader](.\images\javaSe\反射\ClassLoader.png)

1. 获取一个**系统类加载器**

   ```java
   ClassLoader sysClassloader = ClassLoader.getSystemClassLoader();
   ```

2. 获取系统类加载器的父类加载器，即**扩展类加载器**

   ```java
   Classloader exClassloader = sysClassloader.getParent();
   ```

3. 获取扩展类加载器的父类加载器，即**引导类加载器**

   ```java
   classloader bootClassloader = exClassloader.getParent();
   ```



## 4 代理

**代理设计模式的原理**:

使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。==代理对象决定是否以及何时将方法调用转到原始对象上==。 



### 4.1 静态代理

静态代理，特征是代理类和目标对象的类都是在==编译期间==确定下来，不利于程序的扩展。同时，每一个代理类==只能为一个接口服务==，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。



### 4.2 动态代理

动态代理是指客户通过代理类来调用其它对象的方法，并且是==在程序运行时根据需要动态创建目标类的代理对象==。



**动态代理使用场合:** 

- 调试

- 远程方法调用

  

**动态代理相比于静态代理的优点：**
抽象角色中（接口）声明的所有方法都被转移到==调用处理器一个集中的方法==中处理，这样，我们可以更加灵活和统一的处理众多的方法。



**要想实现动态代理，需要解决的问题：**

- 问题一：如何根据加载到内存中的被代理类，动态地创建一个代理类及其对象。（动态创建代理类）
- 问题二：如何通过代理类的对象调用某方法，动态地去调用被代理类中的同名方法。（代理同名方法）



**解决以上问题的方式：**

- java.lang.reflect.Proxy：动态创建代理类
- java.lang.reflect.InvocationHandler：代理同名方法



**具体步骤：**详见代码示例。



### 4.3 AOP

AOP（Aspect Oriented Programming）意为：**面向切面编程**，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。**利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。**



# 多线程

## 1 概念

### 1.1 进程与线程的概念

​	参考：[链接](https://baijiahao.baidu.com/s?id=1666454968534966585&wfr=spider&for=pc)

​	**进程（Process）**是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，**进程是线程的容器**。 程序是指令、数据及其组织形式的描述，进程是程序的实体。

​	进程是程序的一次动态执行过程，它需要经历从代码加载，代码执行到执行完毕的一个完整的过程，这个过程也是进程本身从产生，发展到最终消亡的过程。 多进程操作系统能同时达运行多个进程（程序），由于 CPU 具备分时机制，所以每个进程都能循环获得自己的 CPU 时间片。由于 CPU 执行速度非常快， 使得所有程序好像是在同时运行一样。

​	线程是比进程更小的执行单位，线程是进程的基础之上进行进一步的划分。所谓多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的单元称为**线程**，这些线程可以同时存在，同时运行，一个进程可能包含多个同时执行的线程。**多线程是实现并发机制的一种有效手段**。进程和线程一样，都是实现并发的一个基本单位。

​	程序是一段静态的代码，进程是正在运行的程序，线程是程序内部执行的一条路径。

​	每个线程拥有独立的**栈、程序计数器**；一个进程中的多个线程共享进程的**堆、方法区**

![进程概念](.\images\javaSe\多线程\进程概念.png)

![线程概念](.\images\javaSe\多线程\线程概念.png)

### 1.2 并发与并行

**并发（concurrency）：**

并发指==两个或多个事件在同一个时间段内**间隔**发生==（一个人吃两个馒头，一口咬这个，一口咬那个） 。 指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果， 但在微观上并不是同时执行的，只是把时间分成若干端，使多个进程快速交替的执行。比如： 一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。 由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作， 这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，==同一时刻，其实只有一个线程在执行==。



**并行（parallel）：**

指==两个或多个事件在同一时刻发生（同时发生）==（两个人同时吃两个馒头，互不影响）。 它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。 并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。 而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。



![并发与并行](.\images\javaSe\多线程\并发与并行.png)

![并行和并发](.\images\javaSe\多线程\并行和并发.jpeg)





### 1.3 线程调度

**线程调度分两种：**

- 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 

- 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)

  > Java使用的为抢占式调度。



### 1.4 主线程

当一个Java程序启动以后，有一个线程就会立马被创建并执行，这就是通常所说的**主线程（Main Thread）**。



### 1.4 守护线程和用户线程

**java中线程分为两种类型：**

- 用户线程

- 守护线程：也称“服务线程”，在没有用户线程可服务时会自动离开

  > 通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。

 

**用户线程和守护线程的区别：**

1. 主线程结束后用户线程还会继续运行，JVM存活；主线程结束后守护线程和JVM的状态由下面第2条确定。

2. 如果没有用户线程，都是守护线程，那么JVM结束（随之而来的是所有的一切烟消云散，包括所有的守护线程）。
3. 守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。

 

**示例：**

垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。



**生命周期：**

守护进程（Daemon）是运行在后台的一 种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。 那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。



### 1.5 何时需要多线程

1. 程序需要同时执行两个或多个任务

2. 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等

3. 需要一些后台运行的程序时

   

## 2 创建线程

**创建线程方式：**

- 继承式
  - 继承Thread类式
- 实现式
  - 实现Runnable接口式
  - 实现Callable接口式
- 线程池式？？？



**继承式和实现式对比：**

1. 实现方式没有单继承性的限制：实际场景中，如果类继承了Thread类就不能继承其他类，而实现无此限制
2. 实现方式更方便处理多个线程共享数据的场景
2. 不管是继承式和实现式，都需要使用到 Thread 类

> 结论：更推荐使用实现式创建线程



**实现Runnable接口式与实现Callable接口式对比：**

1. Callable 可以在任务结束的时候提供一个**返回值**，Runnable 无法提供这个功能
2. Callable 的 call 方法分可以抛出异常，而 Runnable 的 run 方法不能抛出异常
3. Callable 支持泛型

> 结论：实现Callable接口式功能更强大



### 2.1 继承Thread类式

创建一个线程类MyThread，并继承于Thread类，线程类MyThread实例化几次，就创建几个线程。



**步骤：**

1. 创建一个线程类MyThread，并继承于Thread类（如果线程类只用一次，可使用匿名类写法）
2. 重写 Thread 类的 run 方法
3. 创建 MyThread 实例：myThread 
4. 调用实例 myThread.start 方法，启动线程



### 2.2 实现Runnable接口式

**步骤：**

1. 创建一个线程类MyThread，并实现Runnable接口（如果线程类只用一次，可使用匿名类写法）

2. 重写 Runnable 接口的 run 方法

   > run 方法是提供给Thread内部调用，通过start方法可调到。不可直接调用 run 方法（不调start），这样不会创建线程

3. 创建 MyThread 实例：myThread 

4. 实例化 Thread 类，将实例 myThread 作为构造参数传入，得到 Thread 类实例对象：thread

5. 调用 thread.start 方法，启动线程



### 2.3 实现Callable接口式

**步骤：**

1. 创建一个线程类MyThread，并实现Callable接口（如果线程类只用一次，可使用匿名类写法）

2. 重写 Callable 接口的 call 方法

   > call 方法是提供给FutureTask、Thread内部调用，通过start方法可调到。不可直接调用 call 方法（不调start），这样不会创建线程

3. 创建 MyThread 的实例：myThread

4. 实例化 FutureTask 类，将实例 myThread 作为构造参数传入，得到 FutureTask 类实例对象：futureTask 

5. 实例化 Thread 类，将实例 futureTask 作为构造参数传入，得到 Thread 类实例对象：thread

6. 调用 thread.start()，启动线程

> futureTask.get() 返回 call 方法的返回值。



## 3 线程生命周期和状态

在Java中，线程被分为六种状态，这6种状态定义在Thread类的State枚举中（Thread.State）。一个线程在某一时刻只能有一种状态。

通常网上说的线程有五种状态：创建（NEW）、就绪（READY）、运行（RUNNING）、阻塞（BLOCKED）、死亡（DEAD），是把运行(RUNNABLE)拆分为就绪（READY）和运行中（RUNNING）两个状态，把阻塞(BLOCKED)、等待(WAITING)、超时等待(TIMED_WAITING)合并为阻塞（blocked）一个状态导致的。



参考：[链接](https://blog.csdn.net/pange1991/article/details/53860651)



**Java线程的六种状态：**

1. **初始(NEW)：**新创建了一个线程对象，但还没有调用start()方法。

2. **运行(RUNNABLE)：**Java线程中将==就绪（READY）==和==运行中（RUNNING）==两种状态笼统的称为==运行(RUNNABLE)==，也就是Java中的RUNNABLE状态包含了READY和RUNNING。

   - **就绪（READY）：**线程对象创建后，调用线程的start()方法，此线程进入就绪状态。该状态的线程等待被线程调度选中，争抢CPU执行权。就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。
   - **运行中（RUNNING）：**就绪状态的线程在获得CPU执行权后就变为运行中状态。

3. **阻塞(BLOCKED)：**阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

4. **等待(WAITING)：**处于这种状态的线程不会被分配CPU执行权，它们要等待被显式地唤醒（等待其他线程做出一些特定动作（通知或中断）），否则会处于无限期等待的状态。

5. **超时等待(TIMED_WAITING)：**与WAITING不同的是，TIMED_WAITING有最大等待时间，在达到这个时间后它们会自动唤醒。

6. **终止(TERMINATED)：**该状态在以下情况发生时出现：

   - 当线程的run()方法完成时，或者主线程的main()方法完成
   - 线程调用stop方法
   - 线程出现异常没有处理

   终止状态表示该线程已经执行完毕。线程一旦终止了，就不能复生。终止的线程再用start()方法，就会抛出java.lang.IllegalThreadStateException异常。



![线程状态](.\images\javaSe\多线程\线程状态.jpeg)





![线程状态转换](.\images\javaSe\多线程\线程状态转换.png)

## 4 线程优先级

Java中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行（概率上）。

子线程的优先级被默认等于创建它的主线程的优先级。



**线程优先级（静态属性）：**

1. Thread.MAX_PRIORITY：10
2. Thread.MIN_PRIORITY：1
3. Thread.NORM_PRIORITY：5（默认）



**设置优先级：**

```java
thread.setPriority()
```

**获取优先级：**

```
thread.getPriority()
```



## 5 Thread的常规操作方法

### 5.1 实例方法

#### start()

辟新的栈空间，启动线程，执行 run 方法，进入**就绪状态（ready）**。
一个线程只能启动一次，即个线程的start()只能执行一次，否则报错：IllegalThreadStateException



#### getName()\setName()

获取\设置线程名字



#### join()

执行该语句的当前线程进入**等待状态（WAITING）**，等待目标线程执行完，达到死亡状态（TERMINATED）时，当前线程才能重新执行。



**注：**

1. join方法一般写在【目标线程】外部，效果如上

2. 若在目标线程内部调用，等于在内部等待自己死亡，释放执行权，进入永远阻塞状态。



**isAlive()**

测试此线程是否仍然存活。



#### getState()

获取线程状态。返回 Thread.State 枚举实例。



### 5.2 静态方法

#### currentThread()

返回对当前正在执行的线程对象。



#### yield()

让步，释放cpu执行权，让线程从RUNNABLE的**运行中状态（RUNNING）**切换到**就绪状态（READY）**，重新争抢执行权。



**注：**

1. 不释放对象锁，如果有 synchronized 同步块，其他线程仍然不能访问共享数据
2. 只能**相同或高于**它的优先级的线程有争抢执行权的机会。



#### sleep()

休眠，释放cpu执行权，进入**超时等待状态（TIMED_WAITING）**，让其他线程先执行，休眠结束再争抢执行权，继续执行。



**注：**

1. 不释放对象锁，如果有 synchronized 同步块，其他线程仍然不能访问共享数据
2. 需要处理异常
3. 此操作受到系统计时器和调度程序精度和准确性的影响
4. 所有优先级的线程都有争抢执行权的机会（区别于yield）



## 6 线程安全问题

**满足以下所有条件时，将出现线程安全问题：**

1. 多线程运行的代码（单线程不会出现线程安全问题）

2. 多个线程有共享数据，并对其进行操作

   > 解释：当某一线程操作共享数据时，执行了部分代码，但尚未完全执行完成，这时候cpu切换到另外一个线程执行，这个线程也同样进入此处操作共享数据，这种情况就容易产生对共享数据的重复操作，或多余的操作，这就是线程安全问题。**并且线程的阻塞会加大这种安全问题出现的概率。**



![线程安全之卖票](.\images\javaSe\多线程\线程安全之卖票.bmp)

**现象举例：**

1. 多个窗口买票，出现重票、错号票
2. 多人对同一银行账户存取、取款，数额不符



**解决思路：** 同步机制。当某线程在操作共享数据时，禁止其他线程同时操作，直到当前线程操作完成。即在同一时间，保证只有一个线程在操作共享数据，操作共享数据的代码相当于是单线程的。

**同步机制缺点：** 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。



### 6.1 同步方案

**同步方案：**

1. synchronized方式

   1. 同步代码块

   2. 同步方法

2. Lock锁

   > 推荐顺序： lock锁 - 同步代码块 - 同步方法



#### 6.1.1 同步代码块

**格式：**

```java
synchronized(同步监视器){
	// 需要同步的代码
}
```

**需要同步的代码：**

即操作（包括判断）共享数据的代码。

- **注意：**需要同步的代码不能多了或少了。少了依然有同步安全问题；多了，一些没必要同步的代码也变成同步，效率变低。



**同步监视器：**

同步监视器俗称“锁”。只有拿到锁的线程才可以进入同步代码块，只有当前线程执行完同步代码，才会把锁递交给下一个线程，即同一时刻，一把锁只能被一个线程持有。没有拿到锁的线程，运行到同步代码块会进入**阻塞状态（BLOCKED）**等待，直到拿到锁重新进入运行状态。

- **要求：**

  1. 锁必须是对象，任何类的对象都可以充当锁
  2. 唯一性：必须确保使用多个线程共用一把锁（即锁对象是同一个），这个非常重要，否则就无法保证共享资源的安全

  

- **常用的锁对象：**

  - 创建一个任意唯一对象（不推荐，浪费内存）
  - this：需要保证每个线程都共享这个this，而不是各自创建一个this（[继承Thread类式](#2.1 继承Thread类式)创建的线程的this不唯一，所以不推荐）
  - 当前类.class\getClass()（一个类只会加载一次，所以每个类的Class对象都是唯一的，推荐）

  

- **释放锁的操作：**
  1.当前线程的同步方法、同步代码块执行结束。
  2.当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
  3.当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
  4.当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。



- **不会释放锁的操作：**
  1.线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行
  2.线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。

  > 注： 应尽量避免使用suspend()和resume()来控制线程

  

#### 6.1.2 同步方法

同步方法脱胎于同步方法块，机制基本类似，区别在于同步监视器。



**格式：** 

```java
synchronized returnType methodName(){
	// 需要同步的代码
}
```



**同步监视器（锁）：** 无需手动声明，是固定的，区别于同步方法块。若同步方法是实例的，便是 this 对象，若同步方法是静态的，便是本类的Class对象。所以当在[继承Thread类式](#2.1 继承Thread类式)创建的线程中想要使用同步方法来实现线程同步时，它的this对象不是唯一的，则需要使用==静态的同步方法==。



**注意事项：** 

1. synchronized关键字不能继承：在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以同步。



#### 6.1.3 Lock锁

从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition 。 



**Lock接口：** Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。



**ReentrantLock类：** ReentrantLock类 实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。



**步骤：**

1. 创建锁

   ```java
   ReentrantLock reentrantLock = new ReentrantLock();
   ```

2. 获取锁，锁上。在需要同步的代码前调用

   ```java
   reentrantLock.lock();
   ```

3. 释放锁，解锁。在可能出现线程安全的同步代码后调用

   ```java
   reentrantLock.unlock();
   ```



**注意事项：**

 1. 一定要手动关闭锁，否则将造成死锁
 2. 为了避免报错执行不到解锁操作，造成死锁，建议使用 try-finally，在finally调用unlock



**Lock相较于synchronized方式的不同：**

1. Lock是显式锁，手动释放，是更为灵活的结构，synchronized是隐式锁，出了作用域自动释放
2. Lock只有代码块锁，synchronized有同步代码块和同步方法
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）



### 6.2 死锁问题

不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。

线程出现死锁后，不会出现异常，不会出现提示，只是所有死锁的线程都处于阻塞状态，无法继续。

所以需要避免死锁的出现。



**解决方法：** 

1. 专门的算法、原则
2. 尽量减少同步资源的定义
3. 尽量避免嵌套同步



## 7 线程通信

当我们需要多个线程共同完成一个任务时，总希望它们互相协作，有规律的运行，而不是独立随机的运行。这时，就需要线程通信机制，通信机制即等待唤醒机制，主要包含等待和唤醒两种方式。



**线程通信的前提条件：** 多线程共同操作同一份共享数据，即需要同步机制时。



### 7.1 synchronized方式通讯

使用synchronized方式同步的多线程之间通讯，需要使用到wait()、notify()/notifyAll()方法，这三个方法定义在Object类中，所有的类的对象都会继承这些方法。



**注意事项：**

1. wait()/notify()/notifyAll()必须写在synchronized代码块中或synchronized方法中（lock中不行），否则会报 IllegalMonitorStateException 异常
2. wait()/notify()/notifyAll()是成对调用的，有等待，就有唤醒
3. wait()/notify()/notifyAll()的调用者必须是**同步监视器对象**，且必须由**同一个锁**调用



**wait与sleep的对比：**

- **相同点：**都能造成当前线程阻塞
- **不同点：**
  - wait方法是Object类的实例方法，sleep是Thread类的静态方法
  - wait只能在synchronized代码块中或synchronized方法中，sleep在任何地方都可以
  - wait会释放对象锁，sleep不释放



- **wait()**

  使当前线程状态变成**等待（WAITING）**或**超时等待(TIMED_WAITING)**，释放cpu执行权，不执行wait后面的代码，让其他线程先执行。

  ==wait()会释放对象锁，而sleep、yield不会，这是重点。==

  

  **重载用法：**

  - wait(): 无限等待，使当前线程状态变成**等待（WAITING）**，只有notify了才能唤醒
  - wait(long m): 限时等待，使当前线程状态变成**超时等待(TIMED_WAITING)**，超过时长m没被notify唤醒，自动醒来



- **notify()/notifyAll()**

  - **notify：** 唤醒，唤醒另外一个被wait的线程，重新进入就**绪状态（READY）**，抢夺执行权，抢到之后继续执行wait后面的代码。==如果有多个等待线程，选择其中一个唤醒， 选择是任意的==。

  - **notifyAll：** 唤醒所有被wait的线程



### 7.2 Lock锁方式通讯

Lock锁方式通讯需要java.util.concurrent.locks.Condition类提供的方法。Lock接口提供了一个newCondition的方法来返回Condition实例。

Condition类提供了await()、signal()/signalAll()来实现线程通讯，其功能分别与wait()、notify()/notifyAll()方法近似。



# 文件

File对象是Java中文件和目录路径名的抽象表示。File类的一个对象代表一个文件或文件目录（文件夹）。

==File类只涉及到文件层面的操作，不涉及到文件内容层面，文件内容层面需要IO流来操作==。



**不同系统的路径分隔符：**

1. windows和DOS系统默认使用反斜杆“\”来表示（\在java代码中有特殊意义，需要转义写成/），但在windows下也能识别“/”

2. Linux、UNIX和URL使用正斜杆“/”来表示

3. 最好使用“/”，因为java是跨平台的。

4. File类提供了一个常量：separator/separatorChar，会根据操作系统，动态的提供分隔符。

  > 注：Java程序支持跨平台运行，因此路径分隔符要慎用。



**实例方法：**详见代码示例。



# IO流

I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。

Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行。

java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。



- 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。
- 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。



## 1 流的分类

- 按操作**数据单位**不同分为：
  - **字节流(8 bit)：**传输过程中，传输数据的最基本单位是字节的流。一般以Stream结尾。一般用于处理字节数据（图片\视频\音频.doc.ppt...）。 ==字节流对字符文件也可以处理，但从内存直接读取打印会可能乱码，单纯的读取和写入不会有问题。==
  - **字符流(16 bit)：**传输过程中，传输数据的最基本单位是字符的流。一般以reader/writer结尾。一般只能处理字符数据（.txt.html.java...）。
- 按数据**流的流向**不同分为：
  - **输入流：**数据流向程序内存的叫作输入流。一般带有input/reader。
  - **输出流：**数据从程序内存流出的叫作输出流。一般带有output/writer。
- 以流相对于程序的另一个端点的分，按**流的角色**的不同分为：
  - **节点流：**以特定源如磁盘文件、内存某区域或者线程之间的管道为端点的构造输入输出流，是一种基本的流。
  - **处理流（过滤流）：**是对一个已存在的流为端点构造，进行连接和封装，通过所封装的流的功能调用实现数据读写。 ==关闭处理流的时候，会自动将自身所封装的流一并关闭，所以只需要关闭最外层的处理流即可。==



![IO流分类](.\images\javaSe\IO流\IO流分类.png)





Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个**抽象基类**派生的。

|            |    字节流    | 字符流 |
| :--------: | :----------: | :----: |
| **输入流** | InputStream  | Reader |
| **输出流** | OutputStream | Writer |



![IO流详细分类](.\images\javaSe\IO流\IO流详细分类.jpg)

## 2 流的操作

**IO流的基础操作：**

1. 流的实例化（new）
2. 读、写文件操作（read、write）
3. 流的关闭（close）

**其他操作：**刷新缓冲区（flush）、换行（newline）……



**注意：**

1. 流的操作一般都需要处理异常
2. 流关闭后将释放与之关联的所有资源，若不关闭会消耗性能，所以必须关闭，一般放在finally中执行
3. 在关闭该流后，再调用 read()、ready()、mark()、reset() 或 skip() 将抛出 IOException





## 3 常用流

### 3.1 文件流

- FileInputStream：字节输入文件流，节点流的一种；用于读取诸如图像数据之类的原始字节流。

- FileOutputStream：字节输出文件流，属节点流的一种；用于写入诸如图像数据之类的原始字节流。

- FileReader：字符输入文件流，属于节点流的一种；用来读取字符文件的便捷类。

- FileWriter：字符输出文件流，属于节点流的一种；用来写入字符文件的便捷类。

  > 实际开发一般不会用这四个，因为效率太低

  

### 3.2 缓冲流

- BufferedInputStream：字节输入缓冲流
- BufferedOutputStream：字节输出缓冲流
- BufferedReader：字符输入缓冲流
- BufferedWriter：字符输出缓冲流



缓冲流属于处理流。

为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个**内部缓冲区数组**，缺省使用**8192个字节(8Kb)的缓冲区**。 

java缓冲流本身不具IO功能，只是在别的流上加上缓冲提高效率，像是为别的流装上一种包装（处理流）。因为缓冲流先将数据缓存起来，然后一起写入或读取出来。所以说，缓冲流还是很重要的，在IO操作时记得加上缓冲流提升性能。

- 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 

- 当写入数据时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方flush()可以强制将缓冲区的内容全部写入输出流。



**不带缓冲的流的工作原理：**

它读取到一个字节/字符，就向用户指定的路径写出去，读一个写一个，所以就慢了。



**带缓冲的流的工作原理：**

读取到一个字节/字符，先不输出，等凑足了缓冲的最大容量后一次性写出去，从而提高了工作效率



**优点：**减少对硬盘的读取次数，降低对硬盘的损耗。



**关闭缓冲流的顺序：**

关闭流的顺序和打开流的顺序相反。**只要关闭最外层流即可**，关闭最外层流也会自动关闭内层节点流。



**flush()方法：**

刷新缓冲区，手动将buffer中内容写入文件。

> 注意：执行缓冲流的close()方法，不但会关闭流，还会先调用flush()方法，在关闭流之前刷新缓冲区，所以不用手动调用。



### 3.3 转换流

- InputStreamReader：将字节输入流转字符输入流。期间做了一个解码的操作
- OutputStreamWriter：将字符输出流转字节输出流。期间做了一个编码的操作



转换流属于处理流，提供了在字节流和字符流之间的转换。

**功能：**

- 字节流和字符流互相转换：当我们拿到一个字节流，但里面数据都是字符时，我们可以使用转换流将它转成字符流，==转成字符流操作更高效。==

- 字符集转换：转换流还提供了字符集转换的功能，很多时候我们使用转换流来处理文件乱码问题（字符集导致）。

  > 字符集是保存在文件中，跟随文件的。



![转换流](.\images\javaSe\IO流\转换流.png)



### 3.4 数据流

- DataInputStream：数据字节输入流

- DataOutputStream：数据字节输出流



数据流属于处理流，用于读写**基本类型**、**字符串类型**、**byte[]类型**的数据，能够持久化储存==带有类型==的数据。



**注意：**

1. 数据流读取类型数据的顺序需要与写入类型数据的顺序一致



### 3.5 对象流

- ObjectInputStream：对象字节输入流

- OjbectOutputSteam：对象字节输出流



用于存储和读取**基本数据类型数据**或**对象**的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。



**注意：**

1. 对象流操作的对象要求是[可序列化的对象](#9 对象的序列化和反序列化)。

   

### 3.6 打印流

- PrintStream：打印字节输出流
- PrintWriter：打印字符输出流



打印流属于处理流，实现将**基本数据类型的数据格式**转化为**字符串**输出。



**注意：**

1. PrintStream和PrintWriter提供了一系列重载的print()和println()方法，用于多种数据类型的输出。
2. PrintStream和PrintWriter的输出不会抛出IOException异常。
3. PrintStream和PrintWriter有自动flush功能。
4. PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 



### 3.7 标准输入输出流

- System.in：标准输入流，类型是InputStream，是InputStream子类的实例。

  > System.in一般和Scanner类来配合使用。

- System.out：标准输出流，是PrintStream的一个实例对象。

- System.err：标准错误输出流，是PrintStream的一个实例对象。



System.in/out/err都是使用单列模式。

System.in和System.out分别代表了系统标准的输入和输出设备。

默认输入设备是==键盘==，输出设备是==显示器==。

> 重定向：通过System类的静态方法setIn()，setOut()来对默认设备进行改变。



**注意：**

1. 一般标准输入输出流不用手动关闭，关闭了就不能用了，留给的垃圾回收机制去处理就可以。



### 3.8 随机存取文件流

RandomAccessFile类声明在java.io包下，但直接继承于java.lang.Object类，并不是继承于四大IO抽象基类。

它实现了DataInput、DataOutput这两个接口，也就意味着这个类==既可以读也可以写==。

属于字节流。

RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件：

- 支持只访问文件的部分内容
- 可以向已存在的文件后追加内容

RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针：

- long getFilePointer()：获取文件记录指针的当前位置
- void seek(long pos)：将文件记录指针定位到 pos 位置



**构造器：**

- public RandomAccessFile(File file, String mode) 
- public RandomAccessFile(String name, String mode)

创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指 定 RandomAccessFile 的访问模式：

- r: 以只读方式打开（输入流）
- rw：打开以便读取和写入（输入、输出流）
- rwd:打开以便读取和写入；同步文件内容的更新（输入、输出流）
- rws:打开以便读取和写入；同步文件内容和元数据的更新（输入、输出流）

**注意：**

- rw模式虽然既可当输出流又可当输入流，但创建出来的流只能当一种角色的流：输出流或输入流
- 如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。
- RandomAccessFile充当输出流时，对文件实现文件内容上的从头覆盖，而不是整体文件的覆盖，如先写入“abcdef”， 再写入“hij”，就会变成“hijdef”，覆盖位置可自定义，默认是0
- JDK 1.6上面写的每次write数据时，"rw"模式，数据不会立即写到硬盘中；如果写数据过程发生异常，"rwd"模式中已被write的数据被保存到硬盘,而“rw”则全部丢失。



**运用：**

我们可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能，用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上 一次的地方下载，从而实现断点下载或上传的功能，有兴趣的朋友们可以自己实现下。



## 4 NIO？

Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。

NIO是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。

Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。

随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。 因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。

```
  ├──FileChannel:处理本地文件
  ├──SocketChannel：TCP网络编程的客户端的Channel
  ├──ServerSocketChannel:TCP网络编程的服务器端的Channel
  └──DatagramChannel：UDP网络编程中发送端和接收端的Channel
```



**NIO.2中Path、Paths、Files类：**：

早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异 常信息。

NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资 源也可以不存在。

在以前IO操作都是这样写的:

```
import java.io.File;
File file = new File("index.html");
```

但在Java7 中，我们可以这样写：

```
import java.nio.file.Path; 
import java.nio.file.Paths; 
Path path = Paths.get("index.html");
```

同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件和目录； Paths则包含了两个返回Path的静态工厂方法。



**Paths 类提供的静态 get() 方法用来获取 Path 对象：**

- static Path get(String first, String … more) : 用于将多个字符串串连成路径
- static Path get(URI uri): 返回指定uri对应的Path路径



**Path 常用方法：**

```
- String toString() ： 返回调用 Path 对象的字符串表示形式
- boolean startsWith(String path) : 判断是否以 path 路径开始
- boolean endsWith(String path) : 判断是否以 path 路径结束
- boolean isAbsolute() : 判断是否是绝对路径
- Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径
- Path getRoot() ：返回调用 Path 对象的根路径
- Path getFileName() : 返回与调用 Path 对象关联的文件名
- int getNameCount() : 返回Path 根目录后面元素的数量
- Path getName(int idx) : 返回指定索引位置 idx 的路径名称
- Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象
- Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象
- File toFile(): 将Path转化为File类的对象
```



**Files常用方法：**

```
- Path copy(Path src, Path dest, CopyOption … how) : 文件的复制
- Path createDirectory(Path path, FileAttribute<?> … attr) : 创建一个目录
- Path createFile(Path path, FileAttribute<?> … arr) : 创建一个文件
- void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错
- void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除
- Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置
- long size(Path path) : 返回 path 指定文件的大小

用于判断
- boolean exists(Path path, LinkOption … opts) : 判断文件是否存在
- boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录
- boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件
- boolean isHidden(Path path) : 判断是否是隐藏文件
- boolean isReadable(Path path) : 判断文件是否可读
- boolean isWritable(Path path) : 判断文件是否可写
- boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在

用于操作内容
- SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连
  接，how 指定打开方式。
- DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录
- InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象
- OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象
```



# 网络编程

Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。

Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并 且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。



**计算机网络：**

把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。



**网络编程的目的：**

直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。



**网络编程中有两个主要的问题：**

- 如何准确地定位网络上一台或多台主机，定位主机上的特定的应用
- 找到主机后如何可靠高效地进行数据传输



**实现网络中的主机互相通信的两要素：**

- 双方的通信地址：
  - IP
  - 端口号



- 通讯规则，即网络通信协议。有两套参考模型：
  - OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广
  - TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。



## 1 通信地址

### 1.1 IP地址

IP地址（InetAddress）是**唯一的标识** Internet 上的计算机（通信实体）。

缺点是不易记忆。



**本地回环地址(hostAddress)：**127.0.0.1

**本地主机名(hostName)：**localhost



**IP地址分类方式1：**

1. IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如：192.168.0.1
2. IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984



**IP地址分类方式2：**

公网地址(万维网使用)和私有地址(局域网使用)。192.168.开头的就是私有址址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用。



#### 1.1.1 Java中的IP对象

Java中使用InetAddress类主要表示IP地址。



**InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取InetAddress实例（单例模式）：**

- public static InetAddress getLocalHost()
- public static InetAddress getByName(String host)



**InetAddress类还有两个子类：**

- Inet4Address：代表IPv4版本的IP地址

- Inet6Address：代表IPv6版本的IP地址



### 1.2 端口号

端口号（Port number）标识正在计算机上运行的**进程**（程序）。不同的进程有不同的端口号。

端口号被规定为一个 16 位的整数 0~65535。

端口号与IP地址的组合得出一个网络套接字：Socket。



**端口分类：**

1. 公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23） 
2. 注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat默认占用端口8080，MySQL默认占用端口3306，Oracle默认占用端口1521等）。
3. 动态/私有端口：49152~65535。

![端口号](.\images\javaSe\网络编程\端口号.png)



### 1.3 主机名

主机名（hostname）就是计算机的名字（计算机名），因特网上的主机或Web站点由主机名识别。主机名有时称为**域名**。主机名映射到IP地址，但是主机名和IP地址之间没有一对一关系。

主机名由称为DNS服务器或域名服务器的服务器映射到IP地址。DNS代表域名服务。在大型网络中，许多DNS服务器可以相互协作，以提供主机名和IP地址之间的映射。

在互联网中，主机名称被附在域名系统（DNS）的域名之后，形成完整域名。



**本地主机名：**localhost



### 1.4 域名

域名（Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。

由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。

尽管IP地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且用户记忆十分不方便，于是人们又发明了另一套字符型的地址方案，即所谓的域名地址。IP地址和域名是一一对应的，这份域名地址的信息存放在一个叫域名服务器(DNS，Domain name server)的主机内，使用者只需了解易记的域名地址，其对应转换工作就留给了域名服务器。域名服务器就是提供IP地址和域名之间的转换服务的服务器。

![域名ip之间的关系](.\images\javaSe\网络编程\域名ip之间的关系.png)



**域名入网结构：**主机名、机构名、网络名、最高层域名



**Internet上的主机有两种方式表示地址：**

- 域名(domain name)：[www.atguigu.com](http://www.atguigu.com/)
- IP 地址(hostAddress)：202.108.35.210



**主机名和域名的联系与区别如下：**

1. Internet域名是Internet网络上的一个服务器或一个网络系统的名字，在全世界，没有重复的域名。==域名的范围要比主机名大==。一个域名下可以有多个主机名，域名下还可以有子域名。例如,域名cnwg.cn下，有主机server1和server2，其主机全名就是server1.cnwg.cn和server2.cnwg.cn。
2. 主机名的含义是机器本身的名字，域名是方面记录IP地址才做的一种IP映射；二者有共性：都能对应到一个唯一的IP上。从应用场景上可以这么简单理解二者的==区别：主机名用于局域网中；域名用于公网中==。



## 2 网络通信协议

计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。



**复杂性：**

计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？



**通信协议分层的思想（解决复杂性）：**

在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。



**传输层协议中有两个非常重要的协议：**

1. 传输控制协议TCP(Transmission Control Protocol)
2. 用户数据报协议UDP(User Datagram Protocol)。



**TCP/IP协议簇：**

TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是==一组协议==，包括多个具有不同功能且互为关联的协议，其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。

传统的开放式系统（OSI）互连参考模型，是一种通信协议的7层抽象的参考模型，其中每一层执行某一特定任务。该模型的目的是使各种硬件在相同的层次上相互通信。而TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即==物理+数据链路层、网络层、传输层和应用层==。

![网络通信协议](.\images\javaSe\网络编程\网络通信协议.png)



### 2.1 TCP协议

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于**字节流**的传输层通信协议。TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。



**特性：**

- 使用TCP协议前，须先建立TCP连接，形成传输数据通道
- 传输前，采用“**三次握手**”方式，点对点通信，是可靠的
- TCP协议进行通信的两个应用进程：**客户端、服务端**。
- 在连接中可进行大数据量的传输
- 传输完毕，需释放已建立的连接，**效率低**



![socket](.\images\javaSe\网络编程\socket.jpg)



![三次握手](.\images\javaSe\网络编程\三次握手.png)

![四次挥手](.\images\javaSe\网络编程\四次挥手.png)

### 2.2 UDP协议

UDP 是User Datagram Protocol的简称， 中文名是用户数据包协议。UDP是无连接传输协议，且不对传送数据包进行可靠性保证，适合于一次传输少量数据。UDP使用底层的互联网协议来传送报文，同IP一样提供不可靠的无连接数据包传输服务。==它不提供报文到达确认、排序、及流量控制等功能==。UDP不保证数据能够安全送到目的地，也不能确定什么时候可以抵达。



**特性：**

- 将数据、源、目的封装成数据包，**不需要建立连接**
- 每个数据报的大小限制在64K内 
- 发送不管对方是否准备好，接收方收到也不确认，故是**不可靠的** 
- 可以广播发送
- 发送数据结束时**无需释放资源，开销小，速度快**



![udp](.\images\javaSe\网络编程\udp.gif)



## 3 Socket编程

### 3.1 Socket

Socket的英文原义是“孔”或“插座”，在网络编程中，中文叫作“套接字”。

Socket是对网络中不同主机上的应用进程之间进行==双向通信的端点==的抽象。在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个Socket。一个Socket就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，Socket上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。

Socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

Socket本质是编程接口(API)，==对TCP/IP的封装==，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。

Socket实质上提供了进程通信的端点。进程通信之前，双方首先必须各自创建一个端点，否则是没有办法建立联系并相互通信的。正如打电话之前，双方必须各自拥有一台电话机一样。



**特性简要：**

- 利用Socket开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。 
- 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 
- 通信的两端都要有Socket，是两台机器间通信的端点。 
- 网络通信其实就是Socket间的通信。
- Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。
- 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。



**Socket分类：**

- 流套接字（stream Socket）：使用TCP提供可依赖的字节流服务
- 数据报套接字（datagram Socket）：使用UDP提供“尽力而为”的数据报服务



### 3.2 基于Socket的TCP编程

**Java基于Socket的TCP协议网络编程需要使用到两个类：**

- Socket：客户端套接字
- ServerSocket：服务器端套接字



**实现步骤：**

1. **服务器监听：**是服务器端套接字并不定位具体的客户端Socket，而是**处于等待连接的状态，实时监控网络状态**。服务器一定要先启，若客户端先启，无法连接会报错。

2. **客户端请求：**是指由客户端套接字提出连接请求，要连接的目标是服务器端套接字。为此，客户端套接字必须首先描述它要连接的服务器套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

3. **连接确认：**是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，==建立一个新的线程==，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而==服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求==。

   > 客户端与服务器是两个独立的运行程序



**客户端套接字实现步骤：**

1. **创建套接字：**使用Socket类，根据指定服务端的 IP 地址或端口号创建客户端套接字对象。创建的同时会自动向服务器方发起连接。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。
2. **获取IO流：** 使用客户端套接字对象getInputStream()方法获得输入流，使用Socket对象的getOutputStream()方法获得输出流，进行数据传输
3. **进行读/写操作：**通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。
4. **关闭操作：**关闭所有IO流，套接字



**服务器套接字实现步骤：**

1. **创建套接字：**使用ServerSocket类创建一个服务器端套接字对象，并绑定到指定端口上。用于监听客户端的请求。
2. **开始监听请求：**调用服务器端套接字对象的accept()方法，监听连接请求，如果客户端请求连接，则接受连接，同时返回==客户端套接字对象==。 
3. **获取IO流：**调用==客户端套接字对象==的 getOutputStream() 和 getInputStream()，获取输出流和输入流，开始网络数据的发送和接收。
4. **关闭操作：**关闭所有IO流，套接字



### 3.2 基于Socket的UDP编程

**Java实现UDP通信主要用到了两个类：**

- DatagramSocket：用于发送和接收数据包的套接字，系统不保证UDP数据包一定能够安全送到目的地，也不能确定什么时候可以抵达。

- DatagramPacket：用于封装了UDP数据包，在数据报包中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。

> UDP协议中每个数据包都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。



**实现步骤：**

1. 接收端监听接收
2. 发送端发送数据包

> 发送端与接收端是两个独立的运行程序



**发送端实现步骤：**

1. **创建套接字：**使用DatagramSocket类创建发送端套接字对象。
2. **封装数据包：**使用DatagramPacket类创建数据包对象，包含数据（byte[]格式）、ip、端口信息。
3. **发送操作**：发送端套接字对象调用send()，将数据包发送
4. **关闭操作**：关闭套接字



**接收端实现步骤：**

1. **创建套接字：**使用DatagramSocket类创建接收端套接字对象。
2. **封装接收数据包：**使用DatagramPacket类创建数据包对象，包含一个空的数据（byte[]格式），用于接收
3. **接收操作**：接收端套接字对象调用receive()，监听接收
4. **关闭操作**：关闭套接字



## 3 URL编程

URL(Uniform Resource Locator)表示统一资源定位符，它表示 Internet 上某一 资源的地址。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何定位到这个资源。

通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。



**URL的基本结构由5部分组成：**<传输协议>://<主机名>:<端口号>/<文件名>#片段名?参数列表

**片段名：**即锚点，例如看小说，直接定位到章节

**参数列表格式：**参数名=参数值&参数名=参数值

**例如：**`http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&password=123`



**URI、URL、URN的区别：**

URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。

URL是uniform resource locator，统一资源定位符。URL是URI的一种，不仅标识了一个资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置。

URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如`mailto:java-net@java.sun.com`。

也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。

在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则 不仅符合语义，还包含了定位该资源的信息， 因此它不能是相对的。

URL和URN都是URI的子集。

![URI,URL,URN关系图](.\images\javaSe\网络编程\URI,URL,URN关系图.webp)



### 3.1 Java中的URL编程

Java中使用java.net.URL类表示URL，使用java.net.HttpURLConnection类表示Java应用程序和URL之间的http特性的通信连接。



**步骤：**

1. 创建URL对象：URL url = new URL(...)
2. 创建连接对象：HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
3. 建立连接：urlConnection.connect()
4. 获取输入流：urlConnection.getInputStream()
5. 操作流数据：读取、写出数据
6. 关闭流



# Stream API

Stream API ( java.util.stream) 把真正的**函数式编程风格**引入到Java中。这 是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程 序员的生产力，让程序员写出高效率、干净、简洁的代码。

Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，**Stream API 提供了一种 高效且易于使用的处理数据的方式。**

Stream到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。

“集合讲的是数据，Stream讲的是计算！”



**为什么要使用Stream API：**

实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要**Java层面**去处理。



**Stream 和 Collection 集合的区别：**

Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。



**特性：**

- Stream 自己不会存储元素。
- Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 
- Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。



**Stream 操作步骤：**

1. **创建 Stream 对象：**一个数据源（如：集合、数组），获取一个 Stream 对象
2. **中间操作：**一个中间操作链，对数据源的数据进行处理
3. **终止操作(终端操作)：**一旦执行终止操作，就**执行中间操作链**，并产生结果。之后，不会再被使用

> 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。

![Stream操作步骤](.\images\Stream API\Stream操作步骤.jpg)



## 1 创建实例

**获取Stream实例方式：**

1. 通过容器（集合、数组）获取Stream实例
   1. 集合的实例方法返回：collection.stream()、collection.parallelStream()
   2. Arrays 的静态方法：Arrays.stream(arr)
2. 通过Stream.of()获取实例：Stream.of(T... values)
3. 创建无限流
   1. 用静态方法 Stream.iterate() 
   2. 用静态方法 Stream.generate()



## 2 中间操作

详见代码示例。

## 3 终止操作

详见代码示例。



# 设计模式

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设 计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠 性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化， 设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以 完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一 个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。

## 1 设计模式的分类

**总体来说设计模式分为三大类：**

1. 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
2. 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模 式、享元模式。
3. 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、 命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。



具体如下： 

**其中创建型有：**

一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访 问点

二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口， 而无须指定它们的具体类。

三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化 哪一个类，Factory Method使一个类的实例化延迟到了子类。

四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构 建过程可以创建不同的表示。

五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原 型来创建新的对象。



**行为型有：**

六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又 不需要暴露该对象的内部表示。

七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都得到通知自动更新。

八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延 迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该 算法得某些特定步骤。

九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请 求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。

十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似 乎改变了他的类。

十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们 可以互相替换，本模式使得算法可以独立于使用它们的客户。

十二、Chain of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避 免请求的送发者和接收者之间的耦合关系

十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。

十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使 你可以在不改变各元素类的前提下定义作用于这个元素的新操作。

十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义 一个解释器，这个解释器使用该表示来解释语言中的句子。

十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态， 并在该对象之外保存这个状态。



**结构型有：**

十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系， Composite使得用户对单个对象和组合对象的使用具有一致性。

十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，facade提供了一 高层接口，这个接口使得子系统更容易使用。

十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问

二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter 模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。

二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功 能来说，Decorator模式相比生成子类更加灵活。

二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的 变化。

二十三、Flyweight，享元模式



其实还有两类：**并发型模式**和**线程池模式**。



## 2 单例模式

单例模式（Singleton）是一种常用的设计模式。该模式能保证在一个 JVM 中，某类只有一个实例存在。例如：java.lang.Runtime。



**好处：**

1. 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
2. 省去了 new 操作符，降低了系统内存的使用频率，减轻 GC 压力。
3. 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程



**应用场景:**

1. 网站的计数器，一般也是单例模式实现，否则难以同步。
2. 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
3. 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
4. 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。
5. Application 也是单例的典型应用
6. Windows 的 Task Manager (任务管理器)就是很典型的单例模式
7. Windows 的 Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例



**要求：**

1. 私有化（private）的构造器
2. 内部创建类的对象，并保证只创建一个
3. 通过静态方法获得实例对象



**分类：**

- 饿汉式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。
  - 坏处：对象加载时间过长
  - 好处：线程安全
- 懒汉式（推荐）：在类加载时不初始化，等到第一次被使用时才初始化。
  - 坏处：延迟对象创建，需要处理线程不安全的问题
  - 好处：避免类加载时就完成了初始化，但后面又不用，造成内存浪费



**具体实现：**详见代码示例。



## 3 MVC模式？




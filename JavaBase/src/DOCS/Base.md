# 总概

 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。

 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。



[JDK各版本发布时间](https://zhuanlan.zhihu.com/p/269860416)



**Java基础知识图解：**

![Java基础知识图解](.\images\总概\Java基础知识图解.png)



## 1 动态语言 vs 静态语言

1. **动态语言**

   动态语言是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。`通俗点说就是在运行时代码可以根据某些条件改变自身结构`。

   **主要动态语言：**Object-C、C#、JavaScript、PHP、Python、Erlang等。

   

2. **静态语言**

   静态语言与动态语言相对应的，运行时结构不可变的语言就是静态语言。

   **主要静态语言：**Java、C、C++等。

   

> 注意：Java虽然是静态语言，但Java可以称之为“准动态语言”，即Java有一定的动态性，就是因为我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！



## 2 面向对象

 面向对象(Object Oriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。

 面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。

 面向对象编程（Object Oriented Programming，OOP）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是**类和对象**。



**面向对象特征的三个特征：**封装性、继承性、多态性



**面向对象编程（OOP）与面向过程编程（POP）的区别：**

1. 二者都是一种编程思想，面向对象是相对于面向过程而言的。

   **面向过程，强调的是功能行为，以函数为最小单位，着重于怎么做**。

   **面向对象，将功能封装进对象， 强调具备了功能的对象，以类/对象为最小单位，着重于谁来做。**

   

2. 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。



**理解Java中的“万事万物皆对象”：**

1. 在Java中，我们将功能、结构等封装到类中，填过类的实例化，来调用具体的功能结构
2. 涉及到Java语言与前端、后端的数据库交互时，前后端结构在Java层面交互时，都体现为类、对象



## 3 设计一个项目的思路

1. 罗列出项目中存在的实体
2. 分析实体需要体现的属性和功能，以此设计类和接口
3. 将类实例化成对象。对象是解决问题的最终工具



## 4 常量池

- [Java中几种常量池的区分](http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/)
- [常量池详解](https://zhuanlan.zhihu.com/p/64839455)
- [字符串常量池和运行时常量池是在堆还是在方法区？](https://blog.csdn.net/weixin_44556968/article/details/109468386)
- [字面量进入字符串常量池的时机](https://www.zhihu.com/question/55994121/answer/147296098)
- [JVM 常量池中存储的是对象还是引用呢？](https://www.zhihu.com/question/57109429)



常量池逻辑上是属于方法区。



Java中基本类型的包装类的大部分都实现了常量池技术，这些类是**Byte，Short，Integer，Long，Character，Boolean**，**另外两种浮点数类型（Float、Double）的包装类则没有实现**。另外Byte，Short，Integer，Long，Character这5种整型的包装类也只是在**-128到127之间**时才可使用常量池，也即对象不负责创建和管理大于127的这些类的对象。



了解[字符串常量池](#1 字符串常量池 )。



**常量池的好处**：

常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。
（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。

## 5 JDK、JRE、JVM关系

![JDK&JRE&JVM关系示意图](.\images\总概\JDK&JRE&JVM关系示意图.png)

- **JDK：**

  Java Development Kit，Java开发工具包

- **JRE：**

  Java runtime environment，Java运行环境

- **JVM：**

  Java Virtual Machine，Java虚拟机



**使用的人群：**JDK是给开发人员用的，JRE和JVM是普通用户用的。



## 6 JVM内存

![java内存](.\images\总概\java内存.png)

- **堆（Heap）**

  此内存区域的唯一目的就是存放对象实例几乎所有的对象。 实例都在这里分配内存，包括对象的属性（非静态）。

  这一点在Java虚拟机规范中的描述是：所有的对象实例、数组都要在堆上分配。

  - 凡是new出来的东西都，都存放在堆中。

  - 堆中的所有东西都有一个16进制的地址值。

  - 堆中的数据都有默认值。

- **栈（Stack）**

  通常所说的栈是指**虚拟机栈**。虚拟机栈用于存储**局部变量**等。 

  局部变量表存放了编译期可知长度的各种基本数据类型boolean、byte、char、short、int、float、long、double、对象引用（引用类型在堆内存的首地址），方法执行完，自动释放。

- **本地方法栈（Native Method Stack）**

  操作系统相关，调用一些C、C++等类库。

- **方法区（Method Area）**

  用于存储已被虚拟机加载的**类信息、常量（池）、静态（域）变量、即时编译器编译后的代码**。

- **寄存器（程序计数器\Program Counter Register\PC Register）**

  CPU相关。





## 7 执行顺序

1. 编译完源程序，生成字节码文件
2. JVM中的类加载器和解释器对字节码文件解释运行
3. 运行中，字节码文件中对应的类被加载到各内存中，这里涉及到内存解析



## 8 元空间

https://baijiahao.baidu.com/s?id=1664760592941035748&wfr=spider&for=pc

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：

-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。

-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：

-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集.

-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集





# 数据类型

Java数据类型可分为**基本类型**和**引用类型**两大类。

**基本类型分为八种：**六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 其中整数型：byte、short、int、long。

**引用类型：**类、接口、数组

![数据类型](.\images\数据类型\数据类型.png)



## 1 默认值

存放在堆中的数据都有默认值，如数组的元素、成员变量等。

| **数据类型**           | **默认值** |
| :--------------------- | :--------- |
| byte                   | 0          |
| short                  | 0          |
| int                    | 0          |
| long                   | 0L         |
| float                  | 0.0f       |
| double                 | 0.0d       |
| char                   | 'u0000'    |
| boolean                | false      |
| String (or any object) | null       |



## 2 基本数据类型

- **byte：**

  byte 数据类型是8位、有符号的，以二进制补码表示的整数。

  - 最小值是 -128（-2^7）；
  - 最大值是 127（2^7-1）；
  - 默认值是 0；

  byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一。

  例子：byte a = 100，byte b = -50。



- **short：**

  short 数据类型是 16 位、有符号的以二进制补码表示的整数

  - 最小值是 -32768（-2^15）
  - 最大值是 32767（2^15 - 1）
  - 默认值是 0

  Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一。

  例子：short s = 1000，short r = -20000。



-  **int：**

  int 数据类型是32位、有符号的以二进制补码表示的整数。

  - 最小值是 -2,147,483,648（-2^31）
  - 最大值是 2,147,483,647（2^31 - 1）
  - 默认值是 0 

  一般地整型变量默认为 int 类型。

  例子：int a = 100000, int b = -200000。



- **long：**

  long 数据类型是 64 位、有符号的以二进制补码表示的整数。

  - 最小值是 -9,223,372,036,854,775,808（-2^63）
  - 最大值是 9,223,372,036,854,775,807（2^63 -1）
  - 默认值是 0L

  这种类型主要使用在需要比较大整数的系统上。

  例子： long a = 100000L，Long b = -200000L。

  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。



- **float：**

  float 数据类型是单精度、32位、符合IEEE 754标准的浮点数。 float 在储存大型浮点数组的时候可节省内存空间；

  - 默认值是 0.0f

  浮点数不能用来表示精确的值，如货币；

  例子：float f1 = 234.5f。

  

- **double：**

  double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型；

  - 默认值是 0.0d；

  double类型同样不能表示精确的值，如货币；

  例子：double d1 = 123.4。



- **boolean：**

  boolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；

  - 默认值是 false；

  例子：boolean one = true。



- **char：**

  char类型是一个单一的 16 位 Unicode 字符；

  - 最小值是 \u0000（即为0）；
  - 最大值是 \uffff（即为65,535）；

  char 数据类型可以储存任何字符；

  例子：char letter = 'A';。



## 3 基本类型的自动转换

基本数据类型（除布尔类型外）在某些情况下将发生数据类型自动转换。这些情况包括：赋值运算，数学运算，三目运算，传参等。



**快速记忆：** 数字相关才能玩，运算，传参，不带布尔玩



**自动类型转换（提升）特点：**

1. 代码不需要进行特殊处理，自动完成。
2. 数据范围从小到大自动转变（与字节数无关），所以也叫提升。
3. byte/short/char这三种类型在运算的时候，都默认被先提升成为int类型，然后计算
4. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）



## 4 基本类型的强制转换

向下转换，将数据是从范围大到小的转换。



**格式：** 

```java
（类型）数据
```



**快速记忆：**小小括号能强制，数字相关才能玩，就是不带布尔玩；从小到大很没问题，从大到小要亏损；byte/short/char搞特殊，常量不超范围可省略。



**注意事项：**

1. 不推荐使用，有可能发生精度损失、数据溢出
2. byte/short/char三种类型：如果【常量数据】强制转换为此三种类型，且常量数据【不超过此三种类型范围】，可以省略强制格式——"(类型)"
javac编译器将会自动隐含地补上一个(byte)(short)(char)
3. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）





## 5 包装类

Java语言是一个面向对象的语言，但并不是<u>纯面向对象的语言</u>。基本数据类型不是面向对象的，它们不具有继承性、多态性、封装性。这时，我们就需要利用包装类(Wrapper Class)将基本类型数据转化成引用类型！在实际使用中经常将基本数据类型转换成对象，便于操作，比如，集合的操作中。

> 包装类是属于引用类型，包装类都位于java.lang包下。



![包装类的继承关系](.\images\数据类型\包装类的继承关系.png)



**基本类型与包装类的对应关系：**

| 基本类型 |      包装类       |
| :------: | :---------------: |
|   byte   |       Byte        |
|  short   |       Short       |
|   int    |  Integer【特殊】  |
|   long   |       Long        |
|  float   |       Float       |
|  double  |      Double       |
|   char   | Character【特殊】 |
| boolean  |      Boolean      |



**装箱与拆箱：** 

即基本类型和包装类之间的转换。

- 装箱：基本类型 --> 包装类对象
- 拆箱：包装类对象 --> 基本类型



**为什么需要装箱与拆箱：**

- 基本类型不可调用方法、属性等对象才有的特性
- 包装类不可直接使用算术运算符，需要先转成基本类型



**手动装箱：**new包装类的构造器

**手动拆箱：**调用包装类方法：`xxx.xxxValue()`



**自动装箱、自动拆箱：**

从JDK 1.5+开始，支持自动装箱、自动拆箱。

如：

```java
Type var = value;
```



**包装类的缓存机制（[常量池](#4 常量池)）：**

包装类内部有一个 XxxCache 的静态结构（如：IntegerCache），如果我们自动装箱的范围在：-128~127之间，就会缓存在 XxxCache.cache 这个数组里，
如果再次调用，直接使用缓存中的地址，不会再去 new 了。



目的：提高效率。

> 注意：手动装箱没有缓存（使用new），自动装箱有缓存



## 6 基本类型和String转换

**快速记忆：** 基本转String用valueOf，toString，拼接符号黑科技；String转基本用parse，只有char搞特殊。

![基本类型、包装类、String的转换](.\images\数据类型\基本类型、包装类、String的转换.png)

### 6.1 **基本类型转String**

- String.valueOf(basic)

  如：

  ```java
  String str1 = String.valueOf((byte) 1);
  ```

- 包装类的toString方法

  如：

  ```java
  String str1 = Byte.toString((byte) 1);
  ```

- 字符串拼接方式

  如：

  ```java
  String str1 = (byte) 1 + "";
  ```



### 6.2 String转基本类型

- 包装类的`Xxx.parseXxx(str)`方法（不适用于char）

  如：

  ```java
  byte byte2 = Byte.parseByte("1");
  ```

- String --> char

  - 方式一：

    ```java
    char char1 = "A".charAt(0);
    ```

  - 方式二：

    ```java
    char char2 = (char) Integer.parseInt("65");
    ```



# 变量、常量、字面量

变量可分为[局部变量](#2 局部变量)与[成员变量](#2.1 成员变量)，与常量可分为[局部常量](#3 局部常量)与[成员常量](#8.2.1 成员常量)（以及[接口的成员常量](#4.2 常量)）。

## 1 变量

**命名格式：**小驼峰（myName）



**书写格式：**

```java
// 声明+赋值
Type var = value;

// 先声明再赋值
Type var;
var = value;

// 同时定义多个变量
Type var = value1, var2 = value2;

// 多个变量先声明再赋值
Type var1, var2;
var1 = value1;
var2 = value2;
```



**注意事项：** 

1. 变量名不能重复。
2. 对于float和long类型，后缀F和L不能忘记。
3. byte和short类型，数值不能超出范围。
4. 变量一定先定义（声明+赋值）后使用，**若不使用可以不赋值**。
5. 变量的使用不能超出作用域范围。
6. 局部变量声明后，必须显式赋值才能使用（局部变量声没有默认值）。成员变量可以不显式赋值，因为它有隐式赋值（默认值）。
7. 不能使用权限修饰符，但可以使用final修饰（常量）



**变量传递机制：**

- 基本数据类型：传递数据值
- 引用数据类型：传递地址值



## 2 常量

常量可看作特殊的变量，属于不可变的变量。在程序运行期间，固定不变的量，即“一次赋值，终生使用”，此外其他机制基本与变量一致。



**命名格式：**全大写，底杠分割，如：MY_NAME



## 3 字面量

字面量也叫字面值，直接量。在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。

字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。

```cpp
int a; // 变量
const int b = 10; // b为常量，10为字面量
string str = “hello world！”; // str 为变量，hello world！为字面量
```



**字面量的分类：**

1. 整数字面量：分为byte、short、int、long，默认为int类型。如果
2. 字符串字面量：凡是用双引号引起来的部分，叫做字符串字面量。例如："abc"、"Hello"、"123"
3. 浮点数字面量：直接写上的数字，有小数点，默认为double类型。例如：2.5、-3.14、0.0
4. 字符字面量：凡是用单引号引起来的单个字符，就做字符字面量。例如：'A'、'b'、'9'、'中'
5. 布尔字面量：只有量中取值。true、false。
6. 空字面量：null。代表没有任何数据。



**编译器的常量优化：** 

在给变量进行赋值的时候，如果右侧的表达式当中全都是**字面量或常量，没有任何变量**，那么编译器javac将会直接将若干个字面量表达式计算得到结果。

如：short result = 5 + 8 ，等号右边全都是字面量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中优化成：short result = 13 。

这称为“编译器的常量优化”。（注意：一旦表达式当中有变量参与，那么就不能进行这种优化了）





# 运算符

**Java运算符可分为：**

- 算术运算符：+ - * / % ++ --
- 关系运算符：== != > < >= <=
- 位运算符：...
- 逻辑运算符：&& || ！
- 赋值运算符：= += -= *= /= %= ...
- 三目运算符：?:
- 其他运算符：instanceof 运算符



## 1 instanceof

instanceof用来测试一个对象是否为一个类或其子类的实例，或一个对象是否为一个接口或其子接口的实现类的实例，返回boolean值。



**书写格式：** 

```java
boolean bool = object instanceof Class/Interface
```



## 2 ==

==只比较栈中的值。

对于基本类型来说，== 是进行**数值**的比较。
对于引用类型来说，== 是进行**地址值**的比较。

> 注意： 对于常量池中的字符串也是比较的地址值，只不过在编译阶段就把常量池中相同字符串合并，只占用一个堆空间，共享一个地址值。所以 == 可以用于比较常量池中的字符串是否相等。



# 修饰符

Java语言提供了很多修饰符，主要分为以下两类：

1. 权限修饰符，通常放在语句的最前端（public，default...）

2. 非访问修饰符（final，static...）



## 1 权限修饰符

权限修饰符也叫访问控制符。Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

**访问范围：** public > protected > default > private

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |
| :---------- | :----- | :------- | :------------- | :------------- | :----- |
| `public`    | ✓      | ✓        | ✓              | ✓              | ✓      |
| `protected` | ✓      | ✓        | ✓              | ✓              |        |
| `default`   | ✓      | ✓        | ✓              |                |        |
| `private`   | ✓      |          |                |                |        |



### 1.1 public

对所有类可见。访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、变量以及方法不仅可以跨类访问，而且允许跨包（package）访问。



**使用对象：**类、接口、类成员



**注意：**一个源文件只能有一个public类输出



### 1.2 protected

对同一包内的所有类、所有子类内可见。



**使用对象：**类成员、类和对象.内部类。 



**注意：**

1. 不能修饰**接口的成员**
2. 不能修饰**外部的类\接口**



### 1.3 default

即默认，什么也不写。在同一包内可见，不使用任何修饰符。使



**用对象：**类、接口、类成员。



### 1.4 private

访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能在该类内部访问，外部一概不能访问，包括其子类，更不能允许跨包访问。

有一些变量和方法只作用在本类中，不必被外部访问或子类继承，则可以使用private修饰符；需要访问private成员变量，可通过Getter/Setter方法



**使用对象：**类成员、类和对象、内部类。 



**注意：**不能修饰类\接口（外部）



## 2 非访问修饰符

### 2.1 static

代表静态的、类的



**修饰对象：**

1. 类成员：变量、方法、内部类、代码块
2. 接口成员：常量、方法



**内存位置：**位于静态域（方法区）



### 2.2 final

代表最终、不可变、常量、不可继承、不可重写的

**修饰对象：**

 1. 外部类
 2. 内部类
 4. 类成员
 5. 局部变量
 6. 接口常量



**注意：**abstract 和 final 互相矛盾，所以不能同时使用（abstract 必须要被继承或重写）



**不可变原则：**

1. 对于基本类型来说，不可变说的是局部常量当中的数据不可改变
2. 对于引用类型来说，不可变说的是局部常量当中的地址值不可改变



### 2.3 abstract

代表抽象的、不可实例化的



**修饰对象：**

1. 类
2. 类成员：方法
3. 内部类：成员内部类、局部内部类



**注意：**构造方法、静态方法（static）、私有方法（private）、final方法都不可被重写，final类不可被继承，这些都与抽象冲突，不可同时使用。



### 2.4 synchronized  

代表同步的、线程安全的



**修饰对象：**

 1. 类
 2. 实例方法、静态方法
 3. 代码块



**注意：**

1. 接口方法不能使用synchronized关键字
2. 构造方法不能使用synchronized关键字，但可以使用synchronized代码块来实现同步。




# 数组

数组是引用数据类型，一种容器，可以同时存放多个数据值。

数组本身不提供任何操作方法，方法全部继承自 Object，如果需要操作数组建议使用 Arrays 工具类。

数组也是一种类，一种特殊的类。



**特殊性：** 数组没有一个class文件（例如Array）来储存数组类的相关属性和方法，所以实创实例过程与常规类不同。

具体原因参考：

- 链接1：https://blog.csdn.net/iteye_3313/article/details/81800350?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase

* 链接2：https://bbs.csdn.net/topics/390943750



**特点：** 

1. 数组只能储存同一种类型数据
2. 数组的长度在程序运行期间不可改变
3. 数组未重写 equals、toString 方法



## 1 初始化

**两种常见的初始化方式：**

- 动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。

  **格式：**`数据类型[] 数组名称 = new 数据类型[数组长度];`

  

- 静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。

  - **标准格式：**`数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };`
  - **省略格式：**`数据类型[] 数组名称 = { 元素1, 元素2, ... };`



**注意：**

1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。
2. 初始化格式可以拆分成为两个步骤：声明、初始化。
3. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。



**使用建议：** 如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。



## 2 数组长度

数组长度是数组的成员个数，是int类型的整数。 数组长度是 final 类型，数组一旦创建，程序运行期间，数组长度不可改变。



**访问格式：** array.length



## 3 数组默认值

使用动态初始化数组的时候，其中的元素将会自动拥有一个[默认值](#1 默认值)。



**注意事项：** 静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。



## 4 数组相关异常

- **空指针异常：**
  所有的引用类型变量，都可以赋值为一个null值。但是代表其中什么都没有。
  数组必须进行new初始化才能使用其中的元素。
  如果只是赋值了一个null，没有进行new创建，
  那么将会发生：空指针异常 NullPointerException

  原因：忘了new
  解决：补上new



- 越界异常
  数组的索引编号从0开始，一直到“数组的长度-1”为止。
  如果访问数组元素的时候，索引编号并不存在，那么将会发生
  数组索引越界异常
  ArrayIndexOutOfBoundsException

  原因：索引编号写错了。
  解决：修改成为存在的正确索引编号。



# 字符串

String类是一个final类，引用类型，代表**不可变字符序列**。

API中说：Java 程序中的所有字**符串字面值**（如 "abc" ）都作为此类的实例实现。即：程序当中所有的双引号字符串，都是String类的实例对象（没有new也是）。



**特性：**

1. String声明为一个final类，表示不可继承

2. String实现Serializable接口，表示支持序列化；

3. String实现Comparable接口，表示可比较大小；

4. String内部定义 final byte[] value 属性，用于储存字符串内容；
   
    > 注： 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。
    
5. 不可变性：即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。这是与其他引用类型对象区别之一。正是因为字符串不可改变，所以字符串是可以共享使用的。
   
    - 不可变指的是**字符串内容**不可变，而非指**变量名和内容之间的绑定**不可变
    - 不管什么方式创建的字符串都不可变



**创建字符串的方式：**

1. 构造函数创建：
   
    new构造函数
    
    - public String()：创建一个空白字符串，不含有任何内容。
    
    - public String(String original)：根据字符串字面量构造。
    
    - public String(char[] array)：根据字符数组的内容，来创建对应的字符串。
    
    - public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。
    
      ...
    
      ```java
      String str = new String("Hello"); 
      ```
    
      
    
2. 字面量创建：

    直接写上双引号，就是字符串对象

    ```java
    String str = "Hello"; 
    ```

**区别：** 

- 构造函数创建创建字符串，**会在堆中创成1个或2个字符串对象**：先查找**字符串常量池**中是否存在相同的字符串，若无，创建一个实例1（堆中），将实例1引用地址加入常量池中，若有，则不创建；最后，无论常量池有没有，都会再创建一个实例2（堆中），并返回堆中的实例2的引用地址。
- 字面量创建的字符串，**会在堆中创成0个或1个字符串对象**：先查找**字符串常量池**中是否存在相同的字符串，若无，创建一个实例（堆中），将引用地址加入常量池中，并返回常量池中的引用地址。若有，则不创建实例，直接返回已存在的常量池中的引用地址。
- 构造函数创建返回的**一定是堆中的引用地址**，字面量创建返回的**一定是字符串常量池中的引用地址**。
- 构造函数创建一定会在堆中创建新实例，字面量创建不一定会创建新实例。

![字符串常量池内存](.\images\字符串\字符串常量池内存.png)



**Java9改进字符串底层存储方式：**

Java9改进了字符串（包括String、StringBuffer、StringBuilder）的实现。

在Java9以前字符串采用char[]数组来保存字符，因此字符串的每个字符占2字节；

而Java9的字符串采用byte[]数组再加一个encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。

所以Java9的字符串**更加节省空间**，字符串的功能方法也没有受到影响。



**字符串与基本类型数据转换：**[基本类型和String转换](#6 基本类型和String转换)



## 1 字符串常量池

字符串常量池位于方法区（元空间），用于储存**字面量创建**的字符串。字符串常量池**不会储存相同内容的字符串**。

请结合[常量池](#4 常量池)章理解。



**快速记忆：** 常量池搞兼并，相同值只一个，值同则地址同，可以用==判等。



**常量池位置：** jdk1.6-方法区（永久代），jdk1.7堆空间，jdk1.8+方法区（元空间）



**常量池的好处：**

常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了**对象的共享**。

例如字符串常量池，在编译阶段就把所有的字符串放到一个常量池中。

- **节省内存空间：**常量池中所有相同的字符串值被**合并**，只占用一个空间。
- **节省运行时间：**比较字符串时，== 比 equals() 效率高。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。



## 2 实例方法

由于String的不可变性，String的所有方法都不会改变原字符串。

String实现了CharSequence接口，CharSequence是char值的可读序列。

CharSequence已知实现类：CharBuffer ，Segment ，String ，StringBuffer ，StringBuilder。



### length()

```java
public int length()
```

- <返回> 返回字符串长度
- <底层实现> byte[]数组的长度：value.length



### concat()

```java
public String concat(String str)
```

- <返回> 拼接，等价于+，创建一个新的 String 对象并返回



### charAt()

```java
public char charAt(int index)
```

- <返回> 返回指定索引处的 char 值



### indexOf()

```java
public int indexOf(String str/char char)
```

- <返回> 返回指定字符（串）在此字符串中第一次出现处的索引,未找到返回-1



```java
public int indexOf(String str/char char, int fromIndex)
```

- <返回> 返回指定字符（串）在此字符串中第一次出现处的索引,从指定的索引 fromIndex (包含)开始,未找到返回-1



### lastIndexOf()

```java
public int lastIndexOf(String str/int ch)
```

- <返回> 返回最后一次出现目标字符串 str 或目标字符 ch 的索引位置，未找到返回-1



```java
public int lastIndexOf(String str/int ch, int fromIndex)
```

- <返回> 索引0 - fromIndex之间寻找，返回最后一次出现目标字符串 str 或目标字符 ch 的索引位置，未找到返回-1
- <注> int ch是字符对应的Unicode值，传入char会自动转型



### contains()

```java
public boolean contains(CharSequence s)
```

- <返回> 判断字符串是否包含 s

- <底层实现> return indexOf(s.toString()) >= 0;



### substring()

```java
public String substring(int beginIndex)
```

- <返回> 剪切，从指定索引 beginIndex (包含)的字符开始，直到此字符串末尾，创建并返回剪切的字符串。



```java
public String substring(int beginIndex, int endIndex)
```

- <返回> 剪切，从指定索引 beginIndex (包含)的字符开始，直到索引 endIndex （不包含）结束，创建并返回剪切的字符串。
- <注> 左闭右开[)，beginIndex - 起始索引（包含）,endIndex - 结束索引（不包含）。



### toCharArray()

```java
public char[] toCharArray()
```

- <返回> 将此字符串转换为一个新的字符数组并返回。



### getBytes()

```java
public byte[] getBytes()
```

- <返回> 编码，将此字符串转换为一个新的字节数组并返回，使用默认字符集转换。



```java
public byte[] getBytes(String charsetName)
```

- <返回> 编码，将此字符串转换为一个新的字节数组并返回，使用特定字符集转换。



### intern()

```java
public native String intern()
```

- <返回> 判断该字符串实例引用是否在常量池中，若在，返回引用地址，若不在，将引用地址加入常量池，并返回。该方法一定不会创建新的实例。



### isEmpty()

```java
public boolean isEmpty()
```

- <返回> length()为0时返回true,其他返回false



### toLowerCase()

```java
public String toLowerCase()
```

- <返回> 转换成小写，创建并返回新的字符串。



### toUpperCase()

```java
public String toUpperCase()
```

- <返回> 转换成大写，创建并返回新的字符串。



### trim()

```java
public String trim()
```

- <返回> 去除首位空格,创建并返回新的字符串。
- <应用> 用户输入账号密码可用到



### compareTo()

```java
public int compareTo(String anotherString)
```

- <返回> 按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值。 由该String对象表示的字符序列按字典顺序与由参数字符串表示的字符序列进行比较。
- <应用> 用于字符串排序比较



### endsWith()

```java
public boolean endsWith(String suffix)
```

- <返回> 判断字符串是否以 suffix 结尾



### startsWith()

```java
public boolean startsWith(String prefix)
```

- <返回> 判断字符串是否以 prefix 开头



```java
public boolean startsWith(String prefix, int toffset)
```

- <返回> 判断字符串从 toffset （包含）索引开始，是否以 prefix开头



### replace()

```java
public String replace(CharSequence target, CharSequence replacement)
```

- <返回> 替换，匹配所有 target 字符串，替换成 replacement 字符串，创建并返回新的字符串。



```java
public String replace(char oldChar, char newChar)
```

- <返回> 



### replaceAll()

```java
public String replaceAll(String regex, String replacement)
```

- <返回> 替换，匹配所有 regex 字符串，替换成 replacement 字符串，创建并返回新的字符串。
- <注> regex 字符串表示正则表达式的字符串



### matches()

```java
public boolean matches(String regex)
```

- <返回> 匹配，匹配字符串是否符合正则表达式的规则
- <注> regex 字符串表示正则表达式的字符串



### split()

```java
public String[] split(String regex)
public String[] split(String regex, int limit)
```

- <参数> regex 分割标识符，limit 切割个数阈值
- <返回> 分割，从左往右切割，直到达到阈值为止，创建并返回的字符串数组。
- <注> regex 字符串表示正则表达式的字符串



## 3 StringBuilder和StringBuffer

String是不可变的字符序列，StringBuffer/StringBuilder 代表**可变的字符序列**。

StringBuffer是JDK1.0开始存在，StringBuilder是JDK1.5才新增的。



**StringBuffer、StringBuilder（简称2SB）与String的不同：**

1. 2SB都代表可变字符串序列，String代表不可变的字符序列
2. 2SB因为是可变，可对底层数组进行扩容，String只会开辟新的内存
3. 2SB总体而言，效率比String高



**StringBuffer、StringBuilder相同点：**

 1. 两个类都代表可变字符串对象
 2. 两个类的构造器和方法也基本相同（但不保证同步）。
 3. 两个类底层都是byte[]储存数据
 4. 两个类都会自动对底层数组进行扩容



 **StringBuilder、StringBuffer不同点：**

1. StringBuffer 是线程安全的（方法都添加了synchronized），效率更低
2. StringBuilder 是线程不安全的，效率更高（优先采用）



**实例方法：**实例方法部分与String相同，增加了可修改字符序列的一些方法。



## 4 判等

==

equals

equalsIgnoreCase

Objects.equals



# 日期与时间？



# 方法

方法用于描述类的功能，是语句的集合。

在Java中，没有函数的概念，只有方法的概念。方法不能独立存在，它只能属于类或者对象。



**命名规则：** 小驼峰（myMethod）



**作用：** 

1. 使程序变得更简短而清晰。
2. 有利于程序维护。
3. 可以提高程序开发的效率。
4. 提高了代码的重用性。



**定义格式：** 

```java
修饰符 返回值类型 方法名称(参数类型 参数名称, ...) {
  // 方法体
  return 返回值;
}
```

**说明：**

- 返回值类型：限制方法最终产生的数据结果的数据类型

  > 注：void代表没有返回值，不能返回任何数据，可以不写return，要写只能写return;

- 方法名称：方法的名字，规则和变量一样，小驼峰规则
- 参数类型：限制进入方法的数据类型
- 参数名称：进入方法的数据对应的变量名称（形参）
- 方法体：方法需要做的事情，若干行代码
- 返回值：方法执行后最终产生的数据结果，类型必须与前面的“返回值类型”保持一致



**注意事项：** 

1. 方法必须定义在一个类或接口中，不能定义在另一个方法当中，或其他地方
2. 方法return后面不能书写任何必被执行的语句
4. 返回值类型为void的方法，它没有返回结果，所以不能对它的执行结果赋值或访问



## 1 参数

方法的参数是方法内部的局部变量，但它们是最先声明的，只不过是由调用时**由外部传值\传址来赋值**。



**方法的参数分为两种：**

1. 形参：形参代表方法定义上的，用于接收实参的参数，供方法体使用，如void method(int a, int b)中的a、b
2. 实参：实参代表方法执行时，传递给形参的，且实际参与运算的参数，如method(1, 2)中的1、2



与传递变量一致，传递参数有两种类型：

- 基本类型：值传递（传值），形参的改变不影响实参
- 引用类型：引用地址传递（传址），形参的改变直接影响实参



**修饰符：**

1. 形参不可使用**访问修饰符**
2. 可以使用final修饰符，即为**常量参数**



### 1.1 可变形参

JDK 1.5 开始，Java支持传递**同类型**的可变形参，用来接受不可预期个数的实参。可变形参是**数组类型**。

可变形参可看做**数组形参的升级版**，调用传入实参时，可传入任意个数的同类型实参，也可传入数组。



**书写格式：**

```java
// 声明
method(Type... param)
    
// 调用传参
method(param1, param2, ...)
// 或
method(Type[] param)
```



**注意事项：** 

1. 一个方法中只能指定一个可变参数
2. 可变参数必须是**最后一个参数**
3. 因为与(Type[] name)是相同的形参列表，不构成**重载**条件
4. 可变参数会被转成**数组类型**接收，直接传数组也可接收



## 2 局部变量

**局部变量可分为：** 

1. 形参
2. 方法局部变量
3. 代码块局部变量



**存放位置：** 栈



**生命周期：** 方法调用至执行结束。只有在被调用的时候才分配内存空间，一旦调用结束，就释放内存空间



**注意事项：** 

1. 局部变量没有默认值，都必须显示赋值，否则不能访问
2. 访问修饰符不能用于局部变量



## 3 局部常量

final修饰的局部变量，其他机制基本与变量一致。



## 4 递归方法

递归方法 （recursive method）指：一个方法在内部调用自己。递归方法会实现一种隐式循环，重复某段代码。但这种循环必须有终止条件，否则将变成无穷递归。



## 5 main方法

在Java中，main方法是Java应用程序的**入口方法**，因为JAVA是在C++的基础上开发的语言，main也是c++的程序入口。也就是说，程序在运行的时候，第一个执行的方法就是main()方法，这个方法和其他的方法有很大的不同，比如方法的名字必须是main，方法必须是public static void 类型的，方法必须接收一个字符串数组的参数等等。



**固定格式：**

```java
public static void main(String[] args) {
  ...   
}
```



**要求：**

1. 方法的名字必须是：main
2. 修饰符和返回类型也是固定的：public static void
3. 参数只能一个，且是字符串数组类型的：String[] args



**解释：**

- 为什么是main：规定，JVM只能识别叫做main的函数作为程序运行的起点

- 为什么是public的：为了保证JVM在任何情况下都可以访问到main方法，就用public修饰
- 为什么是static的：静态可以让JVM调用main方法的时候更加方便，不需要通过对象调用
- 为什么没有返回值（void）：没有返回值是因为不需要，Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序
- 为什么参数是String[] args：也是规定



# 类和对象

 ## 1 类的概述

类（class）是对现实中实体事物的属性和行为的描述，是抽象的，概念上的定义，是一个模板



**类的命名规范：** 大驼峰（MyClass）



**注意事项：**

1. 一个源文件【必有且仅能有】一个与文件名相同的类
2. 一个源文件中仅能有一个 public 类，且 public 类名必须与源文件名一致（原因：为了在import公共类时提高效率）
3. 一个源文件可以有多个非 public 类，可以跟文件名不同，但为了为了便于管理，一般一个源文件放一个类
4. 同一个包（同级目录）下不能有重复名称的类



**面向对象具体实现流程：**

1. 创建类，设计类的变量和方法
2. 创建对象
3. 通过对象的属性和方法，来调用对象结构



### 1.1 对象

对象（instance）是实际存在的个体，有状态和行为，也称为实例。对象是解决问题的最终工具。



**对象的命名规范：** 小驼峰（myInstance）



**判断对象的值与址的相等性：**

1.  == ：参考 \src\运算符\双等号
2.  equals：参考 \src\常用类.Object类\equals
3.  Objects.equals：参考 \src\常用类.Object类\Objects工具类\Equals



#### 1.1.1 创建对象

创建对象也叫类的实例化，或实例化类。

**格式：**

```java
类型 对象名 = new 类(参数列表);
```



#### 1.1.2 匿名对象

创建对象没有显式地赋给一个变量名，即为匿名对象。

如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。

> 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。



**示例：**

```java
new Person("张三", 30).tell();
```





### 1.2 this关键字

**使用格式：** 

```java
类名.this // “类名”省略代表当前类下的this
```

**作用：**

- 充当当前实例对象，用于访问实例的成员变量\方法，如：this.field/this.method()
    **注：**当与成员变量或形参不重名的情况下，this可以省略

- 充当本类的构造函数，用法：this()\this(...)
    **注：**

  1. 只允许在构造器的第一行代码执行
  2. 一个构造器中只允许执行一个其他构造方法
  3. 只允许调用其他构造器
  4. 构造器不允许循环调用

  

**注意：** 静态方法、静态代码块中不能使用this，因为实例对象还没生成



## 2 类的成员

类的成员包括**变量**（属性、域、字段、field）、**方法**（行为、函数、method）、**代码块**（初始化块、block）。

面向对象的设计重点是类的设计，而设计类重点则是<u>设计类的成员</u>。



**类的成员分类：**

- 变量
- 方法
- 构造器
- 类
- 接口
- 代码块

> 以上每种都可分为静态（类成员）与非静态（实例成员）。



### 2.1 成员变量

与局部变量不同，成员变量有[默认值](#1 默认值)，不同类型的成员变量有不同的默认值（与数组一致）。



**就近原则：**当方法的<u>局部变量</u>和类的<u>成员变量</u>重名的时候，根据“就近原则”，优先使用局部变量。



**成员变量赋值的先后顺序：**

1. 默认初始化
2. 显式赋值
3. 构造器赋值
4. 通过“对象.方法”或“对象.属性”赋值

> 注：123只执行一次，4可以反复执行）



**实例变量、静态变量、局部变量的对比:**

1. 定义的位置不一样【重点】
    成员变量：定义在类中
    局部变量：定义在方法（包括构造器）中、方法（包括构造器）形参、代码块

2. 作用范围不一样【重点】
   成员变量：整个类全都可以通用。
   局部变量：只有方法当中才可以使用，出了方法就不能再用

3. 默认值不一样【重点】
   成员变量：如果没有赋值，会有默认值，规则和数组一样
   局部变量：没有默认值，如果要想使用，必须手动进行赋值

4. 内存的位置不一样
   实例变量：位于堆内存，跟着实例对象走，new的时候创建
   静态变量：位于方法区（静态域），跟着类走
   局部变量：位于栈内存，跟着方法走，方法进栈，局部变量创建

5. 生命周期不一样
   实例变量：随着实例对象创建而诞生，随着实例对象被垃圾回收而消失。所以实例变量生命周期就是实例对象的开始和销毁。
   静态变量：随着类声明而诞生，随着类被垃圾回收而消失。所以静态变量生命周期就是类的开始和销毁。
   局部变量：随着方法进栈而诞生，随着方法出栈而消失。所以局部变量生命周期就是方法的开始和销毁。

6. 权限修饰符的不同
   成员变量不可用权限修饰符



**成员常量：**可算做不可变的成员变量，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 2.2 成员方法



### 2.3 构造器

构造器（Constructor/构造方法/构造函数）是专门用来创建对象的特殊方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。



**作用：**

1. 创建对象

2. 初始化对象信息



**格式：**

```java
权限修饰符 构造器名(参数列表) {
   ...
}
```

**构造器与成员方法的区别：**

       1. 构造方法的名称必须和所在的类名称完全一模一样
              2. 构造方法不写返回值类型，连void都不写，也不能 return
              3. 构造方法用于创建对象，并进行初始化值；普通成员方法是用于完成特定功能的。
                     4. 构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数；普通成员方法是由创建好的对象调用，可以调用多次

> 注：构造器可以看作特殊的成员方法



**注意事项：**

1. 如果没有编写任何构造方法，那么编译器将会默认创建一个空的构造方法（没有参数、方法体什么事情都不做，即：public Student() {}）
2. 默认提供的构造器的权限修饰符与类相同
3. 一旦显式定义一个构造方法，那么编译器将不再默认创建
4. 构造方法允许重载。（重载：方法名称相同，参数列表不同）
5. 一个类至少有一个构造器，创建一个对象的时候，至少要调用一个构造器
6. 构造方法允许被各种权限修饰符修饰



### 2.4 代码块

代码块也叫初始化块。

**分类：**
       1. 非静态代码块（实例）
              2. 静态代码块



**执行顺序：**

1. 静态代码块先于非静态代码块执行

2. 同一类的多个代码块按**声明顺序**执行（一般不会声明多个代码块）



#### 2.4.1 非静态代码块

**声明格式：**

```java
{
    ...
}
```

**用途：** 给实例属性初始化

**执行时间：** 每次<u>创建实例</u>时候都会执行一次

**创建实例时，实例结构的执行顺序：**

1. 默认初始化
2. 显式初始化/非静态代码块执行
   注： 显式初始化和（实例）代码块执行是同一级别的，谁在前谁先
3. 构造器初始化
4. 通过"对象.属性"或“对象.方法”去赋值



#### 2.4.2 静态代码块

**声明格式：**

```java
static {
    ...
}
```

**用途：** 给静态变量初始化

**执行时间：** 每次<u>加载类</u>的时候都会执行一次

**加载类时，静态结构的执行顺序：**

1. 默认初始化
2. 显式初始化 / 静态代码块执行
   注： 显式初始化和静态代码块执行是同一级别的，谁在前谁先
3. main方法执行



**注意：**

1. 静态代码块类只能调用静态结构
2. 继承的时候先需要加载父类，所以父类的静态代码块也会先执行



### 2.5 成员类、成员接口

成员类是内部类的一种，具体可参考[7.1 成员内部类](#7.1 成员内部类)。

成员接口与成员类类似。



### 2.6 静态成员

static 修饰符可用于修饰类的成员（变量和方法，以及内部类），被修饰的统称为为静态成员。



**什么时候使用静态的：**

1. 不会随着对象改变而变的成员
2. 操作静态属性的方法
3. 工具类的方法，习惯用静态的（比较省事，不用创建对象，如Math、Arrays）
4. 常量（final）习惯用静态的



**访问格式：** 类.静态变量\方法\类

**静态成员内存位置：** 位于静态域（方法区）

**特点：**

1. 节省内存空间
2. 共享性



**注意事项:**

   1. 静态成员属于所在的类，非属于实例对象
   2. 静态成员被同一类的实例对象可以共享
   3. 静态成员可直接通过类访问，不需要创建实例就可使用
   4. 静态先于实例对象存在，所以静态方法中不可用实例变量、实例方法、this、super关键字，但可以访问其他静态成员
   5. 实例方法可以访问静态成员，且可以省略类名
   6. 实例成员和静态成员的名称不允许重复
   7. 静态方法可以被继承，可以被重载，可以被隐藏（隐藏其实相当于重新声明），但不能被重写



## 3 JavaBean

JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定。



**约定：**
1. 所有的成员变量私有化（private）
2. 私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范
3. 必须具有一个公共的(public)无参构造函数
4. 这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）



## 4 类的继承

继承（extends）就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。



**书写格式：**

```java
修饰符 class 子类名 extends 父类名 {
    
}
```



**作用：**共性抽取



**特性:**

1. 子类拥有父类<u>所有的属性和方法</u>

2. 子类可以在父类的基础上进行修改和扩展，方式是重写、重载、隐藏

3. 父类的private属性和方法也是可以被继承的，只是子类拥有但无法访问（封装性）；不能直接访问，但可以通过非private的父类方法进行间接访问。

4. Java 的继承是【单继承】，但是可以【多重继承】。单继承是一个子类只能继承一个父类（只能有一个父亲），多重继承就是子类也可以当父类（传代），例如 A 类 -> B 类 -> C 类

   > 注：A 类 -> B 类 -> C 类，B为C的直接父类，A为C的间接父类

5. 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）

6. 继承是多态的前提

7. 所有类继承的最顶级对象是java.lang.Object，Object是祖先类，Object在 java.lang 包中，所以不需要 import

8. 当访问实例对象的成员变量或方法时，则优先寻找本类当中是否存在，若有则用，无则向上（父类）寻找，不会向下（子类）寻找

9. 若需访问父类与子类的重名成员变量时，可通过super访问



### 4.1 super关键字

我们可以通过super关键字来实现对父类成员的访问，相当于父类的this，指向父类实例。



**使用格式：** 

```java
类名.super // "类名"省略代表当前类的super
```



**作用：**

1. super可以指向父类的this，现对父类成员的访问，用来访问父类的成员变量和方法

2. 可以充当父类的构造函数



**使用注意事项：**

1. 只能在子类构造函数中执行
2. 跟this一样，只能作为第一个语句执行，因此一个代码块中，super和this只能调用一个一个构造函数只能执行一次super

3. 子类所有的构造器第一行都会默认隐式地执行父类的无参构造器（super()），手动显式地执行super()或this()，则替代默认的super()
4. 子类的构造器中，第一行不是执行this()，就是执行super()，而至少有一个子类构造器执行super()，而至多有n-1个this()
5. 每个子类的构造器都会直接或间接调用父类构造器，所以当执行某类的构造器的时候，一定会把它所有父类的构造器都执行一遍，直到Object的构造器，这便是继承的过程。注意：但只创建一个对象，即new的那个类的对象



## 5 重写、重载、隐藏

**重载与重写对比：**

- 重写（Override）：方法的名称、形参列表<u>要求一样</u>；访问权限、返回值类型<u>要求兼容</u>；其他无关；用于子类覆盖父类方法。

  > 记忆：替代

- 重载（Overload）：方法的名称<u>要求一样</u>；形参列表<u>要求不一样</u>；其他无关；用于对不同的传参进行不同的处理情景，可对本类或父类的方法重载。

  > 记忆：新增一种实现方式

![重写和重载](.\images\类和对象\重写和重载.png)



### 7.1 方法重写

方法重写（覆盖/覆写/Override/Overwrite）是子类对父类的允许访问的【实例方法】的实现过程进行重新编写，返回值和形参都不能改变。

<u>即外壳不变，核心重写！</u>



**书写格式：**

```java
@Override
修饰符 类型 方法名 (参数列表){
    ...
}
```

> 注解@Override 写在方法前面，可用来检测是不是有效的正确覆盖重写（可写可不写）



**作用：** 重写的作用在于子类可以根据业务需要，重定义方法的行为，也就是说子类能够根据需要实现父类的方法。



**要求：**

1. 方法的名称、参数列表（类型\个数\顺序）必须相同

2. 返回值类型：如果父类返回值为引用类型，则子类重写方法的返回值必须【小于等于】父类的；如果父类返回值为基本类型或void，则子类必须返回跟父类一模一样的

3. 访问权限：子类重写方法必须【大于等于】父类方法

   > 访问权限：public > protected > (default) > private

4. throws类型：子类重写方法必须【小于等于】父类方法，如果父类没有声明throws，则子类也不能声明



**注意事项：**

1. 重写只能是子类对父类（祖先类）的重写，不能是对本类或子类方法的重写
2. 声明为 final 的方法不能被重写。
3. private方法无法被重载、重写，因为子类无法访问父类的private成员
4. 父类静态方法可以被继承，可以被重载，可以被隐藏，但不能被重写（隐藏只是形式上的重写，并不满足多态的特征，所以严格说不是重写）
5. 重写只能适用于【实例方法】，不能用于静态方法，对于静态方法,只能隐藏







### 7.2 方法重载

方法重载（Overload）是指在同一个类中定义多个同名的方法，要求每个方法具有不同的形参的类型\个数\顺序，保证每个重载的方法都必须有一个独一无二的参数列表。



**作用：** 对不同的传参进行不同的处理

**方法重载与下列因素相关：**

1. 参数个数不同
2. 参数类型不同
3. 参数的多类型顺序不同



**方法重载与下列因素无关：**

1. 与形参的名称无关
2. 与方法的返回值类型无关
3. 与方法的修饰符无关



**注意：**

1. 重载可以对本类方法的重载，也可以是子类对父类的方法进行重载，但不能是本类对子类的重载
2. private方法无法被重载、重写，因为子类无法访问父类的private成员



### 7.3 隐藏

隐藏是指子类的成员变量（包括实例变量和静态变量）和静态方法与父类的命名一样，访问子类的这些变量和方法的时候就只会访问子类的，而父类的被隐藏。若子类没有，再去访问父类的。



## 6 抽象类和抽象方法

**关键字：** abstract



###　6.１ 抽象类

如果一个类没必要实例化，仅提供一些结构供子类去实例化，其中没有包含具体的信息来描绘一个具体的对象，这样的类就是抽象类。

类的继承当中，结构会越来越具体，而上层的父类往往需要更通用，且没必要实例化，因此便有了抽象类。

抽象类就是用来继承的，继承过程中去重写抽象方法，



**声明格式：**

```java
权限修饰符 abstract class {
    ...
}
```



**注意：**

1. 抽象类不能直接实例化，必须被继承，才能够使用
2. 抽象类虽然不能实例化，但仍需要<u>构造器</u>，供子类调用
3. 没有任何抽象方法的抽象类有特殊作用（？？？）
4. 抽象类在继承方面没有限制——抽象类可以被抽象类、普通类继承，抽象类也可以继承抽象类、普通类
5. 抽象类也可以多态
4. final类不可被继承，而抽象类必须要被继承，所以抽象类不能被final修饰



### 6.2 抽象方法

抽象方法就是为了子类重写而存在，该方法的具体实现由它的子类确定，所以不需要方法体。



**声明格式：**

```java
[权限修饰符] abstract 返回类型 方法名 (参数列表); -- 权限修饰符缺省，默认为public
```



**注意：**

1. 抽象方法只能声明在抽象类中，且只有声明，没有方法体
2. 有抽象方法的类必定是抽象类，抽象类中不一定包含抽象方法
3. 子类必须覆盖重写抽象父类当中所有的抽象方法，除非该子类也是抽象类，否则报错
6. 静态方法（static）、私有方法（private）、final方法不可被重写，这些都与抽象冲突，不可用于修饰抽象方法



## 7 内部类

将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。

### 7.1 成员内部类

内部类作为一个外部类的成员存在。



**用途：** 当一个事物（人）需要一个完整的结构（大脑）去描述，而这个结构只需要对这个事物提供服务，那么这个结构最好使用内部类。

**分类：**

- 非静态成员内部类
- 静态成员内部类



**注意：**内部类的 this 指向内部类实例，若要在内部类中使用外部类的 this，则用：【外部类.this】。



#### 7.1.1 非静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
```



#### 7.1.2 静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称.内部类名称();
```





### 7.2 局部内部类

定义在方法、构造器、代码块内部的类。



**注意事项：**

1. 局部内部类只能在该方法内访问，方法外无法访问
2. 局部内部类不允许使用权限修饰符（public，default...），因为没有意义，它只能在方法内访问
3. 局部内部类只能通过所在的方法去使用



**局部内部类访问该方法内的局部变量的情况：** 

1. 该变量必须是【final】的，原因：因为局部变量是跟方法走的，而局部内部类是new出来的，是在堆中的，两者声明周期不同，所以局部变量必须不变
2. 从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略



#### 7.2.1 匿名内部类

匿名内部类也是局部内部类的一种，也只能定义是方法、构造器、代码块内部。

他常用于**继承和实现**中，当一个<u>子类</u>或<u>实现类</u>只使用一次时，可以使用匿名类快捷方便地创建实例。



**格式：**

```java
// 继承
父类名称 对象名 = new 父类名称(){
  // 匿名内部类（子类）
  // 这里书写子类的内容
};

// 实现
接口 对象名 = new 接口(){
  // 匿名内部类（实现类）
  // 这里书写实现类的内容
};
```



## 8 final类与final成员

### 8.1 final类

final类不可被继承（太监类），成为最终类，被继承会报错。



**注意事项：**

1. final类没有子类，但有父类（任何类都有父类，除了Object）
2. 既然没有继承，也就没有所谓的子类对父类的成员覆盖、重载
3. final类一样可以对它的父类成员进行重写、重载
4. abstract 和 final 互相矛盾（abstract 类一定要被继承，final 类不可被继承），不能同时使用



### 8.2 final成员

#### 8.2.1 成员常量

成员常量即加final的变量。

成员常量，不可用默认值，所以必须赋值一次（初始化），且不可再变。

赋值的位置有：显式赋值，构造器赋值，代码块赋值。（方法中赋值不可行，太晚了）。



**命名格式：**全大写，底杠分割，如：MY_NAME



**静态常量：**用 static final 修饰的成员变量。可当作**全局常量**。



**注意：**子类可以隐藏（覆盖）父类的成员常量



#### 8.2.2 final方法

**分类：**

- 静态final方法
- 非静态final方法



**注意：** 

1. abstract 和 final 互相矛盾（abstract 方法一定要被重写，final 方法不可被重写），不能同时使用
2. final方法不可被重写、隐藏，但可以被重载。



## 9 对象的序列化和反序列化

 在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。但是，我们创建出来的这些对象都存在于JVM中的堆（heap）内存中， 只有JVM处于运行状态的时候，这些对象才可能存在。**一旦JVM停止，这些对象也就随之消失**；但是在真实的应用场景中，我们需要将这些对象**持久化**下来，并且在需要的时候 将对象重新读取出来，Java的序列化可以帮助我们实现该功能。

 对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将对象的状态信息保存为**字节数组**，并且可以在有需要的时候将这个字节数组通过**反序列化**的方式转换成对象，对象的序列化可以很容易的在JVM中的**活动对象和字节数组（流）**之间进行转换。

**在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中。**



**定义一个可序列化的类的步骤：**

1. 继承Serializable接口
2. 声明全局常量：serialVersionUID

> 注意：如果内部属性有其他对象，这些对象也必须是可序列化的，否则该类无法可序列化



**serialVersionUID：**

简单来说，JAVA序列化的机制是通过判断类的serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID于本地相应实体类 的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。

serialVersionUID有两种显示的生成方式：

1. 是默认的1L，比如：private static final long serialVersionUID = 1L;
2. 是根据包名，类名，继承关系，非私有的方法和属性，以及参数，返回值等诸多因子计算得出的，极度复杂生成的一个64位的哈希字段。基本上计算出来的这个值是唯一的。 比如：private static final long serialVersionUID = xxxxL;

> 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明。



**注意**

1. static 和 transient 修饰的成员变量无法序列化



# 枚举类

当一个类的对象数量是已知的、确定的、有限的，这个类称为枚举类。

![枚举类归纳](.\images\枚举类\枚举类归纳.png)



**命名规则：**大驼峰（MyEnum）



**建议：**

1. 当我们需要一组有限个数的常量时，建议使用**枚举类**
2. 当枚举类只有一个对象时，可以用**单例模式**实现



**两种方式：**

1. 自定义枚举类（JDK 5.0之前）
2. Enum枚举类（JDK 5.0之后）



## 1 自定义枚举类

使用普通类来模拟枚举类，这是JDK 5.0之前的做法，现在已弃用，使用Enum枚举类代替。



**步骤：**

1. 声明一个类，在类中声明该枚举类的属性（private final）；
2. 私有化构造器（private），并给属性赋值；
3. 在类中创建枚举实例，并提供公共静态常数的访问方式（public static final）



**具体示例：**Season类



## 2 Enum枚举类

枚举（enum）类型是Java 5新增的特性，它是一种新的类型，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。

尽管 enum 看起来像是一种新的数据类型，事实上，enum是一种受限制的类，并且具有自己的方法。创建enum时，编译器会为你生成一个相关的类，这个类继承自 java.lang.Enum。



**特性：**

  1. Enum枚举类和Class、Interface的地位一样
  2. Enum枚举类继承自java.lang.Enum，而不是继承Object类，除此之外**不能继承其他类和其他enum类**
  3. Enum 枚举类固定使用 final 修饰，不能显式修饰，**不可以被继承**
  4. Enum枚举类跟类一样，**可以实现一个或多个接口**
  5. Enum枚举类**不能抽象**，因为无法被继承
  6. Enum枚举类的toString方法继承至Enum，返回枚举实例的常量名，直接打印枚举实例，输出的是枚举实例的常量名
  7. Enum 枚举类的**构造函数是私有的**
 8. Enum枚举类**可以有静态方法**



**声明格式：**

```java
public enum Payment {
  // 枚举实例
  // 属性
  // 构造器
  // 方法
    ...
}
```



**枚举实例：**

- 定义格式：

  ```java
  枚举实例名1(...), 枚举实例名2(...), 枚举实例名3(...), ... 无参枚举实例名4;
  ```

- 注意：
  1. 必须在Enum枚举类中**第一行**声明，否则报错
  2. 固定是public static final修饰，不能显式修饰

**属性：**与普通类一致。

**构造器：**

- 声明格式：

  ```java
  构造器名(...){
      ...
  }
  ```

- 注意：固定是私有的（private），否则报错，可以省略



**Enum枚举类实现接口**：Enum枚举类跟类一样，也可以实现接口。



**Enum枚举类实例方法与静态方法：**略



## 3 内部枚举类？



# 接口

接口就是规范，定义的是一组规则。接口的本质是契约，标准，规范，就像我们的法律一样，制定好后大家都要遵守。

在Java语言中，接口（Interface）是一种引用类型，是方法的集合，是类的公共规范。

如果说类的内部封装了成员变量、构造方法和成员方法， 那么接口的内部**主要就是封装了方法**，其中最重要的就是的：**抽象方法**。

编写接口的方式和类很相似，但是它们属于不同的概念，接口与类是并列的两个结构。

接口是**隐式抽象**的。



**特性：**

- 多重实现：类只能单继承，但允许同时可以实现多个接口
- 多重继承：接口允许同时继承多个父接口



> **实现接口和继承类的通俗理解：**实现接口可以理解为一个人学一个技能，比如烹饪，那么他必须遵守了烹饪的相关规则，才能说学会了烹饪。当然一个人可以学很多技能：写作、开车、修理家具等等。继承类可以理解为一个人选择成为某个职业中的一员，比如成为厨师，那么他也必须遵守厨师的相关规则，但是职业只能一个（Java规定，其他语言不一定），不能既是厨师，又是运动员。



**接口与类的不同之处：**

1. 类描述对象的<u>属性和方法</u>，接口则包含类要实现的<u>方法</u>
2. 接口不能实例化（没有构造函数），同过<u>实现</u>发挥效用；类通过实例化发挥效用
3. 接口里的所有的方法必须是<u>抽象方法</u>
4. 接口支持<u>多继承，多实现</u>，而类只支持<u>单继承</u>。
5. 接口不能包含成员变量、构造方法、代码块



**接口与类的相同之处：**

1. 与类一样，接口文件保存在.java 结尾的文件中，文件名使用接口名
2. 与类一样，接口的字节码文件保存在 .class 结尾的文件中
3. 与类一样，接口也具有多态性
4. 与类一样，接口也可以包含常量、抽象方法、默认方法、静态方法、私有方法



**不同版本Java，接口包含的内容：**

- Java 7：
  - 常量
  - 抽象方法
- Java 8：
  - 默认方法
  - 静态方法
- Java 9：
  - 私有方法



**标识接口：**标识接口是<u>没有任何方法和属性</u>的接口。标识接口不对实现它的类有任何语义上的要求，它仅仅表明实现它的类属于一个特定的类型。如Serializable接口。



## 1 定义接口

**书写格式：**

```java
权限修饰符 [abstract] interface 接口名称 {
    // 接口内容
}
// 接口是隐式抽象的，所以[abstract]可省略
```



**接口的命名规范**： 大驼峰（MyInterface）





**接口和抽象类相似之处:**

1. 接口和抽象类都不能被实例化。
2. 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。



1. 接口里只能包含抽象方法、静态方法和默认方法，不能为普通方法提供实现，而抽象类可以。
2. 接口里只能定义常量，不能定义普通成员变量，抽象类则可以。
3. 接口里不包含构造器;抽象类可以包含构造器，但抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
4. 接口里不能包含初始化块;但抽象类则完全可以包含初始化块。
5. 一个类最多只能有一个直接父类（包括抽象类）;但一个类可以实现多个接口，通过实现多个接口可以弥补Java单继承的不足。





## 2 实现接口

接口不能直接使用，必须有一个“实现类”来实现该接口。接口支持多重实现，即：一个“实现类”可以同时实现多个接口。

> 如果实现类没有重写接口中<u>所有的抽象方法</u>，该实现类必须定义成<u>抽象类</u>



**关键字：** implements



**书写格式：**

```java
// 实现，支持多重实现
权限修饰符 class 实现类名称 implements 接口名称1[, 接口名称2, 接口名称3, ...] {
     ...
}
```



**多重实现时，接口成员重复情况：**

1. 静态方法不会被继承，只通过接口自身调用，所以**不用管重复**
2. 私有成员不会被出现在实现类当中，所以**不用管重复**
3. 常量（静态变量）重复，只能通过接口调用；或者实现类中重声明隐藏接口常量，才可以类和实例调用
3. 抽象方法重复，实现类**只需重写一次**
4. 默认方法重复，实现类**必须重写**





**类同时继承，并实现接口情况：** 继承优先于实现，父类优先于接口

```java
// 顺序：先继承，后实现
权限修饰符 class ClassA extends ClassB implements Interface1[, 接口名称2, 接口名称3, ...] {
    ...
}
```



**当继承与实现成员重复时：**

1. 抽象方法同名同参数：子类只需重写一次
2. 普通（默认）成员方法同名同参数：父类优先于接口
3. 静态方法同名同参数：父类优先于接口
4. 静态变量同名：引用不明确，子类不会继承

> 当出现命名冲突时，子类就必须重写或重声明



## 3 接口继承

一个接口允许同时继承多个父接口，即多重继承。



**关键字：** extends



**书写格式：**

```java
// 继承，支持多重继承
权限修饰符 Interface extends Interface1[, Interface2, Interface3...] {
    ...
}
```



**多重继承时，父接口成员重复情况：**

1. 父接口抽象方法重复：子接口不必重写，但实现类中必须重写
2. 父接口默认方法重复：子接口必须重写，实现类不必重写
3. 父接口静态方法重复：静态方法只通过接口自身调用，所以不用管重复（接口的静态方法不会被继承）
4. 父接口常量（静态变量）重复，只能通过父接口调用；或者子接口中重声明隐藏接口常量，才可以在子接口、类、实例调用



## 4 接口成员

接口成员包含：抽象方法、常量、默认方法、私有方法、静态方法。而其中抽象方法是最重要的。



### 4.1 抽象方法

接口最重要的内容就是其中的：抽象方法。



**格式：**

```java
[public abstract] 返回值类型 方法名称(参数列表);// [public abstract]可省略
```



**注意：**

1. 接口中的方法是隐式抽象的，声明时可以省略 abstract 关键字

2. 接口中的抽象方法必须是公有的，权限修饰符必须是public的，所以可以省略 public 关键字

   

### 4.2 常量

接口常量必须是**静态**的，必须使用 public static final 三个关键字进行修饰，所以也可省略。



**格式：**

```java
[public static final] 数据类型 常量名称 = 数据值;
```



**命名格式：**全大写，底杠分割，如：MY_NAME



**注意：**

1. 常量，必须进行赋值

2. 常量会被实现类继承，变成类的静态变量（注意：静态方法不会被继承，这是区别）
3. 常量可以被隐藏
4. 常量可以接口直接调用，也可以实现类调用，也可以实例调用（除了多重实现时重复，只能接口调用）（重点）

>  基本与类的成员常量类似，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 4.3 私有方法

私有方法用于接口内部的代码封装。

> 从Java 9开始支持



**格式：**

```java
private [static] 返回值类型 方法名称(参数列表) {
  ...
}
```



**注意：**私有方法只在接口内部可见，与外部无关，不会被实现类继承。



### 4.4 静态方法

> 从Java 8开始支持



**格式：**

```java
[权限修饰符] static 返回值类型 方法名称(参数列表) {
    ...
}
// 权限修饰符默认为public，可以省略
```



**注意：**

1. 接口的静态方法不会被继承（这点与类不同），只存在接口自身中，当然也没有重载、重写、隐藏（重点）
2. 权限修饰符默认为public，可以省略（这点与类不同）
3. 静态方法只能通过接口自身调用，格式：接口.静态方法()



### 4.5 默认方法

**用途：** 接口当中的默认方法，常用来解决接口升级的问题;若是升级时添加的是抽象方法，老代码因未重写报错，而默认方法不会



> 从Java 8开始支持



**格式：**

```java
[权限修饰符] default 返回值类型 方法名称(参数列表) {
    ...
}
// 权限修饰符默认为public，可以省略
```



**注意：**

1. 默认方法会被实现类的继承作为实例方法
2. 可继承，可重写，可重载



## 5 函数式接口

函数式接口(Functional Interface)是对一类特殊类型的接口的称呼。 这类接口保证有且仅有一个抽象方法。

函数式接口可以使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个 接口是一个函数式接口。

函数式接口可以被隐式转换为 **lambda 表达式**。

其他方面与普通接口无异。



注意，如果接口声明了一个**可被java.lang.Object中的某方法重写**的抽象方法，那么它不会计入接口的抽象方法数量中，因为所有的实现类都继承了Object类，该接口中的抽象方法一开始就已被重写。

比如，虽然Comparator虽然有两个抽象方法：

```java
int compare(T o1, T o2);
boolean equals(Object obj);
```

但其中 equals 被 Object 的 equals 重写，只剩下 compare 是唯一必须被重写的抽象方法，被所以Comparator可以作为函数式接口。



### 1 内置函数式接口

Java 8新增了 java.util.function 包，该包定义了丰富的函数式接口。



**四大核心的内置函数式接口：**

|   函数式接口   | 参数类型 | 返回类型 | 抽象方法          |                             用途                             |
| :------------: | :------: | :------: | ----------------- | :----------------------------------------------------------: |
|  Consumer<T>   |    T     |   void   | void accept(T t)  |             **消费型：**对类型为T的对象应用操作              |
|  Supplier<T>   |    无    |    T     | T get()           |                **供给型：**返回类型为T的对象                 |
| Function<T, R> |    T     |    R     | R apply(T t)      | **函数型：**对类型为T的对象应用操作，并返回结果。结果是R类型的对象。 |
|  Predicate<T>  |    T     | boolean  | boolean test(T t) | **断定型：**确定类型为T的对象是否满足某约束，并返回boolean 值。 |



**其他内置函数式接口：**

|              函数式接口              | 参数类型 | 返回类型 |         抽象方法          |                       用途                       |
| :----------------------------------: | :------: | :------: | :-----------------------: | :----------------------------------------------: |
|         BiFunction<T, U, R>          |   T, U   |    R     |     R apply(T t, U u)     | 对类型为 T, U 参数应用操作，返回 R 类型的结果。  |
|   UnaryOperator<T>(Function子接口)   |    T     |    T     |       T apply(T t)        | 对类型为T的对象进行一元运算，并返回T类型的结果。 |
| BinaryOperator<T>(BiFunction 子接口) |   T, T   |    T     |    T apply(T t1, T t2)    | 对类型为T的对象进行二元运算，并返回T类型的结果。 |
|           BiConsumer<T, U>           |   T, U   |   void   |   void accept(T t, U u)   |           对类型为T, U 参数应用操作。            |
|           BiPredicate<T,U>           |   T,U    | boolean  |   boolean test(T t,U u)   |                    双参断定型                    |
|           ToIntFunction<T>           |    T     |   int    |    int applyAsInt(T t)    |                  计算in值的函数                  |
|          ToLongFunction<T>           |    T     |   long   |   long applyAsLong(T t)   |                 计算long值的函数                 |
|         ToDoubleFunction<T>          |    T     |  double  | double applyAsDouble(T t) |                计算double值的函数                |
|            IntFunction<R>            |   int    |    R     |    R apply(int value)     |               参数为int 类型的函数               |
|           LongFunction<R>            |   long   |    R     |    R apply(long value)    |               参数为long类型的函数               |
|          DoubleFunction<R>           |  double  |    R     |   R apply(double value)   |             参数为double 类型的函数              |



### 2 Lambda表达式

Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。

**本质：**作为函数式接口的实例。它表达的是对象而不是函数。



**格式：**

```java
// 函数式接口实现并实例化普通写法：
接口 itfc = new 接口(){ 
    @Override
    public void 抽象方法(参数) {
        方法体
    }
};

// 改成Lambda表达式：
接口 itfc = (参数) -> { 
    方法体
};

// 若参数只有一个，可以省略圆括号；若方法体只有一句，可以省略大括号；若方法体只有一句，且是返回语句，可以省略return关键字：
接口 itfc = 参数 -> 方法体/返回数据;
```



**lambda表达式的重要特征:**

- 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。
- 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
- 可选的大括号：如果主体只包含一个语句，就不需要使用大括号。
- 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。



### 3 方法引用

方法引用是Lambda表达式升级版，更加省略。

当使用Lambda表达式时，方法体只有一句调用方法的语句，调用方法必须和接口中的抽象方法具有相同的形参，这时可简写成更简洁的Lambda表达式：方法引用格式。

其本质还是Lambda表达式。



**要求：**当使用Lambda表达式时，方法体只有一句调用方法的语句，调用方法必须和接口中的抽象方法具有相同的形参



**格式：** 

```java
接口 itfc = 类\对象 :: 引用方法;
```



**方法引用有四种用法：**

1. 对象::实例方法
2. 类::静态方法
3. 类::实例方法（最特殊）
4. 类::new（构造器引用）



#### 3.1 构造器引用

当使用Lambda表达式时，lambda体是一个调用构造器、实例化的表达式，而是返回一个实例，可简写成构造器引用的格式。



**要求：**引用的构造器方法必须和接口中的抽象方法具有相同的形参，而抽象方法返回这个类的实例。



**格式：** 

```java
接口 itfc = 类 :: new;
```



# 多态

多态是继封装、继承之后，面向对象的第三大特性。多态（Polymorphism）是指同一操作，作用于不同的对象，可以有不同的解释，产生不同的执行结果。现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。比如跑的行为，小猫、小狗和大象，跑起来是不一样的。

Java中，多态就是同一个接口，使用不同的实例而执行不同操作。

多态的使用体主要现在<u>虚拟方法</u>的调用。



**含义：**

父类的引用指向子类对象，或子类对象赋给父类引用。多态本身就是<u>向上转型</u>过的过程，是小范围到大范围的转变。把子类单做父类使用，只能使用继承自父类的成员，不能使用子类特有的成员。例如：把某只猫当作动物而不是猫来看待，它具备动物的属性，但不能使用猫特有的属性。



**多态存在的三个必要条件：**

1. 继承或者实现【二选一】

2. 方法的重写【不重写，无意义】

3. 向上转型



**多态的转型：**多态的转型分为<u>向上转型</u>和<u>向下转型</u>两种



**多态的优点：**

1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性



**多态体现的格式：**

```java
父类名称 对象名 = new 子类名称();
// 或者：
接口名称 对象名 = new 实现类名称();
```



**口诀：** 编译看左边，运行看右边



**使用多态成员看两个方面：**

1. 有没有：看类\接口是否有这个成员（继承来的也算）

2. 从哪找：从哪个类开始往上查找

> 先看有没有，没有则报错，有则再看从哪找



**多态成员变量和多态成员方法调用规则不一样：**

1. 使用多态成员方法：有没有看左边，从哪找看右边

2. 使用多态成员变量：有没有、从哪找都看左边（因为属性不存在多态性）

> 通过get方法间接访问成员变量，跟成员方法的规则一致



**虚拟方法 （虚方法\virtual method）：**在多态的情况下，将父类的方法称为虚拟方法，父类根据赋给他不同的子类对象，动态地调用子类的该方法，这些方法在编译期是无法确定的，只有运行时才能确定。



**注意事项：**

1. 多态对象堆内存中仍然有子类特有的成员，但是因为类型是父类的，所以无法调用，需要向下转型才能调
2. 多态是动态绑定（运行时），重载是静态绑定（编译时）
3. 多态性体现在成员方法上，不体现在属性上



## 1 向上转型

父类引用指向子类对象，把子类当做父类使用，只能使用父类有的成员，不能使用子类特有的成员。例如：把猫当作动物来看待，可以使用动物有的属性，但不能使用猫特有的属性。

类似于自动类型转换：`double num = 100;// int -> double`，范围小 -> 范围大，自动类型转换



**适用场景：** 当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。



**格式：**

```java
Fu fu = new Zi();
```



**向上转型注意事项：**

1. 向上转型是小范围到大范围的转变
2. 向上转型一定是安全的，许可的
3. 优点是：左边代码可以统一
4. 缺点是：不能调用子类特有的内容。解决方案是：向下转型





## 2 向下转型

向下转型是向上转型的还原动作。

向上转型之后，把对象还原为原有类型，向下转型成功后又可以使用子类特有的内容。

例如：把猫上转型为动物来看待后，还原为猫，又可以使用猫的特有属性了。

适用场景： 当要使用子类特有功能时。



**格式：**

```java
Zi zi = (Zi)fu;
```



**类似于：**

```JAVA
int num = (int) 100.0;// 可以
int num = (int) 100.5;// 精度损失
```



**向下转型注意事项：**

1. 向下转型是大范围到小范围的转变

2. 向上转型是安全的，但向下转型是有风险的
3. 【前提条件】：必须先多态（向上转型），才能向下转型，而且只能转为原有类型，若转为其他类型，则编译通过，运行报错，
   报ClassCastException（猫只能还原为猫，不能还原为狗）。所以向下转型前先用 instanceof 判断。



# 泛型

泛型（Generic），即“参数化类型”。顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用/调用时传入具体的类型（类型实参）。

泛型提供了编译时<u>类型安全检测机制</u>，该机制允许程序员在编译时检测到非法的类型。 泛型的引入加强了参数类型的安全性，减少了类型的转换。

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。



**泛型结构：**

- 泛型类
- 泛型接口
- 泛型方法



**特性：**

1. 泛型只在编译阶段有效



## 1 泛型参数

所有泛型都有一个类型参数声明部分，写在尖括号中，如。泛型参数也可叫叫做：类型参数、泛型变量、类型变量。 此处T可以随便写为任意标识，常见的T、E、K、V等大写字母。多个泛型参数用逗号隔开，写做：<T,E,K,V>。



**特性：**

1. null 符合所有泛型参数
2. 若泛型参数未传入，默认是Object类型
3. 泛型参数必须是**引用类型**，不能是基本类型



## 2 泛型结构

### 2.1 泛型方法

泛型方法中，类型传入的时间点： 在方法<u>被调用的时候确定类型</u>，通过实参的类型来来确定。



**声明格式：**

```java
修饰符 <T> returnType methodName (param){
  ...
}
```



**类型传入的时间点：**在方法<u>被调用的时候确定类型</u>，通过实参类型、接收变量类型来确定。

**类型传入格式：**

```java
methodName(param);// 与普通的方法调用无分别
```



**注意事项：**

1. 方法上泛型的差异不构成重载



### 2.2 泛型类

泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。



**声明格式：**

```java
class GenericClass<T>{
  ...
}
```



**类型传入的时间点：** 在类被<u>实例化、继承</u>的时候确定类型

> 注意：泛型类（父）被继承时，可选择完全确定父类类型（参考SubClass1），或者完全保留父类类型，让子类实例化的时候确定类型（参考SubClass2），或者部分保留、部分确定父类类型（参考SubClass3）， 或者擦除父类类型（参考SubClass4）

**类型传入格式：**

```java
// 1.无变量接收
new ClassName<Type>();

// 2.有变量接收
ClassName<Type> Var = new ClassName<Type>();
// 注：JDK7.0 以后，增加类型推断，后面的泛型参数可省略，即：ClassName<Type> Var = new ClassName<>();
// 但后面的尖括号<>不可省略，省略了<>等于不使用泛型。
```



**注意事项：**

1. 类中的非静态成员可以访问并使用类定义的泛型参数，静态成员不可访问
2. 类成员定义的泛型参数优先级大于类定义的泛型参数，若重复，定义的泛型会覆盖类的泛型参数
3. 不同泛型参数的引用不能互相赋值，参考例test3
4. 静态方法不能使用类的泛型，但可以有自己的泛型，因为静态方法加载时，泛型有可能还未传入（实例化）
5. 泛型类是无法继承自 Throwable 类（包括异常类（Exception\Error）），即异常类等不能使用泛型，
    参考：https://blog.csdn.net/ziwang_/article/details/56288597
6. 泛型只是变量，泛型不能充当类直接拿来创建（new），new后面只能是具体的类，但是可以作为类型强转的变量，参考例test4



### 2.3 泛型接口

**声明格式：**

```java
修饰符 interface interfaceName<T> {
  ...
}
```



**类型传入的时间点：** 在接口被<u>实现</u>的时候确定类型

**类型传入格式：**

```java
修饰符 class ClassName implements interfaceName<Type> {
  ...
}
```



## 3 类型擦除机制

Java的泛型在编译阶段实现，<u>在运行期被删除</u>。编译器生成的字节码在运行期间并不包含泛型的类型信息。



**在编译后所有的泛型类型都会做相应的转化，转化如下：**

```java
List<String>、List<T> 擦除后的类型为 List。
List<String>[]、List<T>[] 擦除后的类型为 List[]。
List<? extends E>、List<? super E> 擦除后的类型为 List<E>。
List<T extends Serialzable & Cloneable> 擦除后类型为 List<Serializable>。
```



**jvm如此操作的原因：**

1. 如果把类型信息保留到运行时，需要做大量的重构工作
2. 兼容原生的老版本类型



**注意:**

1. 泛型的class对象时一样的，类型擦除不会改变class属性:

   ```java
   List<String> t1 = new ArrayList<String>();
   List<String> t2 = new ArrayList<Integer>();
   System.out.println(t1.getclass() == t2.getclass());
   ```

   

2. 泛型数组初始化时不能声明泛型类型

   ```java
   List<String>[] list = new List<String>[];
   ```

   在这里可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操作后，相当于List[Object] list = new List()[];编译器拒绝如此声明,所以提前报错，不允许到jvm那一边，java实现的是伪泛型。

   

3. instanceof 不能带泛型参数:

   ```java
   List<String> list = new ArrayList<String>();
   System.out.println(list instanceof List<String>);
   ```

   jvm编译后会丢失信息，所以编译器不允许这么做，因为要是这么做，在运行时候会出问题。实际上list是一个实例，但是丢失类型后无法判断。



# 集合框架

集合框架是一个用来代表和操纵集合的统一架构。Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。

集合和数组都属于Java容器，对多个数据进行储存操作的结构（注：这里的储存是内存层面的储存，非持久化储存）。

![集合框架关系图](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\集合框架\集合框架关系图.gif)

**所有的集合框架都包含如下内容：**

- 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象
- 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。
- 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。



**集合框架结构（不全）：**

```
├── 集合框架
    ├── Collection(I)
        ├── List(I)
            ├──ArrayList（C）   
            ├──LinkedList（C）    
            └──Vector（C）       
        ├── Set(I)
            ├──HashSet（C）     
                └──LinkedHashSet（C）   
            └──TreeSet（C）   
        └── Queue(I)
    └── Map(I)
        ├── HashMap（C）
            ├──LinkedHashMap（C）   
        ├── treeMap（C）    
        └── Hashtable（C）
            └── Properties（C）
```

> 通俗理解：
>
> Java集合框架世界里有两大家族，一个叫**Collection（集）**，另一个是叫**Map（图）**。Collection 家族主张**单列集合**主义，Map家族主张**双列集合**主义。Collection 接口和 Map 接口分别是这2大家族中的大族长（顶层接口）。两大家族的大族长之下，便是一些干部：子接口、抽象类，他们不直接干活，而是叫他们之下的实现类（普通类）、子类（普通类）去干活。



**说明：**

- Collection：接口；单列集合，存储一个一个对象
  - List：接口；储存有序的、可重复的数据；容量不固定，随着容量的增加而动态扩容（阈值基本不会达到），习惯称之为“动态数组”
  - Set：接口；储存无序的、不可重复的数据；习惯称之为“集合”
  - Queue：接口；储存有序的、可重复的数据；
- Map：接口；双列集合，存储键/值对（key-value）映射；允许一对一、多对一，不允许一对多
  - ArrayList：类；数组队列，Java集合框架中被使用最多的，线程不安全，效率高
  - LinkedList：类；双向链表
  - HashSet：类；HashSet 基于 HashMap 来实现的；



**集合和数组的对比：**

1. 数组只能放**同一类型**的数据，集合可以储存不同类型（可以使用泛型约束）
2. 数组可以存放**基本类型**和**引用类型**数据，集合只能存放**引用类型**数据
3. 数组**长度不可变**，集合**长度可变**
4. 数组提供操作数据的手段非常有限，对于删除、增加、插入等操作非常不便，同时效率不高； 集合提供丰富的操作方法，十分便利
5. 数组储存数据的特点：有序，可重复，对于无序，不可重复的数据无法满足，集合可以
6. 获取数组中的元素个数，数组没有提供有效的属性或方法使用



## 1 Collection

Collection 是最基本的单列集合接口，存储一个一个对象，单列集合框架中最顶级的接口。其子接口和实现类都必须满足它设定的规则。



**特性：**

1. 继承了 Iterator 接口
2. 由于Set是无序的，所以Collection不提供**索引相关的特性**，所以也没有类似 get 和 set 方法用于取值设值。
2. Collection 的实现类的对象（不管是有序的List还是无序的Set），在往集合对象里添加元素 obj 时，要求 obj 所在类**必须重写equals方法**，因为 Collection 的许多方法（如：contains、remove、equals...）都会调用到元素对象的equals方法。



**接口方法**：略。



### 1.1 List

储存**有序的、可重复**的数据；容量不固定，随着容量的增加而动态扩容（阈值基本不会达到），习惯称之为“动态数组”。List下面有三个实现类：ArrayList、linkedList、Vector。



**实现类：**

- ArrayList：主要实现类，使用最多；线程不安全，查询效率高；底层使用数组 Object[] elementData 储存数据
- LinkedList：底层使用双向链表储存；对于频繁的插入、删除操作，使用此类效率比 ArrayList 高，但查询效率不如ArrayList
- ~~Vector：出现比较早（1.0，比List还早），基本被ArrayList替代，**不推荐使用**；线程安全，效率低；底层使用 Object[] elementData 储存数据。~~



**ArrayList和LinkedList对比区别：**[博客园](https://i.cnblogs.com/links?cateId=1980880)



**接口方法**：略。



**ArrayList的源码分析：**

```
1.jdk 7情况下
    ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData
    list.add(123);//elementData[0] = new Integer(123);
    ...
    list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。
    默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。
    结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)

2.jdk 8中ArrayList的变化：
    ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组
    list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]
    ...
    后续的添加和扩容操作与jdk 7 无异。
3. 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。
```



**LinkedList的源码分析：**

```java
LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null
    list.add(123);//将123封装到Node中，创建了Node对象。

其中，Node定义为：体现了LinkedList的双向链表的说法
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```



**Vector的源码分析：**

```java
jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。
```



### 1.2 Set

储存无序的、不可重复的数据；习惯称之为“集合”。

Set里没有额外定义的方法，全部是继承自Collection的方法。

list是一个有序的容器，保持了每个元素的插入顺序。即输出顺序就是输入顺序，而Set方法是无序容器，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。



**实现类：**

- HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值，但只能储存一个
  - LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet
- TreeSet：可以按照添加对象的指定属性，进行排序



**特性：**

1. 无序性：不等于随机性；存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的**哈希值**决定的。
2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一个。



**添加元素要求：**

1. HashSet、LinkedHashSet中添加的数据，其所在的类一定要重写hashCode()和equals()，否则添加时都默认是未存在相同的，造成重复的数据
2. 重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码（哈希值）

> 重写两个方法的小技巧： 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。



**添加元素的过程(以HashSet为例)：**

我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值， 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断 数组此位置上是否已经有元素：

- 如果此位置上没有其他元素，则元素a添加成功。 --->情况1
- 如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：
  - 如果hash值不相同，则元素a添加成功。--->情况2
  - 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功。--->情况3

对于添加成功的情况2和情况3而言：元素a与已经存在指定索引位置上数据以链表的方式存储。

jdk 7 :元素a放到数组中，指向原来的元素。 jdk 8 :原来的元素在数组中，指向元素a

总结：七上八下



## 2 Map

Map 是最基本的双列集合接口，存储一个一个键/值对（key-value）映射。

允许一对一、多对一，但不允许一对多。



**理解Map结构：**

- Map中的key：无序的、不可重复的，使用Set存储所有的key，key所在的类要重写equals()和hashCode() （以HashMap为例）
- Map中的value：无序的、可重复的，使用Collection存储所有的value，所以value所在的类要重写equals()
- 一个键值对：key-value构成了一个Entry对象
- Map中的entry：无序的、不可重复的，使用Set存储所有的entry



![Map结构](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\集合框架\Map结构.jpg)



**实例方法：**略。



**实现类：**

- HashMap（C）：作为Map的主要实现类；线程不安全，效率高；允许存储null的key和value；底层实现：数组+链表 （jdk8之前），数组+链表+红黑树 （jdk 8+） 
  - LinkedHashMap（C）：保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。
- treeMap（C）：保证按照特定规则对添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序；底层使用红黑树
- Hashtable（C）：作为古老的实现类；线程安全的，效率低；不能存储null的key和value
  - Properties（C）：常用来处理配置文件。key和value都必须是String类型



**HashMap的底层实现原理：**

```
HashMap map = new HashMap():
在实例化以后，底层创建了长度是16的一维数组Entry[] table。
...可能已经执行过多次put...
map.put(key1,value1):
首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据
的哈希值：
        如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
        如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
                如果equals()返回false:此时key1-value1添加成功。----情况3
                如果equals()返回true:使用value1替换value2。

补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。

在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。

jdk8 相较于jdk7在底层实现方面的不同：
    1. new HashMap():底层没有创建一个长度为16的数组
    2. jdk8底层的数组是：Node[],而非Entry[]
    3. 首次调用put()方法时，底层创建长度为16的数组
    4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。
      4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
      4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。

字段说明：
    DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
    DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
    threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
    TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
    MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
```



**LinkedHashMap的底层实现原理（了解）：**

```
 static class Entry<K,V> extends HashMap.Node<K,V> {
     Entry<K,V> before, after;//能够记录添加的元素的先后顺序
     Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
     }
 }
```



## 3 Iterator

Iterator接口（迭代器）不是一个集合，它是一种用于访问集合的迭代器模式，Iterator 是 Java 迭代器最简单的实现。Iterator就是为容器而生。

Iterator可用于迭代 ArrayList 和 HashSet 等集合。

ListIterator 是 Iterator 的子接口，它扩展了 Iterator 接口。



![迭代器执行原理](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\集合框架\迭代器执行原理.jpg)



**实例方法：**略。



## 4 Collections

Collections是操作Collection、Map的工具类，包含各种有关集合操作的静态方法，专门操作集合实现类里面的元素。

这些方法有：常规操作（查找，最大，最小等）、排序、线程安全（同步）操作、不可变集合等。

不能实例化(把构造函数私有化)。



**静态方法：**略



# 异常

在java语言中，将程序执行中发生不正常的情况称为“异常”。**语法错误和逻辑错误**不是异常。



**Throwable类：**是 Java 语言中所有错误或异常的超类（广义上的异常）。

**Throwable有两个子类：**

1. Error：错误，java虚拟机无法解决的严重错误，无法捕获和预处理，只能改代码，它们在Java程序处理的范畴之外。例如，JVM 内存溢出
2. Exception：异常，编程错误或偶然性的外在因素导致的一般性问题，可以用针对性的代码处理（一般指狭义上的异常）



**Exception异常分为两类：**

1. 编译时异常：也叫**受检异常**（checked），如IOException、ClassNotFoundException、CloneNotSupportedException等。编译时异常必须处理后才能执行程序。
2. 运行时异常：也叫**非受检异常**（unchecked），RuntimeException及其子类异常。运行时异常不处理也可执行程序。

>注： Error也属于不可检测（unchecked），在运行时才抛出

![异常分类](.\images\异常\异常分类.png)



**异常对象的生成有两种方式：**

1. 虚拟机检测到异常，如果当前程序没有对异常进行处理，则会在后台自动创建一个异常对象抛出（自动抛出）
2. 手动创建一个异常对象抛出。如果只创建不抛出，不会对程序运行有影响



**抓抛模型：**java的异常处理是「抓抛模型」，「抓」是「捕获继而处理」的意思，「抛」是「抛出异常」的意思。

**处理异常方式：**要么抓，要么抛，只能选一种。

- 抓：try-catch-finally
- 抛：throws

> 若前面出现异常，但后续操作还必须执行（比如IO流的关闭），这时候就需要try-catch-finally处理，不可再抛到外部，否则内部执行就中断，导致必须执行的代码未执行。



## 1 处理异常

### 1.1 try-catch-finally

try-catch-finally语句用来捕获并处理异常（编译时+运行时）。



**注意：**

1. catch只捕获对应的异常类，一旦捕获，将不执行其他catch
2. catch参数是捕捉对应的异常类，多个catch时，按从小到大的顺序捕捉（异常子类在前，父类在后），不然报错
3. finally兜底，放在最后，无论如何最后都会执行，统一处理try-catch中的错误
4. try中只要检测到异常，代码将中止，进入catch或finally代码块
5. catch代码块中若也发生异常，会进入同级的finally中
6. 运行时异常一般不必用try-catch-finally处理，因为太多了，编译时必须处理，将它延迟到运行时出现
7. 数据库连接、输入输出流、网络编程socket等资源，jvm不会自动回收，我们需要看手动释放，释放代码需要写在finally中



**try-catch-finally中的return：**

1. try、catch、finally的代码块执行不会被 return 截止，会先执行各自return前的代码，最后再按顺序执行return
2. try、catch、finally只会执行一次return，最后执行的那个return会覆盖前面的return
3. finally的return总是大于try、catch
3. 若try-catch-finally都有return，return执行顺序是：try => catch => finally



### 1.2 throws

针对方法内部的异常处理，将方法内部的异常抛出，由调用处接受，一层层向上抛出，直到虚拟机



**作用：**方法内部不处理异常，将异常抛出外部，统一在**方法调用处**处理异常。



**格式：**

```java
method() throws ExceptionType1, ExceptionType2...{
    方法体
}
```



**注意：**

1. throws的类型与顺序无关
2. 方法内部出现异常将终止后续代码执行
3. throws没有真正处理异常，而是向上“甩锅”，最终处理还是需要try-catch-finally



## 2 手动抛出异常

手动抛出异常对象。异常对象是指 Throwable 或其子类的对象。

抛出非自定义异常，一般选择 Exception 或 RuntimeException。



**格式：**

```java
 throw 异常对象;
```



**如何自定义异常类？**

1. 创建一个类，继承Exception 或 RuntimeException
2. 提供静态常量：serialVersionUID
3. 提供重载构造器



## 3 自定义异常类

**自定义异常类流程：**

1. 创建一个类，继承Exception 或 RuntimeException
2. 提供静态常量：serialVersionUID
3. 提供重载构造器



# 比较与排序

在 Java 中经常会涉及到对象的排序问题，那么就涉及到对象之间的比较问题 。



**Java 实现对象排序的方式有两种：**

1. 自然排序： java.lang.Comparable 接口
2. 定制排序： java.util.Comparator 接口



## 1 自然排序

自然排序即：使需要排序的类实现Comparable接口，重写 compareTo 方法。

Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。

> 注： 实现 Comparable 接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort 进行自动排序。



**步骤：**

1. 需要排序的类要实现 Comparable 接口，并重写 compareTo 方法
2. 在 compareTo 方法里，比较该类的两个实例的属性，按特定的规则比较一个或若干个属性，返回1（正数）、0、-1（负数）三个值，**正数代表往后排，0保持不变，负数往前排**
3. 需要排序的类的实例调用compareTo 方法得出排序结果



**已实现Comparable的类（默认都是从小到大排列的）：**

1. 包装类

   > 此外，包装类还提供静态的比较方法，如：Integer.compare(x, y)

2. String

3. Date、Time

3. ...



## 2 定制排序

定制排序即：创建一个**比较器类**，使这个比较器类实现 Comparator 接口，重写 compare 方法。将需要比较的类的实例当作参数传入 compare 方法进行比较。

当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用Comparator接口来创建一个**比较器类**。

> 注： 可以把比较器类传递给 sort 方法（如 Collections.sort 或 Arrays.sort）从而允许在排序顺序上实现精确控制 。



**步骤：**

1. 创建一个比较器类，实现 Comparator 接口，重写 compare 方法
2. 在 compare 方法里，比较该类的两个实例的属性，按特定的规则比较一个或若干个属性，返回1（正数）、0、-1（负数）三个值，**正数代表往后排，0保持不变，负数往前排**
3. 需要排序的类的实例调当作参数传入比较器类的 compare 方法得出排序结果



# 注解

注解（Annotation）又称标注，是 JDK5.0 引入的一种注释机制。 

Java 语言中的包，类，构造器，方法，成员变量，参数，局部变量的声明都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 

当然它也支持自定义 Java 标注。

Annotation 其实就是代码里的特殊标记, 这些标记可以在编译 , 类加载 , 运行时被读取 , 并执行相应 的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下 , 在源文件中嵌入一些 补充信息 。 代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。

Annotation 可以像修饰符一样被使用 , 可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在 Annotation 的 “name=value” 对中。

未来的开发模式都是基于注解的， JPA 是基于注解的，Spring2.5 以上都是基于注解的，Hibernate3.x 以后也是基于注解的， 现在的Struts2 有一部分也是基于注解的了，注解是一种趋势 ，一定程度上可以说： 框架 = 注解 + 反射 + 设计模式。

![Annotation 架构](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\注解\Annotation 架构.PNG)



**按作用位置分，注解可分为类：**

- 作用在代码的注解
- 作用在其他注解的注解(元注解)



**调用格式：** 

```java
// 通常写法
@AnnotationName(key1 = value1, key2 = value2, ...);

// 无参数，或者所有参数都有默认值时，可以省略()，省略时使用的是默认值传入
@AnnotationName;

// 一个参数， 且key 名称为“value”，可以省略key = 
@AnnotationName(value);

```



## 1 自定义注解

自定义注解自动继承 java.lang.annotation.Annotation 接口。

注解的与类相似，也有内部成员，叫作**注解成员**，也叫**配置参数、参数**。

与类不同的是，注解成员比较单一，只有一种形式，其定义与调用的写法类似于类的成员方法。

没有成员的注解称为**标记**，包含成员的注解称为**元数据 Annotation**。



**关键字：** @interface



**声明格式：**

```java
public @interface AnnotationName{
    // 无默认值成员
	type valueName();
    
    // 带默认值成员
    type valueName() default value;
}
```

**注意：**

1. 成员类型（type）只能是：基本数据类型、String 类型、Class类型、enum类型、Annotation类型及以上所有类型的**数组**
2. 如果只有一个成员，建议使用名称为“value”
3. 自定义注解必须配上注解的信息处理流程才有意义？？？



## 2 内置的注解

Java 定义了一套内置的注解，有的在 java.lang 中，有的在 java.lang.annotation 中。



**作用在代码的内置注解:**

- @Override - 标记重写方法；**无参**
- @Deprecated - 标记过时方法
- @SuppressWarnings - 抑制编译器警告
- @SafeVarargs - （ Java 7+）忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告；**无参**。
- @FunctionalInterface - （Java 8+）标识一个匿名函数或函数式接口；**无参**



**作用在其他注解的内置注解(元注解):**

- @Retention - 标识一个注解的生命周期
- @Documented - 标记这些注解是否包含在用户文档（javadoc）中；**无参**
- @Target - 标记注解的修饰范围
- @Inherited - 标记注解的继承性；**无参**
- @Repeatable - （Java 8+）标识某注解可以在同一个声明上使用多次



### 2.1 @Override

标记重写方法。可写可不写，建议写，可校验是否重写。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 

无参。



### 2.2 @Deprecated 

标记过时方法，意味将来很可能被删除，使用时会被划线，但仍可正常使用。如果使用该方法，会报编译警告。



### 2.3 @SuppressWarnings

指示编译器去忽略注解中声明的警告。



### 2.4 @SafeVarargs 

在JDK 7中引入，主要目的是处理可变长参数中的泛型，此注解告诉编译器：在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。

在声明具有模糊类型（比如：泛型）的可变参数的构造函数或方法时，Java编译器会报unchecked警告。鉴于这些情况，如果程序员断定声明的构造函数和方法的主体不会对其varargs参数执行潜在的不安全的操作，可使用@SafeVarargs进行标记，这样的话，Java编译器就不会报unchecked警告。



### 2.5 @FunctionalInterface 

Java 8 开始支持，标识一个匿名函数或函数式接口。

无参。



### 2.6 @Retention

标识一个注解的生命周期，标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。



**参数：**

- RetentionPolicy枚举：
  - RetentionPolicy.SOURCE - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃
  - RetentionPolicy.CLASS - 注解被保留到class文件，但jvm加载class文件时候被遗弃（默认）
  - RetentionPolicy.RUNTIME - 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；只有通过RUNTIME才能使用**反射**获取

> 这3个生命周期分别对应于：Java源文件(.java文件) ---> .class文件 ---> 内存中的字节码。生命周期长度 SOURCE < CLASS < RUNTIME



**怎么选择参数：**

一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解，比如@Deprecated使用RUNTIME注解；
如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；
如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，使用SOURCE 注解。



### 2.7 @Documented

标记这些注解是否包含在用户文档（javadoc）中。

无参。



### 2.8 @Target 

标记注解的修饰范围。



**参数：**

- 枚举数组，ElementType[]，ElementType是一个枚举类



### 2.9 @Inherited

标记注解的继承性。当一个注解 a 使用@Inherited修饰后，某一个类使用了 a 注解，则这个类的子类也会继承这个 a 注解。

无参。



### 2.10 @Repeatable 

Java 8 开始支持，标识某注解可以在同一个声明上使用多次。



**参数：**



# 反射

Reflection（反射）是被视为<u>动态语言</u>的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

加载完类之后，在堆内存的方法区中就产生了一个<u>Class类型的对象</u>（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。

通俗地讲，有一个运行时的未知的对象，我们可以通过反射，来知道这个对象对应的类，类的属性、方法等成员，以及调用这些方法、或设置这些属性等操作。

> 注意：Java不是动态语言，但Java可以称之为“准动态语言”，即Java有一定的动态性，就是因为我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！



**Java反射机制提供的功能：**

- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时获取泛型信息
- 在运行时调用任意一个对象的成员变量和方法
- 在运行时处理注解
- 生成动态代理



## 1 java.lang.Class

java.lang.Class类是Java反射的源头。

在Object类中定义了以下的方法：`public final Class getClass()`，此方法将被所有子类继承。此方法返回值的类型是一个Class类型的对象。

程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为<u>**类的加载**</u>。加载到内存中的类，我们就称为**运行时类**，此运行时类，就作为Class的一个实例。

换句话说，<u>Class的实例就对应着一个运行时类。</u>

加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类（Class对象）。

对于每个类而言，JRE 都为其保留一个不变的 Class 对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。



**注意：**

- Class本身也是一个类
- Class 对象只能由系统建立对象
- 一个加载的类（运行时类）在 JVM 中只会有一个Class实例
- 一个Class对象实例（运行时类）对应的是一个加载到JVM中的一个.class文件
- 每个类的实例都会记得自己是由哪个 Class 实例所生成
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象



**Class对象的常用方法：**

- static Class forName(String name) 返回指定类名 name 的 Class 对象
- Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例
- getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称
- Class getSuperClass() 返回当前Class对象的父类的Class对象
- Class [] getInterfaces() 获取当前Class对象的接口
- ClassLoader getClassLoader() 返回该类的类加载器
- Class getSuperclass() 返回表示此Class所表示的实体的超类的Class
- Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组
- Field[] getDeclaredFields() 返回Field对象的一个数组
- Method getMethod(String name,Class … paramTypes)返回一个Method对象，此对象的形参类型为paramType



**哪些类型可以有Class对象？**

- class： 外部类（包含Class自身），成员(成员内部类，静态内部类)，局部内部类，匿名内部类
- interface：接口
- []：数组
- enum：枚举
- annotation：注解@interface
- primitive type：基本数据类型
- void



## 2 类的加载过程

![ ](file:///E:/Desktop/myJavaStudy/JavaBase/src/%E5%8F%8D%E5%B0%84/%E6%88%AA%E5%9B%BE/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B1.png)

1. 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。 
2. 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。
   - 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题
   - 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 
3. 初始化：
   - 执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 
   - 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 
   - 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步



**什么时候会发生类初始化？**

1. 类的主动引用（一定会发生类的初始化）

    

   - 当虚拟机启动，先初始化main方法所在的类 
   - new一个类的对象
   - 调用类的静态成员（除了final常量）和静态方法
   - 使用java.lang.reflect包的方法对类进行反射调用
   - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类

2. 类的被动引用（不会发生类的初始化）

    

   - 当访问一个静态域时，只有真正声明这个域的类才会被初始化
   - 当通过子类引用父类的静态变量，不会导致子类初始化
   - 通过数组定义类引用，不会触发此类的初始化
   - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

   

**类加载器的作用**

![ ](file:///E:/Desktop/myJavaStudy/JavaBase/src/%E5%8F%8D%E5%B0%84/%E6%88%AA%E5%9B%BE/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B2.png)

- 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。
- 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。



**类加载器ClassLoader**

![ ](file:///E:/Desktop/myJavaStudy/JavaBase/src/%E5%8F%8D%E5%B0%84/%E6%88%AA%E5%9B%BE/ClassLoader.png)

1. 获取一个系统类加载器

   ```java
   ClassLoader classloader = ClassLoader.getSystemClassLoader();
   System.out.println(classloader);
   ```

2. 获取系统类加载器的父类加载器，即扩展类加载器

   ```java
   classloader = classloader.getParent();
   System.out.println(classloader);
   ```

3. 获取扩展类加载器的父类加载器，即引导类加载器

   ```java
   classloader = classloader.getParent();
   System.out.println(classloader);
   ```

4. 测试当前类由哪个类加载器进行加载

   ```java
   classloader = Class.forName("exer2.ClassloaderDemo").getClassLoader();
   System.out.println(classloader);
   ```



# 多线程

## 1 概念

### 1.1 进程与线程的概念

​	参考：[链接](https://baijiahao.baidu.com/s?id=1666454968534966585&wfr=spider&for=pc)

​	**进程（Process）**是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，**进程是线程的容器**。 程序是指令、数据及其组织形式的描述，进程是程序的实体。

​	进程是程序的一次动态执行过程，它需要经历从代码加载，代码执行到执行完毕的一个完整的过程，这个过程也是进程本身从产生，发展到最终消亡的过程。 多进程操作系统能同时达运行多个进程（程序），由于 CPU 具备分时机制，所以每个进程都能循环获得自己的 CPU 时间片。由于 CPU 执行速度非常快， 使得所有程序好像是在同时运行一样。

​	线程是比进程更小的执行单位，线程是进程的基础之上进行进一步的划分。所谓多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的单元称为**线程**，这些线程可以同时存在，同时运行，一个进程可能包含多个同时执行的线程。**多线程是实现并发机制的一种有效手段**。进程和线程一样，都是实现并发的一个基本单位。

​	程序是一段静态的代码，进程是正在运行的程序，线程是程序内部执行的一条路径。

​	每个线程拥有独立的**栈、程序计数器**；一个进程中的多个线程共享进程的**堆、方法区**

![进程概念](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\多线程\进程概念.png)

![线程概念](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\多线程\线程概念.png)

### 1.2 并发与并行

**并发（concurrency）：**

并发指==两个或多个事件在同一个时间段内**间隔**发生==（一个人吃两个馒头，一口咬这个，一口咬那个） 。 指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果， 但在微观上并不是同时执行的，只是把时间分成若干端，使多个进程快速交替的执行。比如： 一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。 由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作， 这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，==同一时刻，其实只有一个线程在执行==。



**并行（parallel）：**

指==两个或多个事件在同一时刻发生（同时发生）==（两个人同时吃两个馒头，互不影响）。 它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。 并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。 而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。



![并发与并行](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\多线程\并发与并行.png)

![并行和并发](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\多线程\并行和并发.jpeg)





### 1.3 线程调度

**线程调度分两种：**

- 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 

- 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)

  > Java使用的为抢占式调度。



### 1.4 主线程

当一个Java程序启动以后，有一个线程就会立马被创建并执行，这就是通常所说的**主线程（Main Thread）**。



### 1.4 守护线程和用户线程

**java中线程分为两种类型：**

- 用户线程

- 守护线程：也称“服务线程”，在没有用户线程可服务时会自动离开

  > 通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。

 

**用户线程和守护线程的区别：**

1. 主线程结束后用户线程还会继续运行，JVM存活；主线程结束后守护线程和JVM的状态由下面第2条确定。

2. 如果没有用户线程，都是守护线程，那么JVM结束（随之而来的是所有的一切烟消云散，包括所有的守护线程）。
3. 守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。

 

**示例：**

垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。



**生命周期：**

守护进程（Daemon）是运行在后台的一 种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。 那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。



### 1.5 何时需要多线程

1. 程序需要同时执行两个或多个任务

2. 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等

3. 需要一些后台运行的程序时

   

## 2 创建线程

**创建线程方式：**

- 继承式
  - 继承Thread类式
- 实现式
  - 实现Runnable接口式
  - 实现Callable接口式
- 线程池式？？？



**继承式和实现式对比：**

1. 实现方式没有单继承性的限制：实际场景中，如果类继承了Thread类就不能继承其他类，而实现无此限制
2. 实现方式更方便处理多个线程共享数据的场景
2. 不管是继承式和实现式，都需要使用到 Thread 类

> 结论：更推荐使用实现式创建线程



**实现Runnable接口式与实现Callable接口式对比：**

1. Callable 可以在任务结束的时候提供一个**返回值**，Runnable 无法提供这个功能
2. Callable 的 call 方法分可以抛出异常，而 Runnable 的 run 方法不能抛出异常
3. Callable 支持泛型

> 结论：实现Callable接口式功能更强大



### 2.1 继承Thread类式

创建一个线程类MyThread，并继承于Thread类，线程类MyThread实例化几次，就创建几个线程。



**步骤：**

1. 创建一个线程类MyThread，并继承于Thread类（如果线程类只用一次，可使用匿名类写法）
2. 重写 Thread 类的 run 方法
3. 创建 MyThread 实例：myThread 
4. 调用实例 myThread.start 方法，启动线程



### 2.2 实现Runnable接口式

**步骤：**

1. 创建一个线程类MyThread，并实现Runnable接口（如果线程类只用一次，可使用匿名类写法）

2. 重写 Runnable 接口的 run 方法

   > run 方法是提供给Thread内部调用，通过start方法可调到。不可直接调用 run 方法（不调start），这样不会创建线程

3. 创建 MyThread 实例：myThread 

4. 实例化 Thread 类，将实例 myThread 作为构造参数传入，得到 Thread 类实例对象：thread

5. 调用 thread.start 方法，启动线程



### 2.3 实现Callable接口式

**步骤：**

1. 创建一个线程类MyThread，并实现Callable接口（如果线程类只用一次，可使用匿名类写法）

2. 重写 Callable 接口的 call 方法

   > call 方法是提供给FutureTask、Thread内部调用，通过start方法可调到。不可直接调用 call 方法（不调start），这样不会创建线程

3. 创建 MyThread 的实例：myThread

4. 实例化 FutureTask 类，将实例 myThread 作为构造参数传入，得到 FutureTask 类实例对象：futureTask 

5. 实例化 Thread 类，将实例 futureTask 作为构造参数传入，得到 Thread 类实例对象：thread

6. 调用 thread.start()，启动线程

> futureTask.get() 返回 call 方法的返回值。



## 3 线程生命周期和状态

在Java中，线程被分为六种状态，这6种状态定义在Thread类的State枚举中（Thread.State）。一个线程在某一时刻只能有一种状态。

通常网上说的线程有五种状态：创建（NEW）、就绪（READY）、运行（RUNNING）、阻塞（BLOCKED）、死亡（DEAD），是把运行(RUNNABLE)拆分为就绪（READY）和运行中（RUNNING）两个状态，把阻塞(BLOCKED)、等待(WAITING)、超时等待(TIMED_WAITING)合并为阻塞（blocked）一个状态导致的。



参考：[链接](https://blog.csdn.net/pange1991/article/details/53860651)



**Java线程的六种状态：**

1. **初始(NEW)：**新创建了一个线程对象，但还没有调用start()方法。

2. **运行(RUNNABLE)：**Java线程中将==就绪（READY）==和==运行中（RUNNING）==两种状态笼统的称为==运行(RUNNABLE)==，也就是Java中的RUNNABLE状态包含了READY和RUNNING。

   - **就绪（READY）：**线程对象创建后，调用线程的start()方法，此线程进入就绪状态。该状态的线程等待被线程调度选中，争抢CPU执行权。就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。
   - **运行中（RUNNING）：**就绪状态的线程在获得CPU执行权后就变为运行中状态。

3. **阻塞(BLOCKED)：**阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

4. **等待(WAITING)：**处于这种状态的线程不会被分配CPU执行权，它们要等待被显式地唤醒（等待其他线程做出一些特定动作（通知或中断）），否则会处于无限期等待的状态。

5. **超时等待(TIMED_WAITING)：**与WAITING不同的是，TIMED_WAITING有最大等待时间，在达到这个时间后它们会自动唤醒。

6. **终止(TERMINATED)：**该状态在以下情况发生时出现：

   - 当线程的run()方法完成时，或者主线程的main()方法完成
   - 线程调用stop方法
   - 线程出现异常没有处理

   终止状态表示该线程已经执行完毕。线程一旦终止了，就不能复生。终止的线程再用start()方法，就会抛出java.lang.IllegalThreadStateException异常。



![线程状态](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\多线程\线程状态.jpeg)





![线程状态转换](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\多线程\线程状态转换.png)

## 4 线程优先级

Java中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行（概率上）。

子线程的优先级被默认等于创建它的主线程的优先级。



**线程优先级（静态属性）：**

1. Thread.MAX_PRIORITY：10
2. Thread.MIN_PRIORITY：1
3. Thread.NORM_PRIORITY：5（默认）



**设置优先级：**

```java
thread.setPriority()
```

**获取优先级：**

```
thread.getPriority()
```



## 5 Thread的常规操作方法

### 5.1 实例方法

#### start()

辟新的栈空间，启动线程，执行 run 方法，进入**就绪状态（ready）**。
一个线程只能启动一次，即个线程的start()只能执行一次，否则报错：IllegalThreadStateException



#### getName()\setName()

获取\设置线程名字



#### join()

执行该语句的当前线程进入**等待状态（WAITING）**，等待目标线程执行完，达到死亡状态（TERMINATED）时，当前线程才能重新执行。



**注：**

1. join方法一般写在【目标线程】外部，效果如上

2. 若在目标线程内部调用，等于在内部等待自己死亡，释放执行权，进入永远阻塞状态。



**isAlive()**

测试此线程是否仍然存活。



#### getState()

获取线程状态。返回 Thread.State 枚举实例。



### 5.2 静态方法

#### currentThread()

返回对当前正在执行的线程对象。



#### yield()

让步，释放cpu执行权，让线程从RUNNABLE的**运行中状态（RUNNING）**切换到**就绪状态（READY）**，重新争抢执行权。



**注：**

1. 不释放对象锁，如果有 synchronized 同步块，其他线程仍然不能访问共享数据
2. 只能**相同或高于**它的优先级的线程有争抢执行权的机会。



#### sleep()

休眠，释放cpu执行权，进入**超时等待状态（TIMED_WAITING）**，让其他线程先执行，休眠结束再争抢执行权，继续执行。



**注：**

1. 不释放对象锁，如果有 synchronized 同步块，其他线程仍然不能访问共享数据
2. 需要处理异常
3. 此操作受到系统计时器和调度程序精度和准确性的影响
4. 所有优先级的线程都有争抢执行权的机会（区别于yield）



## 6 线程安全问题

**满足以下所有条件时，将出现线程安全问题：**

1. 多线程运行的代码（单线程不会出现线程安全问题）

2. 多个线程有共享数据，并对其进行操作

   > 解释：当某一线程操作共享数据时，执行了部分代码，但尚未完全执行完成，这时候cpu切换到另外一个线程执行，这个线程也同样进入此处操作共享数据，这种情况就容易产生对共享数据的重复操作，或多余的操作，这就是线程安全问题。**并且线程的阻塞会加大这种安全问题出现的概率。**



![线程安全之卖票](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\多线程\线程安全之卖票.bmp)

**现象举例：**

1. 多个窗口买票，出现重票、错号票
2. 多人对同一银行账户存取、取款，数额不符



**解决思路：** 同步机制。当某线程在操作共享数据时，禁止其他线程同时操作，直到当前线程操作完成。即在同一时间，保证只有一个线程在操作共享数据，操作共享数据的代码相当于是单线程的。

**同步机制缺点：** 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。



### 6.1 同步方案

**同步方案：**

1. synchronized方式

   1. 同步代码块

   2. 同步方法

2. Lock锁

   > 推荐顺序： lock锁 - 同步代码块 - 同步方法



#### 6.1.1 同步代码块

**格式：**

```java
synchronized(同步监视器){
	// 需要同步的代码
}
```

**需要同步的代码：**

即操作（包括判断）共享数据的代码。

- **注意：**需要同步的代码不能多了或少了。少了依然有同步安全问题；多了，一些没必要同步的代码也变成同步，效率变低。



**同步监视器：**

同步监视器俗称“锁”。只有拿到锁的线程才可以进入同步代码块，只有当前线程执行完同步代码，才会把锁递交给下一个线程，即同一时刻，一把锁只能被一个线程持有。没有拿到锁的线程，运行到同步代码块会进入**阻塞状态（BLOCKED）**等待，直到拿到锁重新进入运行状态。

- **要求：**

  1. 锁必须是对象，任何类的对象都可以充当锁
  2. 唯一性：必须确保使用多个线程共用一把锁（即锁对象是同一个），这个非常重要，否则就无法保证共享资源的安全

  

- **常用的锁对象：**

  - 创建一个任意唯一对象（不推荐，浪费内存）
  - this：需要保证每个线程都共享这个this，而不是各自创建一个this（[继承Thread类式](#2.1 继承Thread类式)创建的线程的this不唯一，所以不推荐）
  - 当前类.class\getClass()（一个类只会加载一次，所以每个类的Class对象都是唯一的，推荐）

  

- **释放锁的操作：**
  1.当前线程的同步方法、同步代码块执行结束。
  2.当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
  3.当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
  4.当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。



- **不会释放锁的操作：**
  1.线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行
  2.线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。

  > 注： 应尽量避免使用suspend()和resume()来控制线程

  

#### 6.1.2 同步方法

同步方法脱胎于同步方法块，机制基本类似，区别在于同步监视器。



**格式：** 

```java
synchronized returnType methodName(){
	// 需要同步的代码
}
```



**同步监视器（锁）：** 无需手动声明，是固定的，区别于同步方法块。若同步方法是实例的，便是 this 对象，若同步方法是静态的，便是本类的Class对象。所以当在[继承Thread类式](#2.1 继承Thread类式)创建的线程中想要使用同步方法来实现线程同步时，它的this对象不是唯一的，则需要使用==静态的同步方法==。



**注意事项：** 

1. synchronized关键字不能继承：在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以同步。



#### 6.1.3 Lock锁

从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition 。 



**Lock接口：** Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。



**ReentrantLock类：** ReentrantLock类 实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。



**步骤：**

1. 创建锁

   ```java
   ReentrantLock reentrantLock = new ReentrantLock();
   ```

2. 获取锁，锁上。在需要同步的代码前调用

   ```java
   reentrantLock.lock();
   ```

3. 释放锁，解锁。在可能出现线程安全的同步代码后调用

   ```java
   reentrantLock.unlock();
   ```



**注意事项：**

 1. 一定要手动关闭锁，否则将造成死锁
 2. 为了避免报错执行不到解锁操作，造成死锁，建议使用 try-finally，在finally调用unlock



**Lock相较于synchronized方式的不同：**

1. Lock是显式锁，手动释放，是更为灵活的结构，synchronized是隐式锁，出了作用域自动释放
2. Lock只有代码块锁，synchronized有同步代码块和同步方法
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）



### 6.2 死锁问题

不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。

线程出现死锁后，不会出现异常，不会出现提示，只是所有死锁的线程都处于阻塞状态，无法继续。

所以需要避免死锁的出现。



**解决方法：** 

1. 专门的算法、原则
2. 尽量减少同步资源的定义
3. 尽量避免嵌套同步



## 7 线程通信

当我们需要多个线程共同完成一个任务时，总希望它们互相协作，有规律的运行，而不是独立随机的运行。这时，就需要线程通信机制，通信机制即等待唤醒机制，主要包含等待和唤醒两种方式。



**线程通信的前提条件：** 多线程共同操作同一份共享数据，即需要同步机制时。



### 7.1 synchronized方式通讯

使用synchronized方式同步的多线程之间通讯，需要使用到wait()、notify()/notifyAll()方法，这三个方法定义在Object类中，所有的类的对象都会继承这些方法。



**注意事项：**

1. wait()/notify()/notifyAll()必须写在synchronized代码块中或synchronized方法中（lock中不行），否则会报 IllegalMonitorStateException 异常
2. wait()/notify()/notifyAll()是成对调用的，有等待，就有唤醒
3. wait()/notify()/notifyAll()的调用者必须是**同步监视器对象**，且必须由**同一个锁**调用



**wait与sleep的对比：**

- **相同点：**都能造成当前线程阻塞
- **不同点：**
  - wait方法是Object类的实例方法，sleep是Thread类的静态方法
  - wait只能在synchronized代码块中或synchronized方法中，sleep在任何地方都可以
  - wait会释放对象锁，sleep不释放



- **wait()**

  使当前线程状态变成**等待（WAITING）**或**超时等待(TIMED_WAITING)**，释放cpu执行权，不执行wait后面的代码，让其他线程先执行。

  ==wait()会释放对象锁，而sleep、yield不会，这是重点。==

  

  **重载用法：**

  - wait(): 无限等待，使当前线程状态变成**等待（WAITING）**，只有notify了才能唤醒
  - wait(long m): 限时等待，使当前线程状态变成**超时等待(TIMED_WAITING)**，超过时长m没被notify唤醒，自动醒来



- **notify()/notifyAll()**

  - **notify：** 唤醒，唤醒另外一个被wait的线程，重新进入就**绪状态（READY）**，抢夺执行权，抢到之后继续执行wait后面的代码。==如果有多个等待线程，选择其中一个唤醒， 选择是任意的==。

  - **notifyAll：** 唤醒所有被wait的线程



### 7.2 Lock锁方式通讯

Lock锁方式通讯需要java.util.concurrent.locks.Condition类提供的方法。Lock接口提供了一个newCondition的方法来返回Condition实例。

Condition类提供了await()、signal()/signalAll()来实现线程通讯，其功能分别与wait()、notify()/notifyAll()方法近似。



```

```

# 网络编程？

# File?

# IO流？

I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。

Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行。

java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。



- 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。
- 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。



## 1 流的分类

- 按操作**数据单位**不同分为：
  - **字节流(8 bit)：**传输过程中，传输数据的最基本单位是字节的流。一般以Stream结尾。一般用于处理字节数据（图片\视频\音频.doc.ppt...）。 ==字节流对字符文件也可以处理，但从内存直接读取打印会可能乱码，单纯的读取和写入不会有问题。==
  - **字符流(16 bit)：**传输过程中，传输数据的最基本单位是字符的流。一般以reader/writer结尾。一般只能处理字符数据（.txt.html.java...）。
- 按数据**流的流向**不同分为：
  - **输入流：**数据流向程序内存的叫作输入流。一般带有input/reader。
  - **输出流：**数据从程序内存流出的叫作输出流。一般带有output/writer。
- 以流相对于程序的另一个端点的分，按**流的角色**的不同分为：
  - **节点流：**以特定源如磁盘文件、内存某区域或者线程之间的管道为端点的构造输入输出流，是一种基本的流。
  - **处理流（过滤流）：**是对一个已存在的流为端点构造，进行连接和封装，通过所封装的流的功能调用实现数据读写。 ==关闭处理流的时候，会自动将自身所封装的流一并关闭，所以只需要关闭最外层的处理流即可。==



![IO流分类](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\IO流\IO流分类.png)





Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个**抽象基类**派生的。

|            |    字节流    | 字符流 |
| :--------: | :----------: | :----: |
| **输入流** | InputStream  | Reader |
| **输出流** | OutputStream | Writer |



![IO流详细分类](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\IO流\IO流详细分类.jpg)

## 2 流的操作

**流的操作一般包括：**

1. 流的实例化
2. 读、写文件操作
3. 流的关闭



**注意：**

1. 流的操作一般都需要处理异常
2. 流关闭后将释放与之关联的所有资源，若不关闭会消耗性能，所以必须关闭，一般放在finally中执行
3. 在关闭该流后，再调用 read()、ready()、mark()、reset() 或 skip() 将抛出 IOException





## 3 常用流

### 3.1 文件流

- FileInputStream：字节输入文件流，节点流的一种；用于读取诸如图像数据之类的原始字节流。

- FileOutputStream：字节输出文件流，属节点流的一种；用于写入诸如图像数据之类的原始字节流。

- FileReader：字符输入文件流，属于节点流的一种；用来读取字符文件的便捷类。

- FileWriter：字符输出文件流，属于节点流的一种；用来写入字符文件的便捷类。

  > 实际开发一般不会用这四个，因为效率太低

  

### 3.2 缓冲流

- BufferedInputStream：字节输入缓冲流
- BufferedOutputStream：字节输出缓冲流
- BufferedReader：字符输入缓冲流
- BufferedWriter：字符输出缓冲流



为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个**内部缓冲区数组**，缺省使用**8192个字节(8Kb)的缓冲区**。 

java缓冲流本身不具IO功能，只是在别的流上加上缓冲提高效率，像是为别的流装上一种包装（处理流）。因为缓冲流先将数据缓存起来，然后一起写入或读取出来。所以说，缓冲流还是很重要的，在IO操作时记得加上缓冲流提升性能。

- 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 

- 当写入数据时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方flush()可以强制将缓冲区的内容全部写入输出流。



**不带缓冲的流的工作原理：**

它读取到一个字节/字符，就向用户指定的路径写出去，读一个写一个，所以就慢了。



**带缓冲的流的工作原理：**

读取到一个字节/字符，先不输出，等凑足了缓冲的最大容量后一次性写出去，从而提高了工作效率



**优点：**减少对硬盘的读取次数，降低对硬盘的损耗。



**关闭缓冲流的顺序：**

关闭流的顺序和打开流的顺序相反。**只要关闭最外层流即可**，关闭最外层流也会自动关闭内层节点流。



**flush()方法：**

刷新缓冲区，手动将buffer中内容写入文件。

> 注意：执行缓冲流的close()方法，不但会关闭流，还会先调用flush()方法，在关闭流之前刷新缓冲区。



### 3.3 转换流

- InputStreamReader：字节转字符输入流。期间做了一个解码的操作
- OutputStreamWriter：字符转字节输出流。期间做了一个编码的操作



转换流提供了在字节流和字符流之间的转换。

当我们拿到一个字节流，但里面数据都是字符时，我们可以使用转换流将它转成字符流，==转成字符流操作更高效。==

通过转换流可以解决一定的编码问题。很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。





![转换流](E:\Desktop\myJavaStudy\JavaBase\src\DOCS\images\IO流\转换流.png)

```


```

### 3.4 数据流



### 3.5 对象流



### 3.6 打印流



### 3.7 标准输入输出流



### 3.8 随机存取文件流



## 4 NIO





# Stream？



# JDBC?



# 设计模式？



# 算法？
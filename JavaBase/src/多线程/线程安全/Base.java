package 多线程.线程安全;

/**
 @什么时候需要处理线程安全问题：
 （1）存在多线程运行的代码
 （2）多个线程有共享数据
 （3）多线程运行代码中存在操作共享数据

 @不安全问题： 当某个线程在操作共享数据时，且尚未完成，其他线程也参与进来操作共享数据

 @解决方向： 同步机制。当a线程在操作共享数据时，禁止其他线程同时操作，直到a线程操作完成。即在同一时间，只能有一个线程在操作共享数据

 @同步机制缺点： 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

 @解决方案：
    1.synchronized关键字：
        1.同步代码块
        2.同步方法
    2.lock锁

 @推荐顺序： lock锁 - 同步代码块 - 同步方法

 @synchronized关键字：

     @同步监视器（锁）： 哪个线程拿到锁它就可以运行锁控制的那段代码，只有当前线程执行完，才会把锁递交给下一个线程

     @锁的要求：
        1.锁必须是对象，任何对象都可以充当锁
        2.必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全

     @释放锁的操作：
        1.当前线程的同步方法、同步代码块执行结束。
        2.当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
        3.当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
        4.当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。

     @不会释放锁的操作：
         1.线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行
         2.线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。
            @注： 应尽量避免使用suspend()和resume()来控制线程

 @synchronized与Lock的对比：
    1. Lock是显式锁，手动释放，synchronized是隐式锁，出了作用域自动释放
    2. Lock只有代码块锁，synchronized有代码块锁和方法锁
    3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
 */
public class Base {

}

> 进程（Process）和线程（Thread）   

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。
程序是指令、数据及其组织形式的描述，进程是程序的实体。

进程是程序的一次动态执行过程，它需要经历从代码加载，代码执行到执行完毕的一个完整的过程，这个过程也是进程本身从产生，发展到最终消亡的过程。
多进程操作系统能同时达运行多个进程（程序），由于 CPU 具备分时机制，所以每个进程都能循环获得自己的CPU 时间片。由于 CPU 执行速度非常快，
使得所有程序好像是在同时运行一样。

多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是进程的基础之上进行进一步
的划分。所谓多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的单元称为线程，这些线程可以同时存在，同时运行，一个进程可能
包含多个同时执行的线程。

程序是一段静态的代码，进程是正在运行的程序，线程是程序内部执行的一条路径。

每个线程拥有独立的栈、程序计数器；一个进程中的多个线程共享进程的堆、方法区

> 并发与并行

- 参考：[链接](https://baijiahao.baidu.com/s?id=1666454968534966585&wfr=spider&for=pc)

- 并发（concurrency）

    指两个或多个事件在【同一个时间段内间隔】发生。 （一个人吃两个馒头，一口咬这个，一口咬那个）
    指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，
    但在微观上并不是同时执行的，只是把时间分成若干端，使多个进程快速交替的执行。比如：
    一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。
    由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，
    这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用
    这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。
    
- 并行（parallel）

    指两个或多个事件在【同一时刻】发生（同时发生）。（两个人同时吃两个馒头，互不影响）
    它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。
    并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。
    而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。

> 线程调度: 

- 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 

- 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

> 线程生命周期和状态：

- 参考：[链接](https://blog.csdn.net/pange1991/article/details/53860651)

线程的五态：创建（new）、就绪（ready）、运行（running）、阻塞（blocked）、死亡（dead）

Java语言中State有以下6种状态：

1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。

2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。

3. 阻塞(BLOCKED)：表示线程阻塞于锁。

4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。

6. 终止(TERMINATED)：表示该线程已经执行完毕。

> 线程的分类： 守护线程和用户线程

守护线程（例如gc线程）是为用户线程（例如main）服务的，且优先级比较低。在java中当应用只剩下守护线程时，虚拟机就会退出，主要因为守护线程没有的服务的对象了，
自己运行也没有什么必要了。

比喻：兔死狗烹，鸟尽弓藏

将用户线程变成守护的方法是setDaemon()。

> 何时需要多线程？

1. 程序需要同时执行两个或多个任务。
2. 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。
3. 需要一些后台运行的程序时



# 一、数据类型

Java数据类型可分为基本数据类型和引用数据类型两大类。

基本类型分为八种：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 其中整数型：byte、short、int、long



## 1 数据类型

- **byte：**

  byte 数据类型是8位、有符号的，以二进制补码表示的整数。

  - 最小值是 -128（-2^7）；
  - 最大值是 127（2^7-1）；
  - 默认值是 0；

  byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一。

  例子：byte a = 100，byte b = -50。



- **short：**

  short 数据类型是 16 位、有符号的以二进制补码表示的整数

  - 最小值是 -32768（-2^15）
  - 最大值是 32767（2^15 - 1）
  - 默认值是 0

  Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一。

  例子：short s = 1000，short r = -20000。



-  **int：**

  int 数据类型是32位、有符号的以二进制补码表示的整数。

  - 最小值是 -2,147,483,648（-2^31）
  - 最大值是 2,147,483,647（2^31 - 1）
  - 默认值是 0 

  一般地整型变量默认为 int 类型。

  例子：int a = 100000, int b = -200000。



- **long：**

  long 数据类型是 64 位、有符号的以二进制补码表示的整数。

  - 最小值是 -9,223,372,036,854,775,808（-2^63）
  - 最大值是 9,223,372,036,854,775,807（2^63 -1）
  - 默认值是 0L

  这种类型主要使用在需要比较大整数的系统上。

  例子： long a = 100000L，Long b = -200000L。

  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。



- float：

  float 数据类型是单精度、32位、符合IEEE 754标准的浮点数。 float 在储存大型浮点数组的时候可节省内存空间；

  - 默认值是 0.0f

  浮点数不能用来表示精确的值，如货币；

  例子：float f1 = 234.5f。

  

- **double：**

  double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型；

  - 默认值是 0.0d；

  double类型同样不能表示精确的值，如货币；

  例子：double d1 = 123.4。



- **boolean：**

  boolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；

  - 默认值是 false；

  例子：boolean one = true。



- **char：**

  char类型是一个单一的 16 位 Unicode 字符；

  - 最小值是 \u0000（即为0）；
  - 最大值是 \uffff（即为65,535）；

  char 数据类型可以储存任何字符；

  例子：char letter = 'A';。





## 2 包装类

Java语言是一个面向对象的语言，但并不是<u>纯面向对象的语言</u>。基本数据类型不是面向对象的，它们不具有继承性、多态性、封装性。这时，我们就需要利用包装类(Wrapper Class)将基本类型数据转化成引用类型！在实际使用中经常将基本数据类型转换成对象，便于操作，比如，集合的操作中。



> 包装类是属于引用类型，包装类都位于java.lang包下。



**装箱与拆箱：** 

- 装箱：基本类型 --> 包装类对象
- 拆箱：包装类对象 --> 基本类型



**为什么需要装箱与拆箱：**

- 基本类型不可调用方法、属性等对象才有的特性
- 包装类不可直接使用算术运算符，需要先转成基本类型



**基本类型与包装类的对应关系：**

| 基本类型 |      包装类       |
| :------: | :---------------: |
|   byte   |       Byte        |
|  short   |       Short       |
|   int    |  Integer【特殊】  |
|   long   |       Long        |
|  float   |       Float       |
|  double  |      Double       |
|   char   | Character【特殊】 |
| boolean  |      Boolean      |



**自动装箱、自动拆箱：**

从JDK 1.5+开始，支持自动装箱、自动拆箱。

如：

```java
Type var = value;
```



**包装类的缓存机制：**

包装类内部有一个 XxxCache 的静态结构（如：IntegerCache），如果我们自动装箱的范围在：-128~127之间，就会缓存在 XxxCache.cache 这个数组里，
如果再次调用，直接使用缓存中的地址，不会再去 new 了。



**目的：**提高效率。



注意：手动装箱没有缓存（使用new），自动装箱有缓存



## 3 基本类型的自动转换

基本数据类型（除布尔类型外）在某些情况下将发生数据类型自动转换。这些情况包括：赋值运算，数学运算，三目运算，传参等。



**快速记忆：** 数字相关才能玩，运算，传参，不带布尔玩



**自动类型转换（提升）特点：**

1. 代码不需要进行特殊处理，自动完成。
2. 数据范围从小到大自动转变（与字节数无关），所以也叫提升。
3. byte/short/char这三种类型在运算的时候，都默认被先提升成为int类型，然后计算
4. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）



## 4 基本类型的强制转换

向下转换，将数据是从范围大到小的转换。



**格式：** 

```java
（类型）数据
```



**快速记忆：**小小括号能强制，数字相关才能玩，就是不带布尔玩；从小到大很没问题，从大到小要亏损；byte/short/char搞特殊，常量不超范围可省略。



**注意事项：**

1. 不推荐使用，有可能发生精度损失、数据溢出
2. byte/short/char三种类型：如果【常量数据】强制转换为此三种类型，且常量数据【不超过此三种类型范围】，可以省略强制格式——"(类型)"
javac编译器将会自动隐含地补上一个(byte)(short)(char)

3. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）



## 5 基本数据和String之间的类型转换

```

```

**快速记忆：** 基本转String用valueOf，toString，拼接符号黑科技；String转基本用parse，只有char搞特殊。



### 5.1 **基本类型转String类型**

- String.valueOf(基本类型数据)

  如：

  ```java
  String str1 = String.valueOf((byte) 1);
  ```

- 包装类的toString方法

  如：

  ```java
  String str1 = Byte.toString((byte) 1);
  ```

- 字符串拼接方式

  如：

  ```java
  String str1 = (byte) 1 + "";
  ```



### 5.2 String类型转基本类型

- 包装类的parseXxx(s)方法（不适用于char）

  如：

  ```java
  byte byte2 = Byte.parseByte("1");
  ```

- String --> char

  - 方式一：

    ```java
    char char1 = "A".charAt(0);
    ```

  - 方式二：

    ```java
    char char2 = (char) Integer.parseInt("65");
    ```

    

# 二、类和对象

 ## 1 类的概述

类（class）是对现实中实体事物的属性和行为的描述，是抽象的，概念上的定义，是一个模板



**类的命名规范：** 大驼峰（MyClass）



**注意事项：**

1. 一个源文件【必有且仅能有】一个与文件名相同的类
2. 一个源文件中仅能有一个 public 类，且 public 类名必须与源文件名一致（原因：为了在import公共类时提高效率）
3. 一个源文件可以有多个非 public 类，可以跟文件名不同，但为了为了便于管理，一般一个源文件放一个类
4. 同一个包（同级目录）下不能有重复名称的类



**面向对象具体实现流程：**

1. 创建类，设计类的变量和方法
2. 创建对象
3. 通过对象的属性和方法，来调用对象结构



### 1.1 对象

对象（instance）是实际存在的个体，有状态和行为，也称为实例。对象是解决问题的最终工具。



**对象的命名规范：** 小驼峰（myInstance）



**判断对象的值与址的相等性：**

1.  == ：参考 \src\运算符\双等号
2.  equals：参考 \src\常用类.Object类\equals
3.  Objects.equals：参考 \src\常用类.Object类\Objects工具类\Equals



#### 1.1.1 创建对象

 创建对象也叫类的实例化，或实例化类。

**格式：**

```sql
类型 对象名 = new 类(参数列表);
```



#### 1.1.2 匿名对象

创建对象没有显式地赋给一个变量名，即为匿名对象。

如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。

> 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。



### 1.2 this关键字

**使用格式：** 

```java
类名.this // “类名”省略代表当前类下的this
```

**作用：**

- 充当当前实例对象，用于访问实例的成员变量\方法，如：this.field/this.method()
    **注：**当与成员变量或形参不重名的情况下，this可以省略

- 充当本类的构造函数，用法：this()\this(...)
    **注：**

  1. 只允许在构造器的第一行代码执行
  2. 一个构造器中只允许执行一个其他构造方法
  3. 只允许调用其他构造器
  4. 构造器不允许循环调用

  

**注意：** 静态方法、静态代码块中不能使用this，因为实例对象还没生成



## 2 类的成员

类的成员包括**变量**（属性、域、字段、field）、**方法**（行为、函数、method）、**代码块**（初始化块、block）。

面向对象的设计重点是类的设计，而设计类重点则是<u>设计类的成员</u>。



**类的成员分类：**

- 变量
- 方法
- 构造器
- 类
- 接口
- 代码块

> 以上每种都可分为静态（类成员）与非静态（实例成员）。



### 2.1 成员变量



与局部变量不同，成员变量有默认值，不同类型的成员变量有不同的默认值（与数组一致）。

**成员变量的默认值：**

- 整数类型：默认为 0
- 浮点类型：默认为 0.0
- 字符类型：默认为 '\u0000'(一个特殊字符)
- 布尔类型：默认为 false
- 引用类型：默认为 null



**就近原则：**当方法的<u>局部变量</u>和类的<u>成员变量</u>重名的时候，根据“就近原则”，优先使用局部变量。



**成员变量赋值的先后顺序：**

1. 默认初始化
2. 显式赋值
3. 构造器赋值
4. 通过“对象.方法”或“对象.属性”赋值

> 注：123只执行一次，4可以反复执行）



**实例变量、静态变量、局部变量的对比:**

1. 定义的位置不一样【重点】
    成员变量：定义在类中
    局部变量：定义在方法（包括构造器）中、方法（包括构造器）形参、代码块

2. 作用范围不一样【重点】
   成员变量：整个类全都可以通用。
   局部变量：只有方法当中才可以使用，出了方法就不能再用

3. 默认值不一样【重点】
   成员变量：如果没有赋值，会有默认值，规则和数组一样
   局部变量：没有默认值，如果要想使用，必须手动进行赋值

4. 内存的位置不一样
   实例变量：位于堆内存，跟着实例对象走，new的时候创建
   静态变量：位于方法区（静态域），跟着类走
   局部变量：位于栈内存，跟着方法走，方法进栈，局部变量创建

5. 生命周期不一样
   实例变量：随着实例对象创建而诞生，随着实例对象被垃圾回收而消失。所以实例变量生命周期就是实例对象的开始和销毁。
   静态变量：随着类声明而诞生，随着类被垃圾回收而消失。所以静态变量生命周期就是类的开始和销毁。
   局部变量：随着方法进栈而诞生，随着方法出栈而消失。所以局部变量生命周期就是方法的开始和销毁。

6. 权限修饰符的不同
   成员变量不可用权限修饰符



**成员常量：**可算做不可变的成员变量，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 2.2 成员方法



### 2.3 构造器

构造器（Constructor/构造方法/构造函数）是专门用来创建对象的特殊方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。



**作用：**

1. 创建对象

2. 初始化对象信息



**格式：**

```java
权限修饰符 构造器名(参数列表) {
   ...
}
```

**构造器与成员方法的区别：**

       1. 构造方法的名称必须和所在的类名称完全一模一样
       2. 构造方法不写返回值类型，连void都不写，也不能 return
       3. 构造方法用于创建对象，并进行初始化值；普通成员方法是用于完成特定功能的。
       4. 构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数；普通成员方法是由创建好的对象调用，可以调用多次

> 注：构造器可以看作特殊的成员方法



**注意事项：**

1. 如果没有编写任何构造方法，那么编译器将会默认创建一个空的构造方法（没有参数、方法体什么事情都不做，即：public Student() {}）
2. 默认提供的构造器的权限修饰符与类相同
3. 一旦显式定义一个构造方法，那么编译器将不再默认创建
4. 构造方法允许重载。（重载：方法名称相同，参数列表不同）
5. 一个类至少有一个构造器，创建一个对象的时候，至少要调用一个构造器
6. 构造方法允许被各种权限修饰符修饰



### 2.4 代码块

代码块也叫初始化块。

**分类：**
       1. 非静态代码块（实例）
       2. 静态代码块



**执行顺序：**

1. 静态代码块先于非静态代码块执行

2. 同一类的多个代码块按**声明顺序**执行（一般不会声明多个代码块）



#### 2.4.1 非静态代码块

**声明格式：**

```java
{
    ...
}
```

**用途：** 给实例属性初始化

**执行时间：** 每次<u>创建实例</u>时候都会执行一次

**创建实例时，实例结构的执行顺序：**

1. 默认初始化
2. 显式初始化/非静态代码块执行
   注： 显式初始化和（实例）代码块执行是同一级别的，谁在前谁先
3. 构造器初始化
4. 通过"对象.属性"或“对象.方法”去赋值



#### 2.4.2 静态代码块

**声明格式：**

```java
static {
    ...
}
```

**用途：** 给静态变量初始化

**执行时间：** 每次<u>加载类</u>的时候都会执行一次

**加载类时，静态结构的执行顺序：**

1. 默认初始化
2. 显式初始化 / 静态代码块执行
   注： 显式初始化和静态代码块执行是同一级别的，谁在前谁先
3. main方法执行



**注意：**

1. 静态代码块类只能调用静态结构
2. 继承的时候先需要加载父类，所以父类的静态代码块也会先执行



### 2.5 成员类、成员接口

成员类是内部类的一种，具体可参考[7.1 成员内部类](#7.1 成员内部类)。

成员接口与成员类类似。



### 2.6 静态成员

static 修饰符可用于修饰类的成员（变量和方法，以及内部类），被修饰的统称为为静态成员。



**什么时候使用静态的：**

1. 不会随着对象改变而变的成员
2. 操作静态属性的方法
3. 工具类的方法，习惯用静态的（比较省事，不用创建对象，如Math、Arrays）
4. 常量（final）习惯用静态的



**访问格式：** 类.静态变量\方法\类

**静态成员内存位置：** 位于静态域（方法区）

**特点：**

1. 节省内存空间
2. 共享性



**注意事项:**
   1. 静态成员属于所在的类，非属于实例对象
   2. 静态成员被同一类的实例对象可以共享
   3. 静态成员可直接通过类访问，不需要创建实例就可使用
   4. 静态先于实例对象存在，所以静态方法中不可用实例变量、实例方法、this、super关键字，但可以访问其他静态成员
   5. 实例方法可以访问静态成员
   6. 实例成员和静态成员的名称不允许重复
   7. 静态方法可以被继承，可以被重载，可以被隐藏（隐藏其实相当于重新声明），但不能被重写



## 3 JavaBean

JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定。



**约定：**
1. 所有的成员变量私有化（private）
2. 私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范
3. 必须具有一个公共的(public)无参构造函数
4. 这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）



## 4 类的继承

继承（extends）就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。



**书写格式：**

```java
修饰符 class 子类名 extends 父类名 {
    
}
```



**作用：**共性抽取

**特性:**

1. 子类拥有父类<u>所有的属性和方法</u>

2. 子类可以在父类的基础上进行修改和扩展，方式是重写、重载、隐藏

3. 父类的private属性和方法也是可以被继承的，只是子类拥有但无法访问（封装性）；不能直接访问，但可以间接通过非private的父类方法进行访问。

4. Java 的继承是【单继承】，但是可以【多重继承】。单继承是一个子类只能继承一个父类（只能有一个父亲），多重继承就是子类也可以当父类（传代），例如 A 类 -> B 类 -> C 类

   > 注：A 类 -> B 类 -> C 类，B为C的直接父类，A为C的间接父类

5. 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）

6. 继承是多态的前提

7. 所有类继承的最顶级对象是java.lang.Object，Object是祖先类，Object在 java.lang 包中，所以不需要 import

8. 当访问实例对象的成员变量或方法时，则优先寻找本类当中是否存在，若有则用，无则向上（父类）寻找，不会向下（子类）寻找

9. 若需访问父类与子类的重名成员变量时，可通过super访问



### 4.1 super关键字

我们可以通过super关键字来实现对父类成员的访问，相当于父类的this，指向父类实例。



**使用格式：** 

```java
类名.super // "类名"省略代表当前类的super
```



**作用：**

1. super可以指向父类的this，现对父类成员的访问，用来访问父类的成员变量和方法

2. 可以充当父类的构造函数



**使用注意事项：**

1. 只能在子类构造函数中执行
2. 跟this一样，只能作为第一个语句执行，因此一个代码块中，super和this只能调用一个一个构造函数只能执行一次super

3. 子类所有的构造器第一行都会默认隐式地执行父类的无参构造器（super()），手动显式地执行super()或this()，则替代默认的super()
4. 子类的构造器中，第一行不是执行this()，就是执行super()，而至少有一个子类构造器执行super()，而至多有n-1个this()
5. 每个子类的构造器都会直接或间接调用父类构造器，所以当执行某类的构造器的时候，一定会把它所有父类的构造器都执行一遍，直到Object的构造器，这便是继承的过程。注意：但只创建一个对象，即new的那个类的对象



## 5 重写、重载、隐藏

**重载与重写对比：**

- 重写（Override）：方法的名称、形参列表<u>要求一样</u>；访问权限、返回值类型<u>要求兼容</u>；其他无关；用于子类覆盖父类方法。

  > 记忆：替代

- 重载（Overload）：方法的名称<u>要求一样</u>；形参列表<u>要求不一样</u>；其他无关；用于对不同的传参进行不同的处理情景，可对本类或父类的方法重载。

  > 记忆：新增一种实现方式



### 7.1 方法重写

方法重写（覆盖/覆写/Override/Overwrite）是子类对父类的允许访问的【实例方法】的实现过程进行重新编写，返回值和形参都不能改变。

<u>即外壳不变，核心重写！</u>



**书写格式：**

```java
@Override
修饰符 类型 方法名 (参数列表){
    ...
}
```

> 注解@Override 写在方法前面，可用来检测是不是有效的正确覆盖重写（可写可不写）



**作用：** 重写的作用在于子类可以根据业务需要，重定义方法的行为，也就是说子类能够根据需要实现父类的方法。



**要求：**

1. 方法的名称、参数列表（类型\个数\顺序）必须相同

2. 返回值类型：如果父类返回值为引用类型，则子类重写方法的返回值必须【小于等于】父类的；如果父类返回值为基本类型或void，则子类必须返回跟父类一模一样的

3. 访问权限：子类重写方法必须【大于等于】父类方法

   > 访问权限：public > protected > (default) > private

4. throws类型：子类重写方法必须【小于等于】父类方法，如果父类没有声明throws，则子类也不能声明



**注意事项：**

1. 重写只能是子类对父类（祖先类）的重写，不能是对本类或子类方法的重写
2. 声明为 final 的方法不能被重写。
3. private方法无法被重载、重写，因为子类无法访问父类的private成员
4. 父类静态方法可以被继承，可以被重载，可以被隐藏，但不能被重写（隐藏只是形式上的重写，并不满足多态的特征，所以严格说不是重写）
5. 重写只能适用于【实例方法】，不能用于静态方法，对于静态方法,只能隐藏



### 7.2 方法重载

方法重载（Overload）是指在同一个类中定义多个同名的方法，要求每个方法具有不同的形参的类型\个数\顺序，保证每个重载的方法都必须有一个独一无二的参数列表。



**作用：** 对不同的传参进行不同的处理

**方法重载与下列因素相关：**

1. 参数个数不同
2. 参数类型不同
3. 参数的多类型顺序不同



**方法重载与下列因素无关：**

1. 与形参的名称无关
2. 与方法的返回值类型无关
3. 与方法的修饰符无关



**注意：**

1. 重载可以对本类方法的重载，也可以是子类对父类的方法进行重载，但不能是本类对子类的重载
2. private方法无法被重载、重写，因为子类无法访问父类的private成员



### 7.3 隐藏

隐藏是指子类的成员变量（包括实例变量和静态变量）和静态方法与父类的命名一样，访问子类的这些变量和方法的时候就只会访问子类的，而父类的被隐藏。若子类没有，再去访问父类的。



## 6 抽象类和抽象方法

**关键字：** abstract



###　6.１ 抽象类

如果一个类没必要实例化，仅提供一些结构供子类去实例化，其中没有包含具体的信息来描绘一个具体的对象，这样的类就是抽象类。

类的继承当中，结构会越来越具体，而上层的父类往往需要更通用，且没必要实例化，因此便有了抽象类。

抽象类就是用来继承的，继承过程中去重写抽象方法，



**声明格式：**

```java
权限修饰符 abstract class {
    ...
}
```



**注意：**

1. 抽象类不能直接实例化，必须被继承，才能够使用
2. 抽象类虽然不能实例化，但仍需要<u>构造器</u>，供子类调用
3. 没有任何抽象方法的抽象类有特殊作用（？？？）
4. 抽象类在继承方面没有限制——抽象类可以被抽象类、普通类继承，抽象类也可以继承抽象类、普通类
5. 抽象类也可以多态
4. final类不可被继承，而抽象类必须要被继承，所以抽象类不能被final修饰



### 6.2 抽象方法

抽象方法就是为了子类重写而存在，该方法的具体实现由它的子类确定，所以不需要方法体。



**声明格式：**

```java
[权限修饰符] abstract 返回类型 方法名 (参数列表); -- 权限修饰符缺省，默认为public
```



**注意：**

1. 抽象方法只能声明在抽象类中，且只有声明，没有方法体
2. 有抽象方法的类必定是抽象类，抽象类中不一定包含抽象方法
3. 子类必须覆盖重写抽象父类当中所有的抽象方法，除非该子类也是抽象类，否则报错
6. 静态方法（static）、私有方法（private）、final方法不可被重写，这些都与抽象冲突，不可用于修饰抽象方法



## 7 内部类

将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。

### 7.1 成员内部类

内部类作为一个外部类的成员存在。



**用途：** 当一个事物（人）需要一个完整的结构（大脑）去描述，而这个结构只需要对这个事物提供服务，那么这个结构最好使用内部类。

**分类：**

- 非静态成员内部类
- 静态成员内部类



**注意：**内部类的 this 指向内部类实例，若要在内部类中使用外部类的 this，则用：【外部类.this】。



#### 7.1.1 非静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
```



#### 7.1.2 静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称.内部类名称();
```





### 7.2 局部内部类

定义在方法、构造器、代码块内部的类。



**注意事项：**

1. 局部内部类只能在该方法内访问，方法外无法访问
2. 局部内部类不允许使用权限修饰符（public，default...），因为没有意义，它只能在方法内访问
3. 局部内部类只能通过所在的方法去使用



**局部内部类访问该方法内的局部变量的情况：** 

1. 该变量必须是【final】的，原因：因为局部变量是跟方法走的，而局部内部类是new出来的，是在堆中的，两者声明周期不同，所以局部变量必须不变
2. 从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略



#### 7.2.1 匿名内部类

匿名内部类也是局部内部类的一种，也只能定义是方法、构造器、代码块内部。

他常用于继承和实现中，当一个<u>子类</u>或<u>实现类</u>只使用一次时，可以使用匿名类快捷方便地创建实例。



**格式：**

```java
// 继承
父类名称 对象名 = new 父类名称(){
	// 匿名内部类（子类）
	// 这里书写子类的内容
};

// 实现
接口 对象名 = new 接口(){
	// 匿名内部类（实现类）
    // 这里书写实现类的内容
};
```



## 8 final类与final成员

### 8.1 final类

final类不可被继承（太监类），成为最终类，被继承会报错。



**注意事项：**

1. final类没有子类，但有父类（任何类都有父类，除了Object）
2. 既然没有继承，也就没有所谓的子类对父类的成员覆盖、重载
3. final类一样可以对它的父类成员进行重写、重载
4. abstract 和 final 互相矛盾（abstract 类一定要被继承，final 类不可被继承），不能同时使用



### 8.2 final成员

#### 8.2.1 成员常量

成员常量即加final的变量。

成员常量，不可用默认值，所以必须赋值一次（初始化），且不可再变。

赋值的位置有：显式赋值，构造器赋值，代码块赋值。（方法中赋值不可行，太晚了）。



**命名格式：**全大写，底杠分割，如：MY_NAME



**静态常量：**用 static final 修饰的成员变量。可当作**全局常量**。



**注意：**子类可以隐藏（覆盖）父类的成员常量



#### 8.2.2 final方法

**分类：**

- 静态final方法
- 非静态final方法



**注意：** 

1. abstract 和 final 互相矛盾（abstract 方法一定要被重写，final 方法不可被重写），不能同时使用
2. final方法不可被重写、隐藏，但可以被重载。



## 9 对象的序列化和反序列化

在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。但是，我们创建出来的这些对象都存在于JVM中的堆（heap）内存中， 只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止，这些对象也就随之消失；但是在真实的应用场景中，我们需要将这些对象持久化下来，并且在需要的时候 将对象重新读取出来，Java的序列化可以帮助我们实现该功能。

对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将对象的状态信息保存未字节数组，并且可以在有需要的 时候将这个字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。在JAVA中，对象的序列化和反序列化被 广泛的应用到RMI（远程方法调用）及网络传输中。



**定义一个可序列化的类的步骤：**

1. 继承Serializable接口
2. 声明全局常量：serialVersionUID

> 注意：如果内部属性有其他对象，这些对象也必须是可序列化的，否则该类无法可序列化



**serialVersionUID：**

简单来说，JAVA序列化的机制是通过判断类的serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID于本地相应实体类 的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。

serialVersionUID有两种显示的生成方式：

1. 是默认的1L，比如：private static final long serialVersionUID = 1L;
2. 是根据包名，类名，继承关系，非私有的方法和属性，以及参数，返回值等诸多因子计算得出的，极度复杂生成的一个64位的哈希字段。基本上计算出来的这个值是唯一的。 比如：private static final long serialVersionUID = xxxxL;

> 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明。


**注意**

1. static和transient修饰的成员变量无法序列化



# 三、接口

接口（Interface），是Java语言中一种引用类型，是方法的集合，是多个类的公共规范。

如果说类的内部封装了成员变量、构造方法和成员方法， 那么接口的内部主要就是封装了方法，其中最重要的就是的：**抽象方法**。

编写接口的方式和类很相似，但是它们属于不同的概念，接口与类是并列的两个结构。

接口是隐式抽象的。



**特性：**

- 多重实现：类只能单继承，但允许同时可以实现多个接口
- 多重继承：接口允许同时继承多个父接口



**接口与类的不同之处：**

1. 类描述对象的<u>属性和方法</u>，接口则包含类要实现的<u>方法</u>
2. 接口不能实例化（没有构造函数），同过<u>实现</u>发挥效用；类通过实例化发挥效用
3. 接口里的所有的方法必须是<u>抽象方法</u>
4. 接口支持<u>多继承，多实现</u>，而类只支持<u>单继承</u>。
5. 接口不能包含成员变量、构造方法、代码块



**接口与类的相同之处：**

1. 与类一样，接口文件保存在.java 结尾的文件中，文件名使用接口名
2. 与类一样，接口的字节码文件保存在 .class 结尾的文件中
3. 与类一样，接口也具有多态性
4. 与类一样，接口也可以包含常量、抽象方法、默认方法、静态方法、私有方法



**不同版本Java，接口包含的内容：**

- Java 7：
  - 常量
  - 抽象方法
- Java 8：
  - 默认方法
  - 静态方法
- Java 9：
  - 私有方法



**标识接口：**标识接口是<u>没有任何方法和属性</u>的接口。标识接口不对实现它的类有任何语义上的要求，它仅仅表明实现它的类属于一个特定的类型。如Serializable接口。



## 1 定义接口

**书写格式：**

```java
权限修饰符 [abstract] interface 接口名称 {
    // 接口内容
}
// 接口是隐式抽象的，所以[abstract]可省略
```



**接口的命名规范**： 大驼峰（MyInterface）



## 2 实现接口

接口不能直接使用，必须有一个“实现类”来实现该接口。接口支持多重实现，即：一个“实现类”可以同时实现多个接口。



**关键字：** implements



**书写格式：**

```java
// 实现，支持多重实现
权限修饰符 class 实现类名称 implements 接口名称1[, 接口名称2, 接口名称3, ...] {
     ...
 }

// 类同时继承，并实现接口，顺序：先继承，后实现
权限修饰符 class ClassA extends ClassB implements Interface1[, 接口名称2, 接口名称3, ...] {
    ...
}
```



**注意：**

1. 如果实现类没有重写接口中<u>所有的抽象方法</u>，该实现类必须定义成<u>抽象类</u>



## 3 接口继承

一个接口允许同时继承多个父接口，即多重继承。



**关键字：** extends



**书写格式：**

```java
// 继承，支持多重继承
权限修饰符 Interface extends Interface1[, Interface2, Interface3...] {
    ...
}
```



## 4 接口成员

接口成员包含：抽象方法、常量、默认方法、私有方法、静态方法。而其中抽象方法是最重要的。



### 4.1 抽象方法

接口最重要的内容就是其中的：抽象方法。



**格式：**

```java
[public abstract] 返回值类型 方法名称(参数列表);// [public abstract]可省略
```



**注意：**

1. 接口中的方法是隐式抽象的，声明时可以省略 abstract 关键字

2. 接口中的抽象方法必须是公有的，权限修饰符必须是public的，所以可以省略 public 关键字

   

### 4.2 常量

接口定义常量必须使用 public static final 三个关键字进行修饰，所以也可省略。



**格式：**

```java
[public static final] 数据类型 常量名称 = 数据值;
```



**命名格式：**全大写，底杠分割，如：MY_NAME



**注意：**

1. 常量，必须进行赋值

2. 常量会被实现类继承，变成类的静态变量（注意：静态方法不会被继承，这是区别）
3. 常量可以被隐藏
4. 常量可以接口直接调用，也可以实现类调用，也可以实例调用（除了多重实现时重复，只能接口调用）（重点）

>  基本与类的成员常量类似，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 4.3 私有方法

私有方法用于接口内部的代码封装。

> 从Java 9开始，接口支持定义私有方法。



**格式：**

```java
private [static] 返回值类型 方法名称(参数列表) {
	...
}
```



**注意：**私有方法只在接口内部可见，与外部无关。



### 4.4 静态方法

> 从Java 8开始，接口里允许定义静态方法。



**格式：**

```java
[权限修饰符] static 返回值类型 方法名称(参数列表) {
    ...
}
// 权限修饰符默认为public，可以省略
```



注意：

1. 静态方法非抽象方法，必带有方法体
2. 接口的静态方法不会被继承（这点与类不同），只存在接口自身中，当然也没有重载、重写、隐藏（重点）
2. 权限修饰符默认为public，可以省略（这点与类不同）
3. 静态方法只能通过接口自身调用，格式：接口.静态方法()



```
1. 静态方法非抽象方法，必带有方法体
2. 接口的静态方法不会被继承（这里与父类不同），只存在接口自身中，当然也没有重载、重写、隐藏（重点）
3. 静态方法只能通过接口自身调用，格式：接口.静态方法()
```



## 匿名接口




















































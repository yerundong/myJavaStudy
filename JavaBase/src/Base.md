# 一、数据类型

Java数据类型可分为**基本类型**和**引用类型**两大类。

基本类型分为八种：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 其中整数型：byte、short、int、long。

引用类型：类、接口、数组



## 1 数据类型

- **byte：**

  byte 数据类型是8位、有符号的，以二进制补码表示的整数。

  - 最小值是 -128（-2^7）；
  - 最大值是 127（2^7-1）；
  - 默认值是 0；

  byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一。

  例子：byte a = 100，byte b = -50。



- **short：**

  short 数据类型是 16 位、有符号的以二进制补码表示的整数

  - 最小值是 -32768（-2^15）
  - 最大值是 32767（2^15 - 1）
  - 默认值是 0

  Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一。

  例子：short s = 1000，short r = -20000。



-  **int：**

  int 数据类型是32位、有符号的以二进制补码表示的整数。

  - 最小值是 -2,147,483,648（-2^31）
  - 最大值是 2,147,483,647（2^31 - 1）
  - 默认值是 0 

  一般地整型变量默认为 int 类型。

  例子：int a = 100000, int b = -200000。



- **long：**

  long 数据类型是 64 位、有符号的以二进制补码表示的整数。

  - 最小值是 -9,223,372,036,854,775,808（-2^63）
  - 最大值是 9,223,372,036,854,775,807（2^63 -1）
  - 默认值是 0L

  这种类型主要使用在需要比较大整数的系统上。

  例子： long a = 100000L，Long b = -200000L。

  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。



- float：

  float 数据类型是单精度、32位、符合IEEE 754标准的浮点数。 float 在储存大型浮点数组的时候可节省内存空间；

  - 默认值是 0.0f

  浮点数不能用来表示精确的值，如货币；

  例子：float f1 = 234.5f。

  

- **double：**

  double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型；

  - 默认值是 0.0d；

  double类型同样不能表示精确的值，如货币；

  例子：double d1 = 123.4。



- **boolean：**

  boolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；

  - 默认值是 false；

  例子：boolean one = true。



- **char：**

  char类型是一个单一的 16 位 Unicode 字符；

  - 最小值是 \u0000（即为0）；
  - 最大值是 \uffff（即为65,535）；

  char 数据类型可以储存任何字符；

  例子：char letter = 'A';。





## 2 包装类

Java语言是一个面向对象的语言，但并不是<u>纯面向对象的语言</u>。基本数据类型不是面向对象的，它们不具有继承性、多态性、封装性。这时，我们就需要利用包装类(Wrapper Class)将基本类型数据转化成引用类型！在实际使用中经常将基本数据类型转换成对象，便于操作，比如，集合的操作中。



> 包装类是属于引用类型，包装类都位于java.lang包下。



**装箱与拆箱：** 

- 装箱：基本类型 --> 包装类对象
- 拆箱：包装类对象 --> 基本类型



**为什么需要装箱与拆箱：**

- 基本类型不可调用方法、属性等对象才有的特性
- 包装类不可直接使用算术运算符，需要先转成基本类型



**基本类型与包装类的对应关系：**

| 基本类型 |      包装类       |
| :------: | :---------------: |
|   byte   |       Byte        |
|  short   |       Short       |
|   int    |  Integer【特殊】  |
|   long   |       Long        |
|  float   |       Float       |
|  double  |      Double       |
|   char   | Character【特殊】 |
| boolean  |      Boolean      |



**自动装箱、自动拆箱：**

从JDK 1.5+开始，支持自动装箱、自动拆箱。

如：

```java
Type var = value;
```



**包装类的缓存机制：**

包装类内部有一个 XxxCache 的静态结构（如：IntegerCache），如果我们自动装箱的范围在：-128~127之间，就会缓存在 XxxCache.cache 这个数组里，
如果再次调用，直接使用缓存中的地址，不会再去 new 了。



**目的：**提高效率。



注意：手动装箱没有缓存（使用new），自动装箱有缓存



## 3 基本类型的自动转换

基本数据类型（除布尔类型外）在某些情况下将发生数据类型自动转换。这些情况包括：赋值运算，数学运算，三目运算，传参等。



**快速记忆：** 数字相关才能玩，运算，传参，不带布尔玩



**自动类型转换（提升）特点：**

1. 代码不需要进行特殊处理，自动完成。
2. 数据范围从小到大自动转变（与字节数无关），所以也叫提升。
3. byte/short/char这三种类型在运算的时候，都默认被先提升成为int类型，然后计算
4. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）



## 4 基本类型的强制转换

向下转换，将数据是从范围大到小的转换。



**格式：** 

```java
（类型）数据
```



**快速记忆：**小小括号能强制，数字相关才能玩，就是不带布尔玩；从小到大很没问题，从大到小要亏损；byte/short/char搞特殊，常量不超范围可省略。



**注意事项：**

1. 不推荐使用，有可能发生精度损失、数据溢出
2. byte/short/char三种类型：如果【常量数据】强制转换为此三种类型，且常量数据【不超过此三种类型范围】，可以省略强制格式——"(类型)"
javac编译器将会自动隐含地补上一个(byte)(short)(char)

3. 只有数字类型（byte/short/int/long/float/double）和char类型（char类型底层也是储存数字）的数据，也就是与 Number 类相关的数据类型，
才可以发生转换（包括自动和强制），而 boolean 类型与数字不相关，不能发生数据类型转换（强制和自动都不行）



## 5 基本数据和String之间的类型转换

```

```

**快速记忆：** 基本转String用valueOf，toString，拼接符号黑科技；String转基本用parse，只有char搞特殊。



### 5.1 **基本类型转String类型**

- String.valueOf(基本类型数据)

  如：

  ```java
  String str1 = String.valueOf((byte) 1);
  ```

- 包装类的toString方法

  如：

  ```java
  String str1 = Byte.toString((byte) 1);
  ```

- 字符串拼接方式

  如：

  ```java
  String str1 = (byte) 1 + "";
  ```



### 5.2 String类型转基本类型

- 包装类的parseXxx(s)方法（不适用于char）

  如：

  ```java
  byte byte2 = Byte.parseByte("1");
  ```

- String --> char

  - 方式一：

    ```java
    char char1 = "A".charAt(0);
    ```

  - 方式二：

    ```java
    char char2 = (char) Integer.parseInt("65");
    ```




## 6 数组

数组是引用数据类型，一种容器，可以同时存放多个数据值。

数组本身不提供任何操作方法，方法全部继承自 Object，如果需要操作数组建议使用 Arrays 工具类。

数组也是一种类，一种特殊的类。



**特殊性：** 数组没有一个class文件（例如Array）来储存数组类的相关属性和方法，所以实创实例过程与常规类不同。

具体原因参考：

- 链接1：https://blog.csdn.net/iteye_3313/article/details/81800350?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-2.nonecase

* 链接2：https://bbs.csdn.net/topics/390943750



**特点：** 

1. 数组只能储存同一种类型数据
2. 数组的长度在程序运行期间不可改变
3. 数组未重写 equals、toString 方法



### 6.1 初始化

**两种常见的初始化方式：**

- 动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。

  **格式：**`数据类型[] 数组名称 = new 数据类型[数组长度];`

  

- 静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。

  - **标准格式：**`数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };`
  - **省略格式：**`数据类型[] 数组名称 = { 元素1, 元素2, ... };`



**注意：**

1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。
2. 初始化格式可以拆分成为两个步骤：声明、初始化。
3. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。



**使用建议：** 如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。



### 6.2 数组长度

数组长度是数组的成员个数，是int类型的整数。 数组长度是 final 类型，数组一旦创建，程序运行期间，数组长度不可改变。



**访问格式：** array.length



### 6.3 数组默认值

使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则与成员变量的默认值一样，如下：

- 整数类型：默认为 0
- 浮点类型：默认为 0.0
- 字符类型：默认为 '\u0000'(一个特殊字符)
- 布尔类型：默认为 false
- 引用类型：默认为 null



**注意事项：** 静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。



### 6.4 数组相关异常

- **空指针异常：**
  所有的引用类型变量，都可以赋值为一个null值。但是代表其中什么都没有。
  数组必须进行new初始化才能使用其中的元素。
  如果只是赋值了一个null，没有进行new创建，
  那么将会发生：空指针异常 NullPointerException

  原因：忘了new
  解决：补上new



越界异常
    数组的索引编号从0开始，一直到“数组的长度-1”为止。
    如果访问数组元素的时候，索引编号并不存在，那么将会发生
    数组索引越界异常
    ArrayIndexOutOfBoundsException

    原因：索引编号写错了。
    解决：修改成为存在的正确索引编号。

# 二、类和对象

 ## 1 类的概述

类（class）是对现实中实体事物的属性和行为的描述，是抽象的，概念上的定义，是一个模板



**类的命名规范：** 大驼峰（MyClass）



**注意事项：**

1. 一个源文件【必有且仅能有】一个与文件名相同的类
2. 一个源文件中仅能有一个 public 类，且 public 类名必须与源文件名一致（原因：为了在import公共类时提高效率）
3. 一个源文件可以有多个非 public 类，可以跟文件名不同，但为了为了便于管理，一般一个源文件放一个类
4. 同一个包（同级目录）下不能有重复名称的类



**面向对象具体实现流程：**

1. 创建类，设计类的变量和方法
2. 创建对象
3. 通过对象的属性和方法，来调用对象结构



### 1.1 对象

对象（instance）是实际存在的个体，有状态和行为，也称为实例。对象是解决问题的最终工具。



**对象的命名规范：** 小驼峰（myInstance）



**判断对象的值与址的相等性：**

1.  == ：参考 \src\运算符\双等号
2.  equals：参考 \src\常用类.Object类\equals
3.  Objects.equals：参考 \src\常用类.Object类\Objects工具类\Equals



#### 1.1.1 创建对象

 创建对象也叫类的实例化，或实例化类。

**格式：**

```sql
类型 对象名 = new 类(参数列表);
```



#### 1.1.2 匿名对象

创建对象没有显式地赋给一个变量名，即为匿名对象。

如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。

> 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。



**示例：**

```java
new Person("张三", 30).tell();
```





### 1.2 this关键字

**使用格式：** 

```java
类名.this // “类名”省略代表当前类下的this
```

**作用：**

- 充当当前实例对象，用于访问实例的成员变量\方法，如：this.field/this.method()
    **注：**当与成员变量或形参不重名的情况下，this可以省略

- 充当本类的构造函数，用法：this()\this(...)
    **注：**

  1. 只允许在构造器的第一行代码执行
  2. 一个构造器中只允许执行一个其他构造方法
  3. 只允许调用其他构造器
  4. 构造器不允许循环调用

  

**注意：** 静态方法、静态代码块中不能使用this，因为实例对象还没生成



## 2 类的成员

类的成员包括**变量**（属性、域、字段、field）、**方法**（行为、函数、method）、**代码块**（初始化块、block）。

面向对象的设计重点是类的设计，而设计类重点则是<u>设计类的成员</u>。



**类的成员分类：**

- 变量
- 方法
- 构造器
- 类
- 接口
- 代码块

> 以上每种都可分为静态（类成员）与非静态（实例成员）。



### 2.1 成员变量



与局部变量不同，成员变量有默认值，不同类型的成员变量有不同的默认值（与数组一致）。

**成员变量的默认值：**

- 整数类型：默认为 0
- 浮点类型：默认为 0.0
- 字符类型：默认为 '\u0000'(一个特殊字符)
- 布尔类型：默认为 false
- 引用类型：默认为 null



**就近原则：**当方法的<u>局部变量</u>和类的<u>成员变量</u>重名的时候，根据“就近原则”，优先使用局部变量。



**成员变量赋值的先后顺序：**

1. 默认初始化
2. 显式赋值
3. 构造器赋值
4. 通过“对象.方法”或“对象.属性”赋值

> 注：123只执行一次，4可以反复执行）



**实例变量、静态变量、局部变量的对比:**

1. 定义的位置不一样【重点】
    成员变量：定义在类中
    局部变量：定义在方法（包括构造器）中、方法（包括构造器）形参、代码块

2. 作用范围不一样【重点】
   成员变量：整个类全都可以通用。
   局部变量：只有方法当中才可以使用，出了方法就不能再用

3. 默认值不一样【重点】
   成员变量：如果没有赋值，会有默认值，规则和数组一样
   局部变量：没有默认值，如果要想使用，必须手动进行赋值

4. 内存的位置不一样
   实例变量：位于堆内存，跟着实例对象走，new的时候创建
   静态变量：位于方法区（静态域），跟着类走
   局部变量：位于栈内存，跟着方法走，方法进栈，局部变量创建

5. 生命周期不一样
   实例变量：随着实例对象创建而诞生，随着实例对象被垃圾回收而消失。所以实例变量生命周期就是实例对象的开始和销毁。
   静态变量：随着类声明而诞生，随着类被垃圾回收而消失。所以静态变量生命周期就是类的开始和销毁。
   局部变量：随着方法进栈而诞生，随着方法出栈而消失。所以局部变量生命周期就是方法的开始和销毁。

6. 权限修饰符的不同
   成员变量不可用权限修饰符



**成员常量：**可算做不可变的成员变量，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 2.2 成员方法



### 2.3 构造器

构造器（Constructor/构造方法/构造函数）是专门用来创建对象的特殊方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。



**作用：**

1. 创建对象

2. 初始化对象信息



**格式：**

```java
权限修饰符 构造器名(参数列表) {
   ...
}
```

**构造器与成员方法的区别：**

       1. 构造方法的名称必须和所在的类名称完全一模一样
       2. 构造方法不写返回值类型，连void都不写，也不能 return
       3. 构造方法用于创建对象，并进行初始化值；普通成员方法是用于完成特定功能的。
       4. 构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数；普通成员方法是由创建好的对象调用，可以调用多次

> 注：构造器可以看作特殊的成员方法



**注意事项：**

1. 如果没有编写任何构造方法，那么编译器将会默认创建一个空的构造方法（没有参数、方法体什么事情都不做，即：public Student() {}）
2. 默认提供的构造器的权限修饰符与类相同
3. 一旦显式定义一个构造方法，那么编译器将不再默认创建
4. 构造方法允许重载。（重载：方法名称相同，参数列表不同）
5. 一个类至少有一个构造器，创建一个对象的时候，至少要调用一个构造器
6. 构造方法允许被各种权限修饰符修饰



### 2.4 代码块

代码块也叫初始化块。

**分类：**
       1. 非静态代码块（实例）
       2. 静态代码块



**执行顺序：**

1. 静态代码块先于非静态代码块执行

2. 同一类的多个代码块按**声明顺序**执行（一般不会声明多个代码块）



#### 2.4.1 非静态代码块

**声明格式：**

```java
{
    ...
}
```

**用途：** 给实例属性初始化

**执行时间：** 每次<u>创建实例</u>时候都会执行一次

**创建实例时，实例结构的执行顺序：**

1. 默认初始化
2. 显式初始化/非静态代码块执行
   注： 显式初始化和（实例）代码块执行是同一级别的，谁在前谁先
3. 构造器初始化
4. 通过"对象.属性"或“对象.方法”去赋值



#### 2.4.2 静态代码块

**声明格式：**

```java
static {
    ...
}
```

**用途：** 给静态变量初始化

**执行时间：** 每次<u>加载类</u>的时候都会执行一次

**加载类时，静态结构的执行顺序：**

1. 默认初始化
2. 显式初始化 / 静态代码块执行
   注： 显式初始化和静态代码块执行是同一级别的，谁在前谁先
3. main方法执行



**注意：**

1. 静态代码块类只能调用静态结构
2. 继承的时候先需要加载父类，所以父类的静态代码块也会先执行



### 2.5 成员类、成员接口

成员类是内部类的一种，具体可参考[7.1 成员内部类](#7.1 成员内部类)。

成员接口与成员类类似。



### 2.6 静态成员

static 修饰符可用于修饰类的成员（变量和方法，以及内部类），被修饰的统称为为静态成员。



**什么时候使用静态的：**

1. 不会随着对象改变而变的成员
2. 操作静态属性的方法
3. 工具类的方法，习惯用静态的（比较省事，不用创建对象，如Math、Arrays）
4. 常量（final）习惯用静态的



**访问格式：** 类.静态变量\方法\类

**静态成员内存位置：** 位于静态域（方法区）

**特点：**

1. 节省内存空间
2. 共享性



**注意事项:**
   1. 静态成员属于所在的类，非属于实例对象
   2. 静态成员被同一类的实例对象可以共享
   3. 静态成员可直接通过类访问，不需要创建实例就可使用
   4. 静态先于实例对象存在，所以静态方法中不可用实例变量、实例方法、this、super关键字，但可以访问其他静态成员
   5. 实例方法可以访问静态成员
   6. 实例成员和静态成员的名称不允许重复
   7. 静态方法可以被继承，可以被重载，可以被隐藏（隐藏其实相当于重新声明），但不能被重写



## 3 JavaBean

JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定。



**约定：**
1. 所有的成员变量私有化（private）
2. 私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范
3. 必须具有一个公共的(public)无参构造函数
4. 这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）



## 4 类的继承

继承（extends）就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。



**书写格式：**

```java
修饰符 class 子类名 extends 父类名 {
    
}
```



**作用：**共性抽取

**特性:**

1. 子类拥有父类<u>所有的属性和方法</u>

2. 子类可以在父类的基础上进行修改和扩展，方式是重写、重载、隐藏

3. 父类的private属性和方法也是可以被继承的，只是子类拥有但无法访问（封装性）；不能直接访问，但可以间接通过非private的父类方法进行访问。

4. Java 的继承是【单继承】，但是可以【多重继承】。单继承是一个子类只能继承一个父类（只能有一个父亲），多重继承就是子类也可以当父类（传代），例如 A 类 -> B 类 -> C 类

   > 注：A 类 -> B 类 -> C 类，B为C的直接父类，A为C的间接父类

5. 继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）

6. 继承是多态的前提

7. 所有类继承的最顶级对象是java.lang.Object，Object是祖先类，Object在 java.lang 包中，所以不需要 import

8. 当访问实例对象的成员变量或方法时，则优先寻找本类当中是否存在，若有则用，无则向上（父类）寻找，不会向下（子类）寻找

9. 若需访问父类与子类的重名成员变量时，可通过super访问



### 4.1 super关键字

我们可以通过super关键字来实现对父类成员的访问，相当于父类的this，指向父类实例。



**使用格式：** 

```java
类名.super // "类名"省略代表当前类的super
```



**作用：**

1. super可以指向父类的this，现对父类成员的访问，用来访问父类的成员变量和方法

2. 可以充当父类的构造函数



**使用注意事项：**

1. 只能在子类构造函数中执行
2. 跟this一样，只能作为第一个语句执行，因此一个代码块中，super和this只能调用一个一个构造函数只能执行一次super

3. 子类所有的构造器第一行都会默认隐式地执行父类的无参构造器（super()），手动显式地执行super()或this()，则替代默认的super()
4. 子类的构造器中，第一行不是执行this()，就是执行super()，而至少有一个子类构造器执行super()，而至多有n-1个this()
5. 每个子类的构造器都会直接或间接调用父类构造器，所以当执行某类的构造器的时候，一定会把它所有父类的构造器都执行一遍，直到Object的构造器，这便是继承的过程。注意：但只创建一个对象，即new的那个类的对象



## 5 重写、重载、隐藏

**重载与重写对比：**

- 重写（Override）：方法的名称、形参列表<u>要求一样</u>；访问权限、返回值类型<u>要求兼容</u>；其他无关；用于子类覆盖父类方法。

  > 记忆：替代

- 重载（Overload）：方法的名称<u>要求一样</u>；形参列表<u>要求不一样</u>；其他无关；用于对不同的传参进行不同的处理情景，可对本类或父类的方法重载。

  > 记忆：新增一种实现方式



### 7.1 方法重写

方法重写（覆盖/覆写/Override/Overwrite）是子类对父类的允许访问的【实例方法】的实现过程进行重新编写，返回值和形参都不能改变。

<u>即外壳不变，核心重写！</u>



**书写格式：**

```java
@Override
修饰符 类型 方法名 (参数列表){
    ...
}
```

> 注解@Override 写在方法前面，可用来检测是不是有效的正确覆盖重写（可写可不写）



**作用：** 重写的作用在于子类可以根据业务需要，重定义方法的行为，也就是说子类能够根据需要实现父类的方法。



**要求：**

1. 方法的名称、参数列表（类型\个数\顺序）必须相同

2. 返回值类型：如果父类返回值为引用类型，则子类重写方法的返回值必须【小于等于】父类的；如果父类返回值为基本类型或void，则子类必须返回跟父类一模一样的

3. 访问权限：子类重写方法必须【大于等于】父类方法

   > 访问权限：public > protected > (default) > private

4. throws类型：子类重写方法必须【小于等于】父类方法，如果父类没有声明throws，则子类也不能声明



**注意事项：**

1. 重写只能是子类对父类（祖先类）的重写，不能是对本类或子类方法的重写
2. 声明为 final 的方法不能被重写。
3. private方法无法被重载、重写，因为子类无法访问父类的private成员
4. 父类静态方法可以被继承，可以被重载，可以被隐藏，但不能被重写（隐藏只是形式上的重写，并不满足多态的特征，所以严格说不是重写）
5. 重写只能适用于【实例方法】，不能用于静态方法，对于静态方法,只能隐藏



### 7.2 方法重载

方法重载（Overload）是指在同一个类中定义多个同名的方法，要求每个方法具有不同的形参的类型\个数\顺序，保证每个重载的方法都必须有一个独一无二的参数列表。



**作用：** 对不同的传参进行不同的处理

**方法重载与下列因素相关：**

1. 参数个数不同
2. 参数类型不同
3. 参数的多类型顺序不同



**方法重载与下列因素无关：**

1. 与形参的名称无关
2. 与方法的返回值类型无关
3. 与方法的修饰符无关



**注意：**

1. 重载可以对本类方法的重载，也可以是子类对父类的方法进行重载，但不能是本类对子类的重载
2. private方法无法被重载、重写，因为子类无法访问父类的private成员



### 7.3 隐藏

隐藏是指子类的成员变量（包括实例变量和静态变量）和静态方法与父类的命名一样，访问子类的这些变量和方法的时候就只会访问子类的，而父类的被隐藏。若子类没有，再去访问父类的。



## 6 抽象类和抽象方法

**关键字：** abstract



###　6.１ 抽象类

如果一个类没必要实例化，仅提供一些结构供子类去实例化，其中没有包含具体的信息来描绘一个具体的对象，这样的类就是抽象类。

类的继承当中，结构会越来越具体，而上层的父类往往需要更通用，且没必要实例化，因此便有了抽象类。

抽象类就是用来继承的，继承过程中去重写抽象方法，



**声明格式：**

```java
权限修饰符 abstract class {
    ...
}
```



**注意：**

1. 抽象类不能直接实例化，必须被继承，才能够使用
2. 抽象类虽然不能实例化，但仍需要<u>构造器</u>，供子类调用
3. 没有任何抽象方法的抽象类有特殊作用（？？？）
4. 抽象类在继承方面没有限制——抽象类可以被抽象类、普通类继承，抽象类也可以继承抽象类、普通类
5. 抽象类也可以多态
4. final类不可被继承，而抽象类必须要被继承，所以抽象类不能被final修饰



### 6.2 抽象方法

抽象方法就是为了子类重写而存在，该方法的具体实现由它的子类确定，所以不需要方法体。



**声明格式：**

```java
[权限修饰符] abstract 返回类型 方法名 (参数列表); -- 权限修饰符缺省，默认为public
```



**注意：**

1. 抽象方法只能声明在抽象类中，且只有声明，没有方法体
2. 有抽象方法的类必定是抽象类，抽象类中不一定包含抽象方法
3. 子类必须覆盖重写抽象父类当中所有的抽象方法，除非该子类也是抽象类，否则报错
6. 静态方法（static）、私有方法（private）、final方法不可被重写，这些都与抽象冲突，不可用于修饰抽象方法



## 7 内部类

将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。

### 7.1 成员内部类

内部类作为一个外部类的成员存在。



**用途：** 当一个事物（人）需要一个完整的结构（大脑）去描述，而这个结构只需要对这个事物提供服务，那么这个结构最好使用内部类。

**分类：**

- 非静态成员内部类
- 静态成员内部类



**注意：**内部类的 this 指向内部类实例，若要在内部类中使用外部类的 this，则用：【外部类.this】。



#### 7.1.1 非静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
```



#### 7.1.2 静态成员内部类

**实例化格式：** 

```java
外部类名称.内部类名称 对象名 = new 外部类名称.内部类名称();
```





### 7.2 局部内部类

定义在方法、构造器、代码块内部的类。



**注意事项：**

1. 局部内部类只能在该方法内访问，方法外无法访问
2. 局部内部类不允许使用权限修饰符（public，default...），因为没有意义，它只能在方法内访问
3. 局部内部类只能通过所在的方法去使用



**局部内部类访问该方法内的局部变量的情况：** 

1. 该变量必须是【final】的，原因：因为局部变量是跟方法走的，而局部内部类是new出来的，是在堆中的，两者声明周期不同，所以局部变量必须不变
2. 从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略



#### 7.2.1 匿名内部类

匿名内部类也是局部内部类的一种，也只能定义是方法、构造器、代码块内部。

他常用于继承和实现中，当一个<u>子类</u>或<u>实现类</u>只使用一次时，可以使用匿名类快捷方便地创建实例。



**格式：**

```java
// 继承
父类名称 对象名 = new 父类名称(){
	// 匿名内部类（子类）
	// 这里书写子类的内容
};

// 实现
接口 对象名 = new 接口(){
	// 匿名内部类（实现类）
    // 这里书写实现类的内容
};
```



## 8 final类与final成员

### 8.1 final类

final类不可被继承（太监类），成为最终类，被继承会报错。



**注意事项：**

1. final类没有子类，但有父类（任何类都有父类，除了Object）
2. 既然没有继承，也就没有所谓的子类对父类的成员覆盖、重载
3. final类一样可以对它的父类成员进行重写、重载
4. abstract 和 final 互相矛盾（abstract 类一定要被继承，final 类不可被继承），不能同时使用



### 8.2 final成员

#### 8.2.1 成员常量

成员常量即加final的变量。

成员常量，不可用默认值，所以必须赋值一次（初始化），且不可再变。

赋值的位置有：显式赋值，构造器赋值，代码块赋值。（方法中赋值不可行，太晚了）。



**命名格式：**全大写，底杠分割，如：MY_NAME



**静态常量：**用 static final 修饰的成员变量。可当作**全局常量**。



**注意：**子类可以隐藏（覆盖）父类的成员常量



#### 8.2.2 final方法

**分类：**

- 静态final方法
- 非静态final方法



**注意：** 

1. abstract 和 final 互相矛盾（abstract 方法一定要被重写，final 方法不可被重写），不能同时使用
2. final方法不可被重写、隐藏，但可以被重载。



## 9 对象的序列化和反序列化

在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。但是，我们创建出来的这些对象都存在于JVM中的堆（heap）内存中， 只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止，这些对象也就随之消失；但是在真实的应用场景中，我们需要将这些对象持久化下来，并且在需要的时候 将对象重新读取出来，Java的序列化可以帮助我们实现该功能。

对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将对象的状态信息保存未字节数组，并且可以在有需要的 时候将这个字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。在JAVA中，对象的序列化和反序列化被 广泛的应用到RMI（远程方法调用）及网络传输中。



**定义一个可序列化的类的步骤：**

1. 继承Serializable接口
2. 声明全局常量：serialVersionUID

> 注意：如果内部属性有其他对象，这些对象也必须是可序列化的，否则该类无法可序列化



**serialVersionUID：**

简单来说，JAVA序列化的机制是通过判断类的serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID于本地相应实体类 的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。

serialVersionUID有两种显示的生成方式：

1. 是默认的1L，比如：private static final long serialVersionUID = 1L;
2. 是根据包名，类名，继承关系，非私有的方法和属性，以及参数，返回值等诸多因子计算得出的，极度复杂生成的一个64位的哈希字段。基本上计算出来的这个值是唯一的。 比如：private static final long serialVersionUID = xxxxL;

> 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明。


**注意**

1. static和transient修饰的成员变量无法序列化



# 三、接口

接口（Interface），是Java语言中一种引用类型，是方法的集合，是多个类的公共规范。

如果说类的内部封装了成员变量、构造方法和成员方法， 那么接口的内部主要就是封装了方法，其中最重要的就是的：**抽象方法**。

编写接口的方式和类很相似，但是它们属于不同的概念，接口与类是并列的两个结构。

接口是隐式抽象的。



**特性：**

- 多重实现：类只能单继承，但允许同时可以实现多个接口
- 多重继承：接口允许同时继承多个父接口



**接口与类的不同之处：**

1. 类描述对象的<u>属性和方法</u>，接口则包含类要实现的<u>方法</u>
2. 接口不能实例化（没有构造函数），同过<u>实现</u>发挥效用；类通过实例化发挥效用
3. 接口里的所有的方法必须是<u>抽象方法</u>
4. 接口支持<u>多继承，多实现</u>，而类只支持<u>单继承</u>。
5. 接口不能包含成员变量、构造方法、代码块



**接口与类的相同之处：**

1. 与类一样，接口文件保存在.java 结尾的文件中，文件名使用接口名
2. 与类一样，接口的字节码文件保存在 .class 结尾的文件中
3. 与类一样，接口也具有多态性
4. 与类一样，接口也可以包含常量、抽象方法、默认方法、静态方法、私有方法



**不同版本Java，接口包含的内容：**

- Java 7：
  - 常量
  - 抽象方法
- Java 8：
  - 默认方法
  - 静态方法
- Java 9：
  - 私有方法



**标识接口：**标识接口是<u>没有任何方法和属性</u>的接口。标识接口不对实现它的类有任何语义上的要求，它仅仅表明实现它的类属于一个特定的类型。如Serializable接口。



## 1 定义接口

**书写格式：**

```java
权限修饰符 [abstract] interface 接口名称 {
    // 接口内容
}
// 接口是隐式抽象的，所以[abstract]可省略
```



**接口的命名规范**： 大驼峰（MyInterface）





**接口和抽象类相似之处:**

1. 接口和抽象类都不能被实例化。
2. 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。



1. 接口里只能包含抽象方法、静态方法和默认方法，不能为普通方法提供实现，而抽象类可以。
2. 接口里只能定义常量，不能定义普通成员变量，抽象类则可以。
3. 接口里不包含构造器;抽象类可以包含构造器，但抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
4. 接口里不能包含初始化块;但抽象类则完全可以包含初始化块。
5. 一个类最多只能有一个直接父类（包括抽象类）;但一个类可以实现多个接口，通过实现多个接口可以弥补Java单继承的不足。





## 2 实现接口

接口不能直接使用，必须有一个“实现类”来实现该接口。接口支持多重实现，即：一个“实现类”可以同时实现多个接口。

> 如果实现类没有重写接口中<u>所有的抽象方法</u>，该实现类必须定义成<u>抽象类</u>



**关键字：** implements



**书写格式：**

```java
// 实现，支持多重实现
权限修饰符 class 实现类名称 implements 接口名称1[, 接口名称2, 接口名称3, ...] {
     ...
 }
```



**多重实现时，接口成员重复情况：**

1. 静态方法不会被继承，只通过接口自身调用，所以**不用管重复**
2. 私有成员不会被出现在实现类当中，所以**不用管重复**
3. 常量（静态变量）重复，只能通过接口调用；或者实现类中重声明隐藏接口常量，才可以类和实例调用
3. 抽象方法重复，实现类**只需重写一次**
4. 默认方法重复，实现类**必须重写**





**类同时继承，并实现接口情况：** 继承优先于实现，父类优先于接口

```java
// 顺序：先继承，后实现
权限修饰符 class ClassA extends ClassB implements Interface1[, 接口名称2, 接口名称3, ...] {
    ...
}
```



**当继承与实现成员重复时：**

1. 抽象方法同名同参数：子类只需重写一次
2. 普通（默认）成员方法同名同参数：父类优先于接口
3. 静态方法同名同参数：父类优先于接口
4. 静态变量同名：引用不明确，子类不会继承

> 当出现命名冲突时，子类就必须重写或重声明



## 3 接口继承

一个接口允许同时继承多个父接口，即多重继承。



**关键字：** extends



**书写格式：**

```java
// 继承，支持多重继承
权限修饰符 Interface extends Interface1[, Interface2, Interface3...] {
    ...
}
```



**多重继承时，父接口成员重复情况：**

1. 父接口抽象方法重复：子接口不必重写，但实现类中必须重写
2. 父接口默认方法重复：子接口必须重写，实现类不必重写
3. 父接口静态方法重复：静态方法只通过接口自身调用，所以不用管重复（接口的静态方法不会被继承）
4. 父接口常量（静态变量）重复，只能通过父接口调用；或者子接口中重声明隐藏接口常量，才可以在子接口、类、实例调用



## 4 接口成员

接口成员包含：抽象方法、常量、默认方法、私有方法、静态方法。而其中抽象方法是最重要的。



### 4.1 抽象方法

接口最重要的内容就是其中的：抽象方法。



**格式：**

```java
[public abstract] 返回值类型 方法名称(参数列表);// [public abstract]可省略
```



**注意：**

1. 接口中的方法是隐式抽象的，声明时可以省略 abstract 关键字

2. 接口中的抽象方法必须是公有的，权限修饰符必须是public的，所以可以省略 public 关键字

   

### 4.2 常量

接口定义常量必须使用 public static final 三个关键字进行修饰，所以也可省略。



**格式：**

```java
[public static final] 数据类型 常量名称 = 数据值;
```



**命名格式：**全大写，底杠分割，如：MY_NAME



**注意：**

1. 常量，必须进行赋值

2. 常量会被实现类继承，变成类的静态变量（注意：静态方法不会被继承，这是区别）
3. 常量可以被隐藏
4. 常量可以接口直接调用，也可以实现类调用，也可以实例调用（除了多重实现时重复，只能接口调用）（重点）

>  基本与类的成员常量类似，参考[8.2.1 成员常量](#8.2.1 成员常量)



### 4.3 私有方法

私有方法用于接口内部的代码封装。

> 从Java 9开始支持



**格式：**

```java
private [static] 返回值类型 方法名称(参数列表) {
	...
}
```



**注意：**私有方法只在接口内部可见，与外部无关，不会被实现类继承。



### 4.4 静态方法

> 从Java 8开始支持



**格式：**

```java
[权限修饰符] static 返回值类型 方法名称(参数列表) {
    ...
}
// 权限修饰符默认为public，可以省略
```



**注意：**

1. 接口的静态方法不会被继承（这点与类不同），只存在接口自身中，当然也没有重载、重写、隐藏（重点）
2. 权限修饰符默认为public，可以省略（这点与类不同）
3. 静态方法只能通过接口自身调用，格式：接口.静态方法()



### 4.5 默认方法

**用途：** 接口当中的默认方法，常用来解决接口升级的问题;若是升级时添加的是抽象方法，老代码因未重写报错，而默认方法不会



> 从Java 8开始支持



**格式：**

```java
[权限修饰符] default 返回值类型 方法名称(参数列表) {
    ...
}
// 权限修饰符默认为public，可以省略
```



**注意：**

1. 默认方法会被实现类的继承作为实例方法
2. 可继承，可重写，可重载



## 5 函数式接口



# 四、多态

多态是继封装、继承之后，面向对象的第三大特性。多态（Polymorphism）是指同一操作，作用于不同的对象，可以有不同的解释，产生不同的执行结果。现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。比如跑的行为，小猫、小狗和大象，跑起来是不一样的。

Java中，多态就是同一个接口，使用不同的实例而执行不同操作。

多态的使用体主要现在<u>虚拟方法</u>的调用。



**含义：**

父类的引用指向子类对象，或子类对象赋给父类引用。多态本身就是<u>向上转型</u>过的过程，是小范围到大范围的转变。把子类单做父类使用，只能使用继承自父类的成员，不能使用子类特有的成员。例如：把某只猫当作动物而不是猫来看待，它具备动物的属性，但不能使用猫特有的属性。



**多态存在的三个必要条件：**

1. 继承或者实现【二选一】

2. 方法的重写【不重写，无意义】

3. 向上转型



**多态的转型：**多态的转型分为<u>向上转型</u>和<u>向下转型</u>两种



**多态的优点：**

1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性



**多态体现的格式：**

```java
父类名称 对象名 = new 子类名称();
// 或者：
接口名称 对象名 = new 实现类名称();
```



**口诀：** 编译看左边，运行看右边



**使用多态成员看两个方面：**

1. 有没有：看类\接口是否有这个成员（继承来的也算）

2. 从哪找：从哪个类开始往上查找

> 先看有没有，没有则报错，有则再看从哪找



**多态成员变量和多态成员方法调用规则不一样：**

1. 使用多态成员方法：有没有看左边，从哪找看右边

2. 使用多态成员变量：有没有、从哪找都看左边（因为属性不存在多态性）

> 通过get方法间接访问成员变量，跟成员方法的规则一致



**虚拟方法 （虚方法\virtual method）：**在多态的情况下，将父类的方法称为虚拟方法，父类根据赋给他不同的子类对象，动态地调用子类的该方法，这些方法在编译期是无法确定的，只有运行时才能确定。



**注意事项：**

1. 多态对象堆内存中仍然有子类特有的成员，但是因为类型是父类的，所以无法调用，需要向下转型才能调
2. 多态是动态绑定（运行时），重载是静态绑定（编译时）
3. 多态性体现在成员方法上，不体现在属性上



## 1 向上转型

父类引用指向子类对象，把子类当做父类使用，只能使用父类有的成员，不能使用子类特有的成员。例如：把猫当作动物来看待，可以使用动物有的属性，但不能使用猫特有的属性。

类似于自动类型转换：`double num = 100;// int -> double`，范围小 -> 范围大，自动类型转换



**适用场景：** 当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。



**格式：**

```java
Fu fu = new Zi();
```



**向上转型注意事项：**

1. 向上转型是小范围到大范围的转变
2. 向上转型一定是安全的，许可的
3. 优点是：左边代码可以统一
4. 缺点是：不能调用子类特有的内容。解决方案是：向下转型





## 2 向下转型

向下转型是向上转型的还原动作。

向上转型之后，把对象还原为原有类型，向下转型成功后又可以使用子类特有的内容。

例如：把猫上转型为动物来看待后，还原为猫，又可以使用猫的特有属性了。

适用场景： 当要使用子类特有功能时。



**格式：**

```java
Zi zi = (Zi)fu;
```



**类似于：**

```JAVA
int num = (int) 100.0;// 可以
int num = (int) 100.5;// 精度损失
```



**向下转型注意事项：**

1. 向下转型是大范围到小范围的转变

2. 向上转型是安全的，但向下转型是有风险的
3. 【前提条件】：必须先多态（向上转型），才能向下转型，而且只能转为原有类型，若转为其他类型，则编译通过，运行报错，
   报ClassCastException（猫只能还原为猫，不能还原为狗）。所以向下转型前先用 instanceof 判断。



# 五、泛型

泛型（Generic），即“参数化类型”。顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用/调用时传入具体的类型（类型实参）。

泛型提供了编译时<u>类型安全检测机制</u>，该机制允许程序员在编译时检测到非法的类型。 泛型的引入加强了参数类型的安全性，减少了类型的转换。

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。



**泛型结构：**

- 泛型类
- 泛型接口
- 泛型方法



**特性：**

1. 泛型只在编译阶段有效



## 1 泛型参数

所有泛型都有一个类型参数声明部分，写在尖括号中，如。泛型参数也可叫叫做：类型参数、泛型变量、类型变量。 此处T可以随便写为任意标识，常见的T、E、K、V等大写字母。多个泛型参数用逗号隔开，写做：<T,E,K,V>。



**特性：**

1. null 符合所有泛型参数
2. 若泛型参数未传入，默认是Object类型
3. 泛型参数必须是**引用类型**，不能是基本类型



## 2 泛型结构

### 2.1 泛型方法

泛型方法中，类型传入的时间点： 在方法<u>被调用的时候确定类型</u>，通过实参的类型来来确定。



**声明格式：**

```java
修饰符 <T> returnType methodName (param){
	...
}
```



**类型传入的时间点：**在方法<u>被调用的时候确定类型</u>，通过实参的类型来来确定。

**类型传入格式：**

```java
methodName(param);// 与普通的方法调用无分别
```



**注意事项：**

1. 方法上泛型的差异不构成重载



### 2.2 泛型类

泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。



**声明格式：**

```java
class GenericClass<T>{
	...
}
```



**类型传入的时间点：** 在类被<u>实例化、继承</u>的时候确定类型

> 注意：泛型类（父）被继承时，可选择完全确定父类类型（参考SubClass1），或者完全保留父类类型，让子类实例化的时候确定类型（参考SubClass2），或者部分保留、部分确定父类类型（参考SubClass3）， 或者擦除父类类型（参考SubClass4）

**类型传入格式：**

```java
// 1.无变量接收
new ClassName<Type>();

// 2.有变量接收
ClassName<Type> Var = new ClassName<Type>();
// 注：JDK7.0 以后，增加类型推断，后面的泛型参数可省略，即：ClassName<Type> Var = new ClassName<>();
// 但后面的尖括号<>不可省略，省略了<>等于不使用泛型。
```



**注意事项：**

1. 类中的非静态成员可以访问并使用类定义的泛型参数，静态成员不可访问
2. 类成员定义的泛型参数优先级大于类定义的泛型参数，若重复，定义的泛型会覆盖类的泛型参数
3. 不同泛型参数的引用不能互相赋值，参考例test3
4. 静态方法不能使用类的泛型，但可以有自己的泛型，因为静态方法加载时，泛型有可能还未传入（实例化）
5. 泛型类是无法继承自 Throwable 类（包括异常类（Exception\Error）），即异常类等不能使用泛型，
	参考：https://blog.csdn.net/ziwang_/article/details/56288597
6. 泛型只是变量，泛型不能充当类直接拿来创建（new），new后面只能是具体的类，但是可以作为类型强转的变量，参考例test4



### 2.3 泛型接口

**声明格式：**

```java
修饰符 interface interfaceName<T> {
	...
}
```



**类型传入的时间点：** 在接口被<u>实现</u>的时候确定类型

**类型传入格式：**

```java
修饰符 class ClassName implements interfaceName<Type> {
	...
}
```



## 3 类型擦除机制

Java的泛型在编译阶段实现，<u>在运行期被删除</u>。编译器生成的字节码在运行期间并不包含泛型的类型信息。



**在编译后所有的泛型类型都会做相应的转化，转化如下：**

```java
List<String>、List<T> 擦除后的类型为 List。
List<String>[]、List<T>[] 擦除后的类型为 List[]。
List<? extends E>、List<? super E> 擦除后的类型为 List<E>。
List<T extends Serialzable & Cloneable> 擦除后类型为 List<Serializable>。
```



**jvm如此操作的原因：**

1. 如果把类型信息保留到运行时，需要做大量的重构工作
2. 兼容原生的老版本类型



**注意:**

1. 泛型的class对象时一样的，类型擦除不会改变class属性:

   ```java
   List<String> t1 = new ArrayList<String>();
   List<String> t2 = new ArrayList<Integer>();
   System.out.println(t1.getclass() == t2.getclass());
   ```

   

2. 泛型数组初始化时不能声明泛型类型

   ```java
   List<String>[] list = new List<String>[];
   ```

   在这里可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操作后，相当于List[Object] list = new List()[];编译器拒绝如此声明,所以提前报错，不允许到jvm那一边，java实现的是伪泛型。

   

3. instanceof 不能带泛型参数:

   ```java
   List<String> list = new ArrayList<String>();
   System.out.println(list instanceof List<String>);
   ```

   jvm编译后会丢失信息，所以编译器不允许这么做，因为要是这么做，在运行时候会出问题。实际上list是一个实例，但是丢失类型后无法判断。



# 六、反射

Reflection（反射）是被视为<u>动态语言</u>的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

加载完类之后，在堆内存的方法区中就产生了一个<u>Class类型的对象</u>（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。

通俗地讲，有一个运行时的未知的对象，我们可以通过反射，来知道这个对象对应的类，类的属性、方法等成员，以及调用这些方法、或设置这些属性等操作。

> 注意：Java不是动态语言，但Java可以称之为“准动态语言”，即Java有一定的动态性，就是因为我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！



**Java反射机制提供的功能：**

- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时获取泛型信息
- 在运行时调用任意一个对象的成员变量和方法
- 在运行时处理注解
- 生成动态代理



## 1 java.lang.Class

java.lang.Class类是Java反射的源头。

在Object类中定义了以下的方法：`public final Class getClass()`，此方法将被所有子类继承。此方法返回值的类型是一个Class类型的对象。

程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为<u>**类的加载**</u>。加载到内存中的类，我们就称为**运行时类**，此运行时类，就作为Class的一个实例。

换句话说，<u>Class的实例就对应着一个运行时类。</u>

加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类（Class对象）。

对于每个类而言，JRE 都为其保留一个不变的 Class 对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。



**注意：**

- Class本身也是一个类
- Class 对象只能由系统建立对象
- 一个加载的类（运行时类）在 JVM 中只会有一个Class实例
- 一个Class对象实例（运行时类）对应的是一个加载到JVM中的一个.class文件
- 每个类的实例都会记得自己是由哪个 Class 实例所生成
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象



**Class对象的常用方法：**

- static Class forName(String name) 返回指定类名 name 的 Class 对象
- Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例
- getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称
- Class getSuperClass() 返回当前Class对象的父类的Class对象
- Class [] getInterfaces() 获取当前Class对象的接口
- ClassLoader getClassLoader() 返回该类的类加载器
- Class getSuperclass() 返回表示此Class所表示的实体的超类的Class
- Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组
- Field[] getDeclaredFields() 返回Field对象的一个数组
- Method getMethod(String name,Class … paramTypes)返回一个Method对象，此对象的形参类型为paramType



**哪些类型可以有Class对象？**

- class： 外部类（包含Class自身），成员(成员内部类，静态内部类)，局部内部类，匿名内部类
- interface：接口
- []：数组
- enum：枚举
- annotation：注解@interface
- primitive type：基本数据类型
- void



## 2 类的加载过程

![ ](file:///E:/Desktop/myJavaStudy/JavaBase/src/%E5%8F%8D%E5%B0%84/%E6%88%AA%E5%9B%BE/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B1.png)

1. 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。 
2. 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。
   - 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题
   - 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 
3. 初始化：
   - 执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 
   - 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 
   - 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步



**什么时候会发生类初始化？**

1. 类的主动引用（一定会发生类的初始化）

    

   - 当虚拟机启动，先初始化main方法所在的类 
   - new一个类的对象
   - 调用类的静态成员（除了final常量）和静态方法
   - 使用java.lang.reflect包的方法对类进行反射调用
   - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类

2. 类的被动引用（不会发生类的初始化）

    

   - 当访问一个静态域时，只有真正声明这个域的类才会被初始化
   - 当通过子类引用父类的静态变量，不会导致子类初始化
   - 通过数组定义类引用，不会触发此类的初始化
   - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

   

**类加载器的作用**

![ ](file:///E:/Desktop/myJavaStudy/JavaBase/src/%E5%8F%8D%E5%B0%84/%E6%88%AA%E5%9B%BE/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B2.png)

- 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。
- 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。



**类加载器ClassLoader**

![ ](file:///E:/Desktop/myJavaStudy/JavaBase/src/%E5%8F%8D%E5%B0%84/%E6%88%AA%E5%9B%BE/ClassLoader.png)

1. 获取一个系统类加载器

   ```java
   ClassLoader classloader = ClassLoader.getSystemClassLoader();
   System.out.println(classloader);
   ```

2. 获取系统类加载器的父类加载器，即扩展类加载器

   ```java
   classloader = classloader.getParent();
   System.out.println(classloader);
   ```

3. 获取扩展类加载器的父类加载器，即引导类加载器

   ```java
   classloader = classloader.getParent();
   System.out.println(classloader);
   ```

4. 测试当前类由哪个类加载器进行加载

   ```java
   classloader = Class.forName("exer2.ClassloaderDemo").getClassLoader();
   System.out.println(classloader);
   ```











